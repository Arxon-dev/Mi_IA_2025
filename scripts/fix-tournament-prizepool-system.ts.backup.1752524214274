import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

/**
 * üèÜ SCRIPT: ARREGLAR SISTEMA DE PRIZEPOOL DE TORNEOS
 * 
 * Problema identificado: Los torneos siempre muestran "0 puntos en juego"
 * porque el prizePool est√° hardcodeado en 0 durante la creaci√≥n.
 * 
 * Soluci√≥n: Implementar c√°lculo autom√°tico del prizePool basado en:
 * - N√∫mero de participantes registrados
 * - N√∫mero de preguntas del torneo
 * - Formula atractiva que motive la participaci√≥n
 */

// ‚úÖ FUNCI√ìN PARA CALCULAR PRIZEPOOL AUTOM√ÅTICAMENTE
function calculatePrizePool(participantCount: number, questionsCount: number): number {
  // F√≥rmula: Base por pregunta + bonus por participante + multiplicador de competitividad
  const basePerQuestion = 5; // 5 puntos base por pregunta
  const participantBonus = participantCount * 10; // 10 puntos adicionales por participante
  const competitivenessMultiplier = participantCount > 10 ? 1.5 : 1.2; // M√°s atractivo con m√°s gente
  
  const basePrize = (questionsCount * basePerQuestion) + participantBonus;
  const finalPrize = Math.round(basePrize * competitivenessMultiplier);
  
  // M√≠nimo garantizado de 100 puntos
  return Math.max(finalPrize, 100);
}

// ‚úÖ FUNCI√ìN PARA CALCULAR DISTRIBUCI√ìN DE PREMIOS POR POSICI√ìN
function calculatePrizeDistribution(totalPrizePool: number, participantCount: number): any[] {
  const distribution = [];
  
  // Top 3 obtienen premios especiales del pool
  const firstPlace = Math.round(totalPrizePool * 0.5);   // 50% para el 1er lugar
  const secondPlace = Math.round(totalPrizePool * 0.3);  // 30% para el 2do lugar  
  const thirdPlace = Math.round(totalPrizePool * 0.2);   // 20% para el 3er lugar
  
  distribution.push(
    { position: 1, prize: firstPlace, percentage: 50 },
    { position: 2, prize: secondPlace, percentage: 30 },
    { position: 3, prize: thirdPlace, percentage: 20 }
  );
  
  // Posiciones 4-10 obtienen puntos fijos menores
  for (let i = 4; i <= Math.min(10, participantCount); i++) {
    const fixedPrize = Math.max(20, 100 - (i * 5)); // Decremento gradual
    distribution.push({ position: i, prize: fixedPrize, percentage: 0 });
  }
  
  return distribution;
}

// ‚úÖ AN√ÅLISIS DE TORNEOS EXISTENTES
async function analyzeTournamentPrizePools() {
  console.log('üîç ANALIZANDO SISTEMA DE PREMIOS DE TORNEOS EXISTENTES...\n');
  
  // Obtener torneos con participantes
  const tournaments = await prisma.tournament.findMany({
    include: {
      participants: true,
      _count: {
        select: { participants: true }
      }
    },
    orderBy: { createdAt: 'desc' },
    take: 10
  });
  
  console.log(`üìä Analizando ${tournaments.length} torneos recientes:\n`);
  
  for (const tournament of tournaments) {
    const participantCount = tournament._count.participants;
    const currentPrizePool = tournament.prizePool;
    const suggestedPrizePool = calculatePrizePool(participantCount, tournament.questionsCount);
    const prizeDistribution = calculatePrizeDistribution(suggestedPrizePool, participantCount);
    
    console.log(`üèÜ ${tournament.name}:`);
    console.log(`   üìù Preguntas: ${tournament.questionsCount}`);
    console.log(`   üë• Participantes: ${participantCount}`);
    console.log(`   üí∞ PrizePool actual: ${currentPrizePool} puntos`);
    console.log(`   üí∞ PrizePool sugerido: ${suggestedPrizePool} puntos`);
    console.log(`   üèÖ Distribuci√≥n sugerida:`);
    prizeDistribution.slice(0, 3).forEach(p => {
      console.log(`      ${p.position}¬∫ lugar: ${p.prize} pts (${p.percentage}%)`);
    });
    console.log('');
  }
}

// ‚úÖ SIMULAR DIFERENTES ESCENARIOS
async function simulatePrizePoolScenarios() {
  console.log('üéÆ SIMULANDO DIFERENTES ESCENARIOS DE TORNEOS:\n');
  
  const scenarios = [
    { name: 'Torneo Peque√±o', participants: 5, questions: 20 },
    { name: 'Torneo Mediano', participants: 15, questions: 30 },
    { name: 'Torneo Grande', participants: 50, questions: 50 },
    { name: 'Torneo Masivo', participants: 100, questions: 25 }
  ];
  
  scenarios.forEach(scenario => {
    const prizePool = calculatePrizePool(scenario.participants, scenario.questions);
    const distribution = calculatePrizeDistribution(prizePool, scenario.participants);
    
    console.log(`üéØ ${scenario.name}:`);
    console.log(`   üë• ${scenario.participants} participantes | üìù ${scenario.questions} preguntas`);
    console.log(`   üí∞ Pool total: ${prizePool} puntos`);
    console.log(`   üèÜ Top 3:`);
    distribution.slice(0, 3).forEach(p => {
      console.log(`      ${p.position}¬∫: ${p.prize} pts`);
    });
    console.log('');
  });
}

// ‚úÖ PROPUESTA DE IMPLEMENTACI√ìN
async function showImplementationProposal() {
  console.log('üõ†Ô∏è PROPUESTA DE IMPLEMENTACI√ìN:\n');
  
  console.log('üìù 1. MODIFICAR CREACI√ìN DE TORNEOS:');
  console.log('   - Calcular prizePool autom√°ticamente en lugar de usar 0');
  console.log('   - Actualizar cuando se registren/cancelen participantes');
  console.log('');
  
  console.log('üìù 2. ARCHIVOS A MODIFICAR:');
  console.log('   - src/app/api/admin/tournaments/route.ts (l√≠nea 721)');
  console.log('   - src/services/tournamentService.ts (actualizaci√≥n din√°mica)');
  console.log('   - Notificaciones de torneos (mostrar pool atractivo)');
  console.log('');
  
  console.log('üìù 3. BENEFICIOS:');
  console.log('   ‚úÖ Torneos m√°s atractivos visualmente');
  console.log('   ‚úÖ Motivaci√≥n clara para participar');
  console.log('   ‚úÖ Escalabilidad autom√°tica del premio');
  console.log('   ‚úÖ Transparencia en la distribuci√≥n de premios');
  console.log('');
  
  console.log('üìù 4. MENSAJE MEJORADO QUEDAR√çA AS√ç:');
  const exampleParticipants = 25;
  const exampleQuestions = 20;
  const examplePrizePool = calculatePrizePool(exampleParticipants, exampleQuestions);
  
  console.log(`   üèÜ PERMA 42 #4d82dd92-f5be-4bef-90f0-ecef3d39d317`);
  console.log(`   ‚è∞ Inicio: 18:00:00`);
  console.log(`   üë• ${exampleParticipants}/100 participantes`);
  console.log(`   üìù ${exampleQuestions} preguntas | üí∞ ${examplePrizePool} puntos en juego`);
  console.log(`   üèÖ 1¬∫: ${Math.round(examplePrizePool * 0.5)} pts | 2¬∫: ${Math.round(examplePrizePool * 0.3)} pts | 3¬∫: ${Math.round(examplePrizePool * 0.2)} pts`);
  console.log('');
}

// üéØ EJECUTAR AN√ÅLISIS COMPLETO
async function main() {
  try {
    console.log('üèÜ ===== AN√ÅLISIS DEL SISTEMA DE PREMIOS DE TORNEOS =====\n');
    
    await analyzeTournamentPrizePools();
    await simulatePrizePoolScenarios();
    await showImplementationProposal();
    
    console.log('‚úÖ AN√ÅLISIS COMPLETADO - Listo para implementar las mejoras!');
    
  } catch (error) {
    console.error('‚ùå Error en el an√°lisis:', error);
  } finally {
    await prisma.$disconnect();
  }
}

// Ejecutar si es llamado directamente
if (require.main === module) {
  main();
}

export { calculatePrizePool, calculatePrizeDistribution }; 