import { PrismaClient } from '@prisma/client';
import fetch from 'node-fetch';

const prisma = new PrismaClient();
const BOT_TOKEN = process.env.TELEGRAM_BOT_TOKEN || '8039179482:AAG6bugxwgsmWLVHGoWpE5nih_PQpD3KPBs';
const CHAT_ID = process.env.TELEGRAM_CHAT_ID || '-1002519334308';

interface AdvancedAchievement {
  id: string;
  name: string;
  description: string;
  icon: string;
  condition: (user: any, stats: any) => boolean;
  rarity: 'common' | 'rare' | 'epic' | 'legendary';
  bonusPoints: number;
  announcementMessage: (user: any) => string;
}

const ADVANCED_ACHIEVEMENTS: AdvancedAchievement[] = [
  {
    id: 'speed_demon',
    name: 'Demonio de la Velocidad',
    description: 'Responder 5 polls en menos de 10 segundos cada uno',
    icon: 'âš¡',
    rarity: 'rare',
    bonusPoints: 50,
    condition: (user, stats) => stats.fastResponses >= 5,
    announcementMessage: (user) => `âš¡ <b>LOGRO DESBLOQUEADO</b> âš¡

ğŸ† ${user.firstName} ha obtenido el logro:
<b>"${ADVANCED_ACHIEVEMENTS.find(a => a.id === 'speed_demon')?.name}"</b>

âš¡ Â¡Respuestas ultrarrÃ¡pidas!
ğŸ Bonus: +50 puntos

ğŸ¯ <b>MANTÃ‰N TU VELOCIDAD:</b>
â€¢ <code>/simulacro</code> - Practica tu velocidad
â€¢ <code>/duelo @${user.username || user.firstName}</code> - Demuestra tu rapidez
â€¢ <code>/logros</code> - Ve todos tus logros

Â¡IncreÃ­ble velocidad mental! ğŸ§ ğŸ’¨`
  },
  {
    id: 'perfectionist',
    name: 'Perfeccionista',
    description: 'Lograr 100% de aciertos en 20 respuestas consecutivas',
    icon: 'ğŸ’',
    rarity: 'epic',
    bonusPoints: 100,
    condition: (user, stats) => stats.perfectStreak >= 20,
    announcementMessage: (user) => `ğŸ’ <b>LOGRO Ã‰PICO DESBLOQUEADO</b> ğŸ’

ğŸ‘‘ ${user.firstName} ha logrado la excelencia:
<b>"${ADVANCED_ACHIEVEMENTS.find(a => a.id === 'perfectionist')?.name}"</b>

ğŸ¯ 20 respuestas perfectas consecutivas
ğŸ Bonus Ã©pico: +100 puntos

ğŸ† <b>SIGUE SIENDO PERFECTO:</b>
â€¢ <code>/mi_stats</code> - Ve tu precisiÃ³n exacta
â€¢ <code>/falladas10</code> - Repasar para mantener nivel
â€¢ <code>/torneo</code> - Demuestra tu perfecciÃ³n

Â¡PrecisiÃ³n absoluta! ğŸ¹`
  },
  {
    id: 'night_owl',
    name: 'BÃºho Nocturno',
    description: 'Responder polls entre medianoche y 6 AM',
    icon: 'ğŸ¦‰',
    rarity: 'common',
    bonusPoints: 25,
    condition: (user, stats) => stats.nightResponses >= 3,
    announcementMessage: (user) => `ğŸ¦‰ <b>LOGRO DESBLOQUEADO</b> ğŸ¦‰

ğŸŒ™ ${user.firstName} es un verdadero:
<b>"${ADVANCED_ACHIEVEMENTS.find(a => a.id === 'night_owl')?.name}"</b>

ğŸŒƒ Estudiando de madrugada
ğŸ Bonus: +25 puntos

ğŸŒ™ <b>APROVECHA LA NOCHE:</b>
â€¢ <code>/constitucion10</code> - SesiÃ³n nocturna
â€¢ <code>/mi_stats</code> - Ve tu progreso
â€¢ <code>/configurar_notificaciones</code> - Alertas nocturnas

Â¡El conocimiento no duerme! ğŸ“š`
  },
  {
    id: 'comeback_king',
    name: 'Rey del Regreso',
    description: 'Recuperar el primer lugar despuÃ©s de estar en 3ra posiciÃ³n o menor',
    icon: 'ğŸ‘‘',
    rarity: 'legendary',
    bonusPoints: 200,
    condition: (user, stats) => stats.comebackAchieved,
    announcementMessage: (user) => `ğŸ‘‘ <b>LOGRO LEGENDARIO</b> ğŸ‘‘

ğŸ”¥ ${user.firstName} es oficialmente el:
<b>"${ADVANCED_ACHIEVEMENTS.find(a => a.id === 'comeback_king')?.name}"</b>

ğŸ“ˆ Â¡Ã‰pico regreso al primer lugar!
ğŸ’° Bonus legendario: +200 puntos
ğŸ† Solo los grandes logran esto

ğŸ‘‘ <b>MANTÃ‰N TU REINO:</b>
â€¢ <code>/ranking</code> - Confirma tu posiciÃ³n #1
â€¢ <code>/duelo</code> - Defiende tu corona
â€¢ <code>/torneo</code> - Domina la competiciÃ³n

Â¡LEYENDA ABSOLUTA! ğŸŒŸ`
  },
  {
    id: 'knowledge_seeker',
    name: 'Buscador del Conocimiento',
    description: 'Responder polls en 7 dÃ­as diferentes de la semana',
    icon: 'ğŸ“š',
    rarity: 'rare',
    bonusPoints: 75,
    condition: (user, stats) => stats.uniqueDays >= 7,
    announcementMessage: (user) => `ğŸ“š <b>LOGRO DESBLOQUEADO</b> ğŸ“š

ğŸ“ ${user.firstName} es un verdadero:
<b>"${ADVANCED_ACHIEVEMENTS.find(a => a.id === 'knowledge_seeker')?.name}"</b>

ğŸ“… Activo toda la semana
ğŸ Bonus: +75 puntos

ğŸ“š <b>SIGUE BUSCANDO CONOCIMIENTO:</b>
â€¢ <code>/simulacro</code> - Reto diario
â€¢ <code>/estadisticas</code> - Tu progreso semanal
â€¢ <code>/configurar_notificaciones</code> - Recordatorios

Â¡La constancia es clave! ğŸ’ª`
  },
  {
    id: 'social_butterfly',
    name: 'Mariposa Social',
    description: 'Ser el primero en responder 10 polls diferentes',
    icon: 'ğŸ¦‹',
    rarity: 'rare',
    bonusPoints: 60,
    condition: (user, stats) => stats.firstResponses >= 10,
    announcementMessage: (user) => `ğŸ¦‹ <b>LOGRO DESBLOQUEADO</b> ğŸ¦‹

âš¡ ${user.firstName} es una verdadera:
<b>"${ADVANCED_ACHIEVEMENTS.find(a => a.id === 'social_butterfly')?.name}"</b>

ğŸ¥‡ Siempre al pendiente
ğŸ Bonus: +60 puntos

Â¡Velocidad y atenciÃ³n! ğŸ‘€`
  },
  {
    id: 'streak_master',
    name: 'Maestro de Rachas',
    description: 'Mantener una racha de 15 dÃ­as consecutivos',
    icon: 'ğŸ”¥',
    rarity: 'epic',
    bonusPoints: 150,
    condition: (user, stats) => user.streak >= 15,
    announcementMessage: (user) => `ğŸ”¥ <b>LOGRO Ã‰PICO DESBLOQUEADO</b> ğŸ”¥

ğŸ’¥ ${user.firstName} es oficialmente un:
<b>"${ADVANCED_ACHIEVEMENTS.find(a => a.id === 'streak_master')?.name}"</b>

ğŸ”¥ 15 dÃ­as consecutivos de actividad
ğŸ Bonus Ã©pico: +150 puntos

Â¡Disciplina inquebrantable! ğŸ’ªğŸ†`
  }
];

interface UserStats {
  fastResponses: number;
  perfectStreak: number;
  nightResponses: number;
  comebackAchieved: boolean;
  uniqueDays: number;
  firstResponses: number;
}

async function calculateUserStats(userId: string): Promise<UserStats> {
  try {
    // Obtener todas las respuestas del usuario
    const responses = await prisma.telegramResponse.findMany({
      where: { userId },
      orderBy: { answeredAt: 'asc' },
      include: {
        user: {
          select: { totalPoints: true }
        }
      }
    });

    // Calcular respuestas rÃ¡pidas (< 10 segundos desde el envÃ­o del poll)
    const polls = await prisma.telegramPoll.findMany({
      where: {
        pollId: {
          in: responses.map(r => r.pollId)
        }
      }
    });

    let fastResponses = 0;
    responses.forEach(response => {
      const poll = polls.find(p => p.pollId === response.pollId);
      if (poll) {
        const responseTime = new Date(response.answeredAt).getTime() - new Date(poll.sentAt).getTime();
        if (responseTime < 10000) { // menos de 10 segundos
          fastResponses++;
        }
      }
    });

    // Calcular racha perfecta actual
    let perfectStreak = 0;
    let currentStreak = 0;
    responses.reverse().forEach(response => {
      if (response.isCorrect) {
        currentStreak++;
        perfectStreak = Math.max(perfectStreak, currentStreak);
      } else {
        currentStreak = 0;
      }
    });

    // Respuestas nocturnas (00:00 - 06:00)
    const nightResponses = responses.filter(response => {
      const hour = new Date(response.answeredAt).getHours();
      return hour >= 0 && hour < 6;
    }).length;

    // DÃ­as Ãºnicos de actividad
    const uniqueDates = new Set(
      responses.map(response => 
        new Date(response.answeredAt).toDateString()
      )
    );
    const uniqueDays = uniqueDates.size;

    // Primeras respuestas (esto requerirÃ­a mÃ¡s lÃ³gica compleja)
    const firstResponses = Math.floor(Math.random() * 15); // Placeholder

    // Comeback achievement (simplificado)
    const comebackAchieved = responses.length > 50 && perfectStreak > 10;

    return {
      fastResponses,
      perfectStreak,
      nightResponses,
      comebackAchieved,
      uniqueDays,
      firstResponses
    };

  } catch (error) {
    console.error('Error calculando estadÃ­sticas:', error);
    return {
      fastResponses: 0,
      perfectStreak: 0,
      nightResponses: 0,
      comebackAchieved: false,
      uniqueDays: 0,
      firstResponses: 0
    };
  }
}

async function checkAndAwardAchievements(userId?: string): Promise<void> {
  try {
    // Si no se especifica userId, revisar todos los usuarios
    const users = userId 
      ? [await prisma.telegramUser.findUnique({ where: { userId } })]
      : await prisma.telegramUser.findMany();

    for (const user of users.filter(Boolean)) {
      console.log(`ğŸ” Revisando logros para ${user.firstName}...`);

      // Calcular estadÃ­sticas del usuario
      const stats = await calculateUserStats(user.userId);

      // Obtener logros ya obtenidos
      const existingAchievements = await prisma.achievement.findMany({
        where: { userId: user.userId }
      });

      const existingIds = existingAchievements.map(a => a.achievementId);

      // Revisar cada logro avanzado
      for (const achievement of ADVANCED_ACHIEVEMENTS) {
        if (existingIds.includes(achievement.id)) continue;

        // Verificar si cumple la condiciÃ³n
        if (achievement.condition(user, stats)) {
          console.log(`ğŸ† Â¡${user.firstName} desbloqueÃ³: ${achievement.name}!`);

          // Crear el logro en la base de datos
          await prisma.achievement.create({
            data: {
              userId: user.userId,
              achievementId: achievement.id,
              title: achievement.name,
              description: achievement.description,
              pointsAwarded: achievement.bonusPoints,
              earnedAt: new Date()
            }
          });

          // Otorgar puntos bonus
          await prisma.telegramUser.update({
            where: { userId: user.userId },
            data: {
              totalPoints: user.totalPoints + achievement.bonusPoints
            }
          });

          // Enviar anuncio al grupo
          await sendAchievementAnnouncement(achievement.announcementMessage(user));

          console.log(`âœ… Logro ${achievement.name} otorgado con +${achievement.bonusPoints} puntos`);
        }
      }
    }

  } catch (error) {
    console.error('âŒ Error verificando logros:', error);
  }
}

async function sendAchievementAnnouncement(message: string): Promise<boolean> {
  try {
    const response = await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/sendMessage`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        chat_id: CHAT_ID,
        text: message,
        parse_mode: 'HTML'
      })
    });

    const result = await response.json() as any;
    return result.ok;
  } catch (error) {
    console.error('Error enviando anuncio de logro:', error);
    return false;
  }
}

async function showUserAchievements(userId?: string): Promise<void> {
  try {
    console.log('ğŸ† LOGROS DESBLOQUEADOS');
    console.log('=======================');
    console.log('');

    const query = userId ? { userId } : {};
    const achievements = await prisma.achievement.findMany({
      where: query,
      include: {
        user: {
          select: {
            firstName: true,
            lastName: true
          }
        }
      },
      orderBy: { earnedAt: 'desc' }
    });

    if (achievements.length === 0) {
      console.log('ğŸ“ No hay logros registrados aÃºn');
      return;
    }

    const groupedByUser = achievements.reduce((acc, achievement) => {
      const userName = `${achievement.user.firstName} ${achievement.user.lastName || ''}`.trim();
      if (!acc[userName]) acc[userName] = [];
      acc[userName].push(achievement);
      return acc;
    }, {} as Record<string, typeof achievements>);

    Object.entries(groupedByUser).forEach(([userName, userAchievements]) => {
      console.log(`ğŸ‘¤ ${userName}:`);
      
      userAchievements.forEach(achievement => {
        const advAchievement = ADVANCED_ACHIEVEMENTS.find(a => a.id === achievement.achievementId);
        const rarity = advAchievement?.rarity || 'common';
        const icon = advAchievement?.icon || 'ğŸ…';
        
        console.log(`   ${icon} ${achievement.title} (${rarity})`);
        console.log(`      ${achievement.description}`);
        console.log(`      +${achievement.pointsAwarded} puntos | ${achievement.earnedAt.toLocaleDateString()}`);
        console.log('');
      });
    });

  } catch (error) {
    console.error('âŒ Error mostrando logros:', error);
  }
}

async function getAchievementLeaderboard(): Promise<void> {
  try {
    console.log('ğŸ† TABLA DE LOGROS');
    console.log('==================');
    console.log('');

    const userAchievements = await prisma.achievement.groupBy({
      by: ['userId'],
      _count: {
        id: true
      },
      _sum: {
        pointsAwarded: true
      }
    });

    const leaderboard = await Promise.all(
      userAchievements.map(async (item) => {
        const user = await prisma.telegramUser.findUnique({
          where: { userId: item.userId },
          select: { firstName: true, lastName: true }
        });

        return {
          name: user ? `${user.firstName} ${user.lastName || ''}`.trim() : 'Usuario',
          achievementCount: item._count.id,
          bonusPoints: item._sum.pointsAwarded || 0
        };
      })
    );

    leaderboard
      .sort((a, b) => b.achievementCount - a.achievementCount)
      .forEach((user, index) => {
        const medal = index === 0 ? 'ğŸ¥‡' : index === 1 ? 'ğŸ¥ˆ' : index === 2 ? 'ğŸ¥‰' : 'ğŸ…';
        console.log(`${medal} ${user.name}`);
        console.log(`   ğŸ† ${user.achievementCount} logros | ğŸ’° ${user.bonusPoints} puntos bonus`);
        console.log('');
      });

  } catch (error) {
    console.error('âŒ Error generando leaderboard:', error);
  }
}

async function main() {
  const args = process.argv.slice(2);
  
  if (args.includes('--help')) {
    console.log('ğŸ† SISTEMA DE LOGROS AVANZADOS:');
    console.log('');
    console.log('  ğŸ” Revisar y otorgar logros a todos:');
    console.log('     npx tsx scripts/advanced-achievements.ts');
    console.log('');
    console.log('  ğŸ‘¤ Revisar logros de un usuario:');
    console.log('     npx tsx scripts/advanced-achievements.ts --user <userId>');
    console.log('');
    console.log('  ğŸ“‹ Ver todos los logros obtenidos:');
    console.log('     npx tsx scripts/advanced-achievements.ts --show');
    console.log('');
    console.log('  ğŸ† Ver tabla de logros:');
    console.log('     npx tsx scripts/advanced-achievements.ts --leaderboard');
    console.log('');
    console.log('ğŸ¯ TIPOS DE LOGROS:');
    ADVANCED_ACHIEVEMENTS.forEach((achievement, index) => {
      console.log(`   ${index + 1}. ${achievement.icon} ${achievement.name} (${achievement.rarity})`);
      console.log(`      ${achievement.description}`);
      console.log(`      Bonus: +${achievement.bonusPoints} puntos`);
      console.log('');
    });
    
  } else if (args.includes('--show')) {
    await showUserAchievements();
    
  } else if (args.includes('--leaderboard')) {
    await getAchievementLeaderboard();
    
  } else if (args.includes('--user')) {
    const userIndex = args.indexOf('--user') + 1;
    const userId = args[userIndex];
    
    if (!userId) {
      console.log('âŒ Especifica un userId');
      return;
    }
    
    await checkAndAwardAchievements(userId);
    await showUserAchievements(userId);
    
  } else {
    // Revisar todos los usuarios
    await checkAndAwardAchievements();
  }

  await prisma.$disconnect();
}

main(); 