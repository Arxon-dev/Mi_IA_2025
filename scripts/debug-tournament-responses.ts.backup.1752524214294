// Script para debuggear espec√≠ficamente el problema de handleTournamentPollAnswer
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

async function debugTournamentResponseProcessing() {
  try {
    console.log('üîç DEBUG: ¬øPor qu√© handleTournamentPollAnswer intercepta todos los polls?');
    console.log('==================================================================');
    
    // 1. Verificar polls recientes
    console.log('üìä 1. POLLS RECIENTES EN BD:');
    console.log('============================');
    
    const recentPolls = await prisma.telegramPoll.findMany({
      orderBy: { createdAt: 'desc' },
      take: 5,
      select: {
        pollId: true,
        sourceModel: true,
        createdAt: true,
        questionId: true
      }
    });
    
    console.log('√öltimos 5 polls en telegramPoll:');
    recentPolls.forEach((poll, i) => {
      console.log(`   ${i + 1}. Poll ID: ${poll.pollId}`);
      console.log(`      Source: ${poll.sourceModel}`);
      console.log(`      Fecha: ${poll.createdAt.toLocaleString('es-ES')}`);
      console.log(`      Question ID: ${poll.questionId}`);
      console.log('');
    });
    
    // 2. Verificar respuestas de torneos
    console.log('üèÜ 2. RESPUESTAS DE TORNEOS:');
    console.log('============================');
    
    const tournamentResponses = await prisma.tournamentResponse.findMany({
      orderBy: { answeredAt: 'desc' },
      take: 10,
      select: {
        pollId: true,
        selectedOption: true,
        isCorrect: true,
        answeredAt: true,
        participant: {
          select: {
            user: {
              select: {
                firstName: true,
                telegramUserId: true
              }
            },
            tournament: {
              select: {
                name: true,
                status: true
              }
            }
          }
        }
      }
    });
    
    console.log(`√öltimas ${tournamentResponses.length} respuestas de torneos:`);
    tournamentResponses.forEach((resp, i) => {
      console.log(`   ${i + 1}. Usuario: ${resp.participant.user.firstName}`);
      console.log(`      Torneo: ${resp.participant.tournament.name}`);
      console.log(`      Poll ID: ${resp.pollId || 'NULL'}`);
      console.log(`      Respondido: ${resp.answeredAt ? resp.answeredAt.toLocaleString('es-ES') : 'No'}`);
      console.log('');
    });
    
    // 3. Verificar si hay solapamiento problem√°tico
    console.log('‚ö†Ô∏è 3. AN√ÅLISIS DE POSIBLE PROBLEMA:');
    console.log('====================================');
    
    // Buscar si hay TournamentResponse sin pollId que puedan estar causando problemas
    const responsesSinPollId = await prisma.tournamentResponse.findMany({
      where: {
        OR: [
          { pollId: null },
          { pollId: '' }
        ]
      },
      include: {
        participant: {
          include: {
            user: { select: { firstName: true } },
            tournament: { select: { name: true, status: true } }
          }
        }
      }
    });
    
    console.log(`üö® Respuestas de torneo SIN pollId: ${responsesSinPollId.length}`);
    responsesSinPollId.forEach((resp, i) => {
      console.log(`   ${i + 1}. Usuario: ${resp.participant.user.firstName}`);
      console.log(`      Torneo: ${resp.participant.tournament.name}`);
      console.log(`      Status torneo: ${resp.participant.tournament.status}`);
      console.log(`      Pregunta #: ${resp.questionNumber}`);
      console.log('');
    });
    
    // 4. Simular la l√≥gica de handleTournamentPollAnswer
    console.log('üß™ 4. SIMULACI√ìN DE handleTournamentPollAnswer:');
    console.log('================================================');
    
    // Tomar el poll m√°s reciente que NO sea de torneo
    const latestNonTournamentPoll = recentPolls.find(p => p.sourceModel === 'validQuestion');
    
    if (latestNonTournamentPoll) {
      console.log(`üéØ Probando con poll regular: ${latestNonTournamentPoll.pollId}`);
      
      // Simular la consulta que hace handleTournamentPollAnswer
      const simulatedUserId = '12345'; // Usuario ficticio
      const testResponse = await prisma.tournamentResponse.findFirst({
        where: {
          pollId: latestNonTournamentPoll.pollId,
          participant: {
            user: {
              telegramUserId: simulatedUserId
            }
          }
        }
      });
      
      console.log(`   Query result: ${testResponse ? '‚úÖ ENCONTR√ì respuesta de torneo' : '‚ùå No encontr√≥ respuesta de torneo'}`);
      
      if (!testResponse) {
        console.log('   ‚úÖ CORRECTO: Este poll NO es de torneo, funci√≥n deber√≠a devolver false');
      } else {
        console.log('   üö® PROBLEMA: Este poll regular est√° siendo tratado como de torneo!');
      }
    }
    
    // 5. Buscar el problema real
    console.log('üîç 5. B√öSQUEDA DEL PROBLEMA REAL:');
    console.log('==================================');
    
    // Verificar si hay TournamentResponse con pollIds que coinciden con polls regulares
    const problematicMatches = await prisma.$queryRaw`
      SELECT 
        tr.pollId,
        tr.questionNumber,
        tp.pollId as telegramPollId,
        tp.sourceModel,
        tu.firstName,
        t.name as tournamentName
      FROM TournamentResponse tr
      JOIN TournamentParticipant tpart ON tr.participantId = tpart.id
      JOIN TelegramUser tu ON tpart.userId = tu.id  
      JOIN Tournament t ON tpart.tournamentId = t.id
      LEFT JOIN TelegramPoll tp ON tr.pollId = tp.pollId
      WHERE tr.pollId IS NOT NULL 
        AND tr.pollId != ''
        AND tp.sourceModel = 'validQuestion'
      LIMIT 5
    `;
    
    console.log('üî• POLLS PROBLEM√ÅTICOS (TournamentResponse usando pollIds de preguntas regulares):');
    console.log(problematicMatches);
    
    return {
      totalPolls: recentPolls.length,
      tournamentResponses: tournamentResponses.length,
      problematicResponses: responsesSinPollId.length,
      problematicMatches: (problematicMatches as any[]).length
    };
    
  } catch (error) {
    console.error('‚ùå Error en debug:', error);
    return null;
  } finally {
    await prisma.$disconnect();
  }
}

async function main() {
  const results = await debugTournamentResponseProcessing();
  
  if (results) {
    console.log('\nüìã RESUMEN DEL DIAGN√ìSTICO:');
    console.log('============================');
    console.log(`üìä Polls totales: ${results.totalPolls}`);
    console.log(`üèÜ Respuestas de torneo: ${results.tournamentResponses}`);
    console.log(`‚ö†Ô∏è Respuestas sin pollId: ${results.problematicResponses}`);
    console.log(`üî• Coincidencias problem√°ticas: ${results.problematicMatches}`);
    
    if (results.problematicMatches > 0) {
      console.log('\nüö® PROBLEMA ENCONTRADO: Hay TournamentResponse usando pollIds de preguntas regulares!');
      console.log('üìù ESTO EXPLICAR√çA por qu√© handleTournamentPollAnswer intercepta polls normales.');
    } else if (results.problematicResponses > 0) {
      console.log('\n‚ö†Ô∏è POSIBLE PROBLEMA: Hay respuestas de torneo sin pollId que pueden interferir.');
    } else {
      console.log('\n‚úÖ No se encontraron problemas obvios en los datos.');
      console.log('üîç El problema puede estar en la l√≥gica de la funci√≥n.');
    }
  }
}

main(); 