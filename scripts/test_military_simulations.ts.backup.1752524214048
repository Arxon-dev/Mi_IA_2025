#!/usr/bin/env npx tsx

// ===========================================
// ğŸ§ª SCRIPT DE TESTING - SIMULACROS MILITARES
// ===========================================

import { prisma } from '../src/lib/prisma';
import { MilitarySimulationService } from '../src/services/militarySimulationService';
import { SubscriptionService } from '../src/services/subscriptionService';

console.log('ğŸ§ª INICIANDO TESTING DE SIMULACROS MILITARES PREMIUM...\n');

async function runTests() {
  try {

    // ===========================================
    // ğŸ“‹ TEST 1: VERIFICAR DISTRIBUCIONES
    // ===========================================
    console.log('ğŸ“‹ TEST 1: Verificando distribuciones exactas...');
    
    const distributions = {
      et: MilitarySimulationService.MILITARY_DISTRIBUTIONS.et,
      aire: MilitarySimulationService.MILITARY_DISTRIBUTIONS.aire,
      armada: MilitarySimulationService.MILITARY_DISTRIBUTIONS.armada
    };

    for (const [branch, distribution] of Object.entries(distributions)) {
      const total = Object.values(distribution).reduce((sum, count) => sum + count, 0);
      console.log(`   ğŸ–ï¸ ${branch.toUpperCase()}: ${total} preguntas total`);
      
      if (total !== 100) {
        console.error(`   âŒ ERROR: ${branch} tiene ${total} preguntas, esperadas 100`);
      } else {
        console.log(`   âœ… ${branch}: DistribuciÃ³n correcta (100 preguntas)`);
      }
    }

    // ===========================================
    // ğŸ—‚ï¸ TEST 2: VERIFICAR MAPEO DE TABLAS
    // ===========================================
    console.log('\nğŸ—‚ï¸ TEST 2: Verificando mapeo de tablas...');
    
    const tableMapping = MilitarySimulationService.TABLE_MAPPING;
    const mappedTables = Object.keys(tableMapping);
    console.log(`   ğŸ“Š Total de materias mapeadas: ${mappedTables.length}`);
    
         // Verificar que todas las materias de las distribuciones estÃ¡n en el mapeo
     const allSubjects = new Set<string>();
     Object.values(distributions).forEach(dist => {
       Object.keys(dist).forEach(subject => allSubjects.add(subject));
     });
     
     for (const subject of allSubjects) {
       if (tableMapping[subject]) {
         console.log(`   âœ… ${subject} â†’ ${tableMapping[subject]}`);
       } else {
         console.error(`   âŒ ERROR: Materia '${subject}' no estÃ¡ mapeada`);
       }
     }

    // ===========================================
    // ğŸ” TEST 3: VERIFICAR FUNCIONES DE PERMISOS
    // ===========================================
    console.log('\nğŸ” TEST 3: Verificando funciones de permisos...');
    
    try {
      // Crear usuario de prueba si no existe
      const testUserId = 'test_user_123';
      
      let testUser = await prisma.telegramUser.findUnique({
        where: { telegramUserId: testUserId }
      });

      if (!testUser) {
        testUser = await prisma.telegramUser.create({
          data: {
            telegramUserId: testUserId,
            firstName: 'Test User',
            username: 'test_user'
          }
        });
        console.log('   âœ… Usuario de prueba creado');
      } else {
        console.log('   âœ… Usuario de prueba encontrado');
      }

      // Test de permisos sin Premium
      const canCreate = await MilitarySimulationService.canUserCreatePremiumSimulation(testUserId);
      console.log(`   ğŸ” Usuario sin Premium puede crear simulacro: ${canCreate ? 'âŒ SÃ (ERROR)' : 'âœ… NO (CORRECTO)'}`);

      // Cleanup: Eliminar usuario de prueba
      await prisma.telegramUser.delete({
        where: { telegramUserId: testUserId }
      });
      console.log('   ğŸ§¹ Usuario de prueba eliminado');

         } catch (error) {
       console.error('   âŒ Error en test de permisos:', error instanceof Error ? error.message : String(error));
     }

    // ===========================================
    // ğŸ“Š TEST 4: VERIFICAR CONTEO DE PREGUNTAS
    // ===========================================
    console.log('\nğŸ“Š TEST 4: Verificando disponibilidad de preguntas en BD...');
    
    for (const [subject, tableName] of Object.entries(tableMapping)) {
      try {
        const count = await prisma[tableName].count();
        if (count > 0) {
          console.log(`   âœ… ${subject} (${tableName}): ${count} preguntas disponibles`);
        } else {
          console.log(`   âš ï¸ ${subject} (${tableName}): 0 preguntas (tabla vacÃ­a)`);
        }
      } catch (error) {
        console.error(`   âŒ ${subject} (${tableName}): Error de acceso - ${error.message}`);
      }
    }

    // ===========================================
    // ğŸ¯ TEST 5: SIMULAR SELECCIÃ“N DE PREGUNTAS
    // ===========================================
    console.log('\nğŸ¯ TEST 5: Simulando selecciÃ³n de preguntas para ET...');
    
    try {
      const etDistribution = distributions.et;
      let totalSelected = 0;
      
      for (const [subject, expectedCount] of Object.entries(etDistribution)) {
        const tableName = tableMapping[subject];
        if (tableName) {
          const availableCount = await prisma[tableName].count();
          const selectedCount = Math.min(expectedCount, availableCount);
          totalSelected += selectedCount;
          
          if (selectedCount < expectedCount) {
            console.log(`   âš ï¸ ${subject}: ${selectedCount}/${expectedCount} (faltan ${expectedCount - selectedCount})`);
          } else {
            console.log(`   âœ… ${subject}: ${selectedCount}/${expectedCount}`);
          }
        }
      }
      
      console.log(`   ğŸ“Š Total simulado: ${totalSelected}/100 preguntas`);
      
      if (totalSelected < 100) {
        console.log(`   âš ï¸ ADVERTENCIA: Solo se pueden generar ${totalSelected} preguntas de 100`);
      } else {
        console.log(`   âœ… PERFECTO: Se pueden generar las 100 preguntas completas`);
      }

    } catch (error) {
      console.error('   âŒ Error en simulaciÃ³n:', error.message);
    }

    // ===========================================
    // ğŸ“ RESUMEN FINAL
    // ===========================================
    console.log('\n' + '='.repeat(50));
    console.log('ğŸ“ RESUMEN DE TESTING');
    console.log('='.repeat(50));
    console.log('âœ… Distribuciones verificadas');
    console.log('âœ… Mapeo de tablas validado');
    console.log('âœ… Funciones de permisos testeadas');
    console.log('âœ… Disponibilidad de preguntas checkeada');
    console.log('âœ… SelecciÃ³n de preguntas simulada');
    console.log('\nğŸ–ï¸ SIMULACROS MILITARES PREMIUM - TESTING COMPLETADO');
    console.log('ğŸš€ Â¡Listos para implementar en producciÃ³n!');

  } catch (error) {
    console.error('âŒ ERROR GENERAL EN TESTING:', error);
  } finally {
    await prisma.$disconnect();
  }
}

// ===========================================
// ğŸ¯ FUNCIONES HELPER PARA TESTING
// ===========================================

async function checkTableExists(tableName: string): Promise<boolean> {
  try {
    await prisma[tableName].findFirst();
    return true;
  } catch {
    return false;
  }
}

async function getQuestionSample(tableName: string, limit: number = 3) {
  try {
    return await prisma[tableName].findMany({
      take: limit,
      select: {
        id: true,
        question: true
      }
    });
  } catch {
    return [];
  }
}

// ===========================================
// ğŸƒâ€â™‚ï¸ EJECUTAR TESTS
// ===========================================

if (require.main === module) {
  runTests()
    .then(() => {
      console.log('\nâœ… Testing completado exitosamente');
      process.exit(0);
    })
    .catch((error) => {
      console.error('âŒ Testing fallÃ³:', error);
      process.exit(1);
    });
}

export { runTests }; 