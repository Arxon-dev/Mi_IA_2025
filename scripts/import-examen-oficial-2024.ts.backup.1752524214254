import { PrismaClient } from '@prisma/client';
import * as fs from 'fs';
import * as path from 'path';

const prisma = new PrismaClient();

// RESPUESTAS CORRECTAS DEL EXAMEN OFICIAL 2024
// Extra√≠das de la plantilla oficial de respuestas
const RESPUESTAS_CORRECTAS_2024: { [key: number]: string } = {
  1: 'c', 2: 'c', 3: 'c', 4: 'c', 5: 'c',
  6: 'c', 7: 'c', 8: 'c', 9: 'c', 10: 'd',
  11: 'c', 12: 'c', 13: 'd', 14: 'd', 15: 'a',
  16: 'c', 17: 'c', 18: 'd', 19: 'c', 20: 'a',
  21: 'c', 22: 'a', 23: 'd', 24: 'c', 25: 'd',
  26: 'c', 27: 'a', 28: 'd', 29: 'a', 30: 'c',
  31: 'c', 32: 'c', 33: 'd', 34: 'd', 35: 'c',
  36: 'd', 37: 'c', 38: 'c', 39: 'c', 40: 'c',
  41: 'c', 42: 'd', 43: 'c', 44: 'd', 45: 'c',
  46: 'c', 47: 'c', 48: 'd', 49: 'd', 50: 'd',
  51: 'd', 52: 'c', 53: 'c', 54: 'c', 55: 'c',
  56: 'a', 57: 'a', 58: 'c', 59: 'a', 60: 'c',
  61: 'c', 62: 'a', 63: 'c', 64: 'c', 65: 'c',
  66: 'c', 67: 'c', 68: 'c', 69: 'c', 70: 'c',
  71: 'c', 72: 'c', 73: 'c', 74: 'c', 75: 'a',
  76: 'c', 77: 'a', 78: 'c', 79: 'c', 80: 'a',
  81: 'c', 82: 'c', 83: 'c', 84: 'a', 85: 'c',
  86: 'c', 87: 'c', 88: 'a', 89: 'c', 90: 'a',
  91: 'c', 92: 'a', 93: 'c', 94: 'a', 95: 'c',
  96: 'c', 97: 'c', 98: 'c', 99: 'c', 100: 'c'
};

interface ParsedQuestion {
  questionNumber: number;
  question: string;
  options: string[];
  category?: string;
}

function parseQuestionText(text: string): ParsedQuestion[] {
  const questions: ParsedQuestion[] = [];
  
  // Dividir el texto en l√≠neas
  const lines = text.split('\n').map(line => line.trim()).filter(line => line.length > 0);
  
  let currentQuestion: Partial<ParsedQuestion> = {};
  let currentQuestionText = '';
  let currentOptions: string[] = [];
  let collectingQuestion = false;
  
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    
    // Detectar inicio de pregunta (n√∫mero seguido de punto)
    const questionMatch = line.match(/^(\d+)\.\s*(.*)/);
    if (questionMatch) {
      // Guardar la pregunta anterior si existe
      if (currentQuestion.questionNumber && currentQuestionText && currentOptions.length > 0) {
        questions.push({
          questionNumber: currentQuestion.questionNumber,
          question: currentQuestionText.trim(),
          options: [...currentOptions],
          category: extractCategory(currentQuestionText)
        });
      }
      
      // Iniciar nueva pregunta
      const questionNumber = parseInt(questionMatch[1]);
      currentQuestion = { questionNumber };
      currentQuestionText = questionMatch[2];
      currentOptions = [];
      collectingQuestion = true;
      continue;
    }
    
    // Si estamos recolectando una pregunta
    if (collectingQuestion) {
      // Detectar opciones (a), b), c), d))
      const optionMatch = line.match(/^([a-d])\)\s*(.*)/);
      if (optionMatch) {
        currentOptions.push(optionMatch[2].trim());
        continue;
      }
      
      // Si no es una opci√≥n y tenemos 4 opciones, es el fin de la pregunta
      if (currentOptions.length === 4) {
        if (currentQuestion.questionNumber && currentQuestionText) {
          questions.push({
            questionNumber: currentQuestion.questionNumber,
            question: currentQuestionText.trim(),
            options: [...currentOptions],
            category: extractCategory(currentQuestionText)
          });
        }
        collectingQuestion = false;
        currentQuestion = {};
        currentQuestionText = '';
        currentOptions = [];
      } else {
        // Continuar construyendo el texto de la pregunta
        currentQuestionText += ' ' + line;
      }
    }
  }
  
  // Procesar la √∫ltima pregunta si existe
  if (currentQuestion.questionNumber && currentQuestionText && currentOptions.length === 4) {
    questions.push({
      questionNumber: currentQuestion.questionNumber,
      question: currentQuestionText.trim(),
      options: [...currentOptions],
      category: extractCategory(currentQuestionText)
    });
  }
  
  return questions;
}

function extractCategory(questionText: string): string {
  // Intentar extraer la categor√≠a del texto de la pregunta
  const categoryPatterns = [
    /Constituci√≥n Espa√±ola/i,
    /Ley Org√°nica.*Defensa/i,
    /Ley.*R√©gimen Jur√≠dico/i,
    /R\.?D\.?\s*\d+\/\d+/i,
    /Instrucci√≥n \d+\/\d+/i,
    /Reales Ordenanzas/i,
    /Ley.*carrera militar/i,
    /Ley.*Tropa y Mariner√≠a/i,
    /SEGURIDAD NACIONAL/i,
    /PDC-01/i,
    /Organizaci√≥n.*Naciones Unidas/i,
    /OTAN/i,
    /OSCE/i,
    /Uni√≥n Europea/i
  ];
  
  for (const pattern of categoryPatterns) {
    if (pattern.test(questionText)) {
      const match = questionText.match(pattern);
      if (match) {
        return match[0];
      }
    }
  }
  
  return 'General';
}

function getCorrectAnswerIndex(questionNumber: number): number {
  const correctLetter = RESPUESTAS_CORRECTAS_2024[questionNumber];
  if (!correctLetter) {
    console.warn(`‚ö†Ô∏è No se encontr√≥ respuesta correcta para pregunta ${questionNumber}`);
    return 0; // Por defecto, opci√≥n 'a'
  }
  
  switch (correctLetter.toLowerCase()) {
    case 'a': return 0;
    case 'b': return 1;
    case 'c': return 2;
    case 'd': return 3;
    default:
      console.warn(`‚ö†Ô∏è Respuesta inv√°lida '${correctLetter}' para pregunta ${questionNumber}`);
      return 0;
  }
}

async function importExamenOficial2024() {
  try {
    console.log('üìö IMPORTANDO EXAMEN OFICIAL 2024');
    console.log('=================================');

    // Construir la ruta al archivo
    const filePath = path.join(
      process.cwd(),
      '..',
      '..',
      'OPOMELILLA',
      'Examenes oficiales',
      'formato txt',
      'A√ëO 2024 CON PLANTILLA DE RESPUESTAS.txt'
    );

    console.log(`üìÅ Leyendo archivo: ${filePath}`);
    
    if (!fs.existsSync(filePath)) {
      console.error('‚ùå El archivo no existe en la ruta especificada');
      console.log('üí° Aseg√∫rate de que el archivo est√° en la ubicaci√≥n correcta');
      return;
    }

    const fileContent = fs.readFileSync(filePath, 'utf-8');
    console.log(`‚úÖ Archivo le√≠do: ${fileContent.length} caracteres`);

    // Parsear las preguntas
    console.log('\nüîç Parseando preguntas...');
    const questions = parseQuestionText(fileContent);
    console.log(`‚úÖ ${questions.length} preguntas parseadas`);

    if (questions.length === 0) {
      console.error('‚ùå No se encontraron preguntas v√°lidas');
      return;
    }

    // Verificar si hay datos existentes
    const existingCount = await prisma.examenOficial2024.count();
    if (existingCount > 0) {
      console.log(`‚ö†Ô∏è Ya existen ${existingCount} preguntas en la base de datos`);
      console.log('üóëÔ∏è Eliminando datos existentes...');
      await prisma.examenOficial2024.deleteMany();
    }

    // Verificar respuestas correctas
    if (Object.keys(RESPUESTAS_CORRECTAS_2024).length === 0) {
      console.log('\nüö® ADVERTENCIA: No se han configurado las respuestas correctas');
      console.log('üìã Todas las preguntas se importar√°n con respuesta correcta "a" por defecto');
      console.log('üîß Actualiza el objeto RESPUESTAS_CORRECTAS_2024 con el corrector');
    }

    // Importar preguntas
    console.log('\nüì§ Importando preguntas a la base de datos...');
    let importedCount = 0;
    let errorCount = 0;

    for (const question of questions) {
      try {
        // Filtrar solo preguntas del 1 al 100 (excluir reservas)
        if (question.questionNumber > 100) {
          console.log(`‚è≠Ô∏è Saltando pregunta de reserva ${question.questionNumber}`);
          continue;
        }

        const correctAnswerIndex = getCorrectAnswerIndex(question.questionNumber);

        await prisma.examenOficial2024.create({
          data: {
            questionNumber: question.questionNumber,
            question: question.question,
            options: question.options,
            correctAnswerIndex: correctAnswerIndex,
            category: question.category,
            difficulty: 'OFICIAL',
            isActive: true
          }
        });
        
        importedCount++;
        
        if (importedCount % 10 === 0) {
          console.log(`üìä Progreso: ${importedCount}/${questions.length} preguntas importadas`);
        }
        
      } catch (error) {
        console.error(`‚ùå Error importando pregunta ${question.questionNumber}:`, error);
        errorCount++;
      }
    }

    console.log('\nüéâ IMPORTACI√ìN COMPLETADA');
    console.log(`‚úÖ Preguntas importadas: ${importedCount}`);
    console.log(`‚ùå Errores: ${errorCount}`);
    
    // Mostrar estad√≠sticas
    const stats = await prisma.examenOficial2024.groupBy({
      by: ['category'],
      _count: { id: true }
    });
    
    console.log('\nüìä ESTAD√çSTICAS POR CATEGOR√çA:');
    stats.forEach(stat => {
      console.log(`   ${stat.category}: ${stat._count.id} preguntas`);
    });

    // Mostrar muestra de las primeras 3 preguntas
    console.log('\nüîç MUESTRA DE PREGUNTAS IMPORTADAS:');
    const sample = await prisma.examenOficial2024.findMany({
      take: 3,
      orderBy: { questionNumber: 'asc' }
    });

    sample.forEach(q => {
      console.log(`\nüìù Pregunta ${q.questionNumber}:`);
      console.log(`   ${q.question.substring(0, 100)}...`);
      console.log(`   Opciones: ${q.options.length}`);
      console.log(`   Respuesta correcta: ${String.fromCharCode(97 + q.correctAnswerIndex)}) ${q.options[q.correctAnswerIndex]}`);
      console.log(`   Categor√≠a: ${q.category}`);
    });

  } catch (error) {
    console.error('‚ùå Error general:', error);
  } finally {
    await prisma.$disconnect();
  }
}

// Ejecutar si el script se llama directamente
if (require.main === module) {
  importExamenOficial2024().catch(console.error);
}

export { importExamenOficial2024, RESPUESTAS_CORRECTAS_2024 }; 