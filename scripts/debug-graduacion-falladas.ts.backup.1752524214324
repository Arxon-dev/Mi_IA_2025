import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

async function debugGraduacionFalladas() {
  try {
    console.log('üîç ===== DEBUG GRADUACI√ìN FALLADAS =====');
    
    // Tu user ID de Telegram
    const userId = '1629320726';
    
    console.log(`\nüìä INVESTIGANDO USUARIO: ${userId}`);
    
    // 1. Buscar todas las respuestas del usuario por subject
    console.log('\n1Ô∏è‚É£ RESPUESTAS POR SUBJECT:');
    const allResponses = await prisma.studyResponse.findMany({
      where: { userId },
      select: { subject: true, isCorrect: true }
    });
    
    const subjectStats: Record<string, { total: number, correct: number }> = {};
    allResponses.forEach(r => {
      if (!subjectStats[r.subject]) {
        subjectStats[r.subject] = { total: 0, correct: 0 };
      }
      subjectStats[r.subject].total++;
      if (r.isCorrect) subjectStats[r.subject].correct++;
    });
    
    Object.entries(subjectStats).forEach(([subject, stats]) => {
      console.log(`   üìö ${subject}: ${stats.total} respuestas, ${stats.correct} correctas`);
    });
    
    // 2. Buscar respuestas espec√≠ficas a la pregunta problem√°tica de Defensa Nacional
    console.log('\n2Ô∏è‚É£ PREGUNTA PROBLEM√ÅTICA - DEFENSA NACIONAL:');
    const defenseResponses = await prisma.studyResponse.findMany({
      where: { 
        userId,
        subject: 'defensanacional'
      },
      orderBy: { answeredAt: 'asc' },
      select: {
        id: true,
        questionId: true,
        isCorrect: true,
        answeredAt: true,
        pollId: true
      }
    });
    
    console.log(`   üìù Total respuestas defensanacional: ${defenseResponses.length}`);
    
    // Agrupar por questionId
    const responsesByQuestion: Record<string, typeof defenseResponses> = {};
    defenseResponses.forEach(response => {
      if (!responsesByQuestion[response.questionId]) {
        responsesByQuestion[response.questionId] = [];
      }
      responsesByQuestion[response.questionId].push(response);
    });
    
    // Analizar cada pregunta
    for (const [questionId, responses] of Object.entries(responsesByQuestion)) {
      console.log(`\n   üéØ PREGUNTA ID: ${questionId}`);
      console.log(`   üìä Total respuestas: ${responses.length}`);
      
      // Encontrar primer fallo
      const failedResponses = responses.filter(r => !r.isCorrect);
      const correctResponses = responses.filter(r => r.isCorrect);
      
      console.log(`   ‚ùå Fallos: ${failedResponses.length}`);
      console.log(`   ‚úÖ Aciertos: ${correctResponses.length}`);
      
      if (failedResponses.length > 0) {
        const lastFail = failedResponses[failedResponses.length - 1];
        console.log(`   üîç √öltimo fallo: ${lastFail.answeredAt}`);
        
        // Contar aciertos despu√©s del √∫ltimo fallo
        const aciertosPostFallo = correctResponses.filter(r => 
          r.answeredAt && lastFail.answeredAt && r.answeredAt > lastFail.answeredAt
        ).length;
        
        console.log(`   üéØ Aciertos despu√©s del √∫ltimo fallo: ${aciertosPostFallo}`);
        console.log(`   üéì ¬øDeber√≠a graduarse? ${aciertosPostFallo >= 3 ? 'S√ç' : 'NO'}`);
        
        // Mostrar detalle de los √∫ltimos intentos
        const recent = responses.slice(-10);
        console.log('   üìù √öltimos 10 intentos:');
        recent.forEach((r, i) => {
          console.log(`     ${i+1}. ${r.isCorrect ? '‚úÖ' : '‚ùå'} - ${r.answeredAt} - Poll: ${r.pollId}`);
        });
      }
    }
    
    // 3. Ejecutar la consulta SQL real que usa el sistema
    console.log('\n3Ô∏è‚É£ CONSULTA SQL REAL DEL SISTEMA:');
    const query = `
      WITH failed_questions AS (
        SELECT DISTINCT 
          sr."questionId",
          sr.subject,
          MAX(sr."answeredAt") as last_failed_at
        FROM "StudyResponse" sr 
        WHERE sr."userId" = $1 
          AND sr."isCorrect" = false 
          AND sr."answeredAt" IS NOT NULL
          AND sr.subject = 'defensanacional'
        GROUP BY sr."questionId", sr.subject
      ),
      total_successes AS (
        SELECT 
          fq."questionId",
          fq.subject,
          fq.last_failed_at,
          COUNT(sr2.id) as total_successes_since_last_fail
        FROM failed_questions fq
        LEFT JOIN "StudyResponse" sr2 ON sr2."questionId" = fq."questionId" 
          AND sr2."userId" = $1 
          AND sr2."isCorrect" = true 
          AND sr2."answeredAt" > fq.last_failed_at
          AND sr2.subject = fq.subject
        GROUP BY fq."questionId", fq.subject, fq.last_failed_at
      )
      SELECT 
        ts."questionId",
        ts.subject,
        ts.total_successes_since_last_fail,
        ts.last_failed_at
      FROM total_successes ts
      WHERE ts.total_successes_since_last_fail < 3
      ORDER BY ts.last_failed_at ASC
    `;
    
    const sqlResult = await prisma.$queryRawUnsafe(query, userId) as any[];
    
    console.log(`   üîç Preguntas que NO han graduado seg√∫n SQL: ${sqlResult.length}`);
    sqlResult.forEach(row => {
      console.log(`     üìö ${row.subject} - Q${row.questionId} - ${row.total_successes_since_last_fail}/3 aciertos`);
    });
    
    // 4. Verificar si hay discrepancia
    console.log('\n4Ô∏è‚É£ AN√ÅLISIS DE DISCREPANCIA:');
    for (const [questionId, responses] of Object.entries(responsesByQuestion)) {
      const failedResponses = responses.filter(r => !r.isCorrect);
      if (failedResponses.length > 0) {
        const sqlRow = sqlResult.find(r => r.questionId === questionId);
        
        if (sqlRow) {
          console.log(`   üîç Pregunta ${questionId}:`);
          console.log(`     üí≠ Mi c√°lculo manual: Deber√≠a ${responses.filter(r => r.isCorrect).length >= 3 ? 'graduarse' : 'NO graduarse'}`);
          console.log(`     ü§ñ SQL del sistema: ${sqlRow.total_successes_since_last_fail}/3 aciertos`);
          console.log(`     ‚öñÔ∏è Estado: ${sqlRow.total_successes_since_last_fail >= 3 ? 'GRADUADA' : 'NO GRADUADA'}`);
        }
      }
    }
    
    // 5. Investigar el subject PDC que se gradu√≥ r√°pido
    console.log('\n5Ô∏è‚É£ INVESTIGANDO PDC (se gradu√≥ con 1 acierto):');
    const pdcResponses = await prisma.studyResponse.findMany({
      where: { 
        userId,
        subject: 'pdc'
      },
      orderBy: { answeredAt: 'desc' },
      take: 20,
      select: {
        id: true,
        questionId: true,
        isCorrect: true,
        answeredAt: true
      }
    });
    
    console.log(`   üìù Total respuestas PDC: ${pdcResponses.length}`);
    
    // Agrupar por questionId
    const pdcByQuestion = {};
    pdcResponses.forEach(response => {
      if (!pdcByQuestion[response.questionId]) {
        pdcByQuestion[response.questionId] = [];
      }
      pdcByQuestion[response.questionId].push(response);
    });
    
    console.log(`   üéØ Preguntas distintas de PDC: ${Object.keys(pdcByQuestion).length}`);
    
    // Verificar si hay preguntas de PDC que deber√≠an estar en falladas
    const pdcQuery = query.replace("AND sr.subject = 'defensanacional'", "AND sr.subject = 'pdc'");
    const pdcSqlResult = await prisma.$queryRawUnsafe(pdcQuery, userId) as any[];
    console.log(`   üîç Preguntas PDC que NO han graduado seg√∫n SQL: ${pdcSqlResult.length}`);
    
    if (pdcSqlResult.length === 0) {
      console.log('   ‚úÖ PDC: Todas las preguntas falladas est√°n graduadas (por eso no aparecen en /falladas)');
    } else {
      console.log('   ‚ùå PDC: Hay preguntas que deber√≠an aparecer en /falladas:');
      pdcSqlResult.forEach(row => {
        console.log(`     üìö Q${row.questionId} - ${row.total_successes_since_last_fail}/3 aciertos`);
      });
    }
    
  } catch (error) {
    console.error('‚ùå Error en debug:', error);
  } finally {
    await prisma.$disconnect();
  }
}

debugGraduacionFalladas(); 