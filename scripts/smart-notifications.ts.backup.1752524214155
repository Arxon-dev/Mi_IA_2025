import { PrismaClient } from '@prisma/client';
import fetch from 'node-fetch';
import { readFileSync, existsSync } from 'fs';
import { join } from 'path';

const prisma = new PrismaClient();
const BOT_TOKEN = process.env.TELEGRAM_BOT_TOKEN || '8039179482:AAG6bugxwgsmWLVHGoWpE5nih_PQpD3KPBs';
const CHAT_ID = process.env.TELEGRAM_CHAT_ID || '-1002519334308';
const CONFIG_FILE = join(process.cwd(), 'scheduler-config.json');

interface NotificationRule {
  id: string;
  name: string;
  condition: (users: any[]) => any[];
  message: (users: any[]) => string;
  cooldown: number; // minutes
}

// Cargar configuraciÃ³n para obtener reglas habilitadas
function loadEnabledRules(): string[] {
  try {
    if (existsSync(CONFIG_FILE)) {
      const content = readFileSync(CONFIG_FILE, 'utf-8');
      const config = JSON.parse(content);
      return config.notifications?.enabledRules || [];
    }
  } catch (error) {
    console.warn('âš ï¸ Error leyendo configuraciÃ³n, usando todas las reglas:', error);
  }
  
  // Fallback: todas las reglas
  return ['streak_encouragement', 'level_celebration', 'inactive_users', 'high_performers', 'close_competition'];
}

// Definir reglas de notificaciÃ³n
const NOTIFICATION_RULES: NotificationRule[] = [
  {
    id: 'streak_encouragement',
    name: 'MotivaciÃ³n de rachas',
    condition: (users) => users.filter(u => u.streak >= 3 && u.streak <= 7),
    message: (users) => `ğŸ”¥ <b>Â¡RACHAS EN MARCHA!</b> ğŸ”¥

${users.map(u => `ğŸ¯ ${u.firstName} lleva ${u.streak} dÃ­as consecutivos`).join('\n')}

Â¡Sigan asÃ­! Â¿QuiÃ©n llegarÃ¡ a los 10 dÃ­as? ğŸ’ª`,
    cooldown: 720 // 12 horas
  },
  {
    id: 'level_celebration',
    name: 'CelebraciÃ³n de niveles',
    condition: (users) => {
      // Usuarios que subieron de nivel en las Ãºltimas 6 horas
      const sixHoursAgo = new Date(Date.now() - 6 * 60 * 60 * 1000);
      return users.filter(u => u.lastActivity && new Date(u.lastActivity) > sixHoursAgo && u.level >= 2);
    },
    message: (users) => `ğŸ‰ <b>Â¡NIVEL ALCANZADO!</b> ğŸ‰

${users.map(u => `ğŸ† ${u.firstName} ha alcanzado el nivel ${u.level}!`).join('\n')}

Â¡Felicidades por el progreso! ğŸŒŸ`,
    cooldown: 360 // 6 horas
  },
  {
    id: 'inactive_users',
    name: 'ReactivaciÃ³n de usuarios inactivos',
    condition: (users) => {
      const threeDaysAgo = new Date(Date.now() - 3 * 24 * 60 * 60 * 1000);
      return users.filter(u => !u.lastActivity || new Date(u.lastActivity) < threeDaysAgo);
    },
    message: (users) => `ğŸ“š <b>Â¡TE EXTRAÃ‘AMOS!</b> ğŸ“š

Algunos usuarios no han participado recientemente:
${users.slice(0, 3).map(u => `ğŸ‘‹ ${u.firstName}`).join(', ')}

ğŸ¯ Hay nuevas preguntas esperando por ti
ğŸ† Tu posiciÃ³n en el ranking te estÃ¡ esperando
ğŸ’¡ Â¡Cada respuesta cuenta para tu progreso!

Â¿Listos para el siguiente desafÃ­o? ğŸš€`,
    cooldown: 1440 // 24 horas
  },
  {
    id: 'high_performers',
    name: 'Reconocimiento a top performers',
    condition: (users) => users.filter(u => u.totalPoints >= 500 && u.level >= 3),
    message: (users) => `ğŸ‘‘ <b>HALL OF FAME</b> ğŸ‘‘

Nuestros futuros permanentes con mÃ¡s de 500 puntos:
${users.map(u => `ğŸ¥‡ ${u.firstName} - ${u.totalPoints} pts (Nivel ${u.level})`).join('\n')}

Â¡Son un ejemplo para todos! ğŸŒŸ
Â¿QuiÃ©n mÃ¡s se unirÃ¡ al club de los 500? ğŸ’ª`,
    cooldown: 1440 // 24 horas
  },
  {
    id: 'close_competition',
    name: 'Competencia reÃ±ida',
    condition: (users) => {
      const sorted = users.sort((a, b) => b.totalPoints - a.totalPoints);
      if (sorted.length < 2) return [];
      const top1 = sorted[0];
      const top2 = sorted[1];
      const difference = top1.totalPoints - top2.totalPoints;
      return difference <= 50 ? [top1, top2] : [];
    },
    message: (users) => `âš”ï¸ <b>Â¡COMPETENCIA REÃ‘IDA!</b> âš”ï¸

ğŸ¥‡ ${users[0].firstName}: ${users[0].totalPoints} pts
ğŸ¥ˆ ${users[1].firstName}: ${users[1].totalPoints} pts

Â¡Solo ${users[0].totalPoints - users[1].totalPoints} puntos de diferencia!

Â¿QuiÃ©n tomarÃ¡ la delantera? ğŸƒâ€â™‚ï¸ğŸ’¨`,
    cooldown: 480 // 8 horas
  }
];

async function sendNotification(message: string): Promise<boolean> {
  try {
    const response = await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/sendMessage`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        chat_id: CHAT_ID,
        text: message,
        parse_mode: 'HTML'
      })
    });

    const result = await response.json() as any;
    return result.ok;
  } catch (error) {
    console.error('Error enviando notificaciÃ³n:', error);
    return false;
  }
}

async function checkNotificationCooldown(ruleId: string, cooldownMinutes: number): Promise<boolean> {
  try {
    // Verificar si ya se enviÃ³ esta notificaciÃ³n recientemente
    const recentLog = await prisma.telegramSendLog.findFirst({
      where: {
        questionId: `notification_${ruleId}`,
        sendTime: {
          gte: new Date(Date.now() - cooldownMinutes * 60 * 1000)
        }
      }
    });

    return !recentLog; // true si NO hay log reciente (puede enviar)
  } catch (error) {
    console.error('Error verificando cooldown:', error);
    return false;
  }
}

async function logNotification(ruleId: string, success: boolean): Promise<void> {
  try {
    await prisma.telegramSendLog.create({
      data: {
        questionId: `notification_${ruleId}`,
        sourceModel: 'notification',
        success,
        telegramMsgId: success ? `notif_${Date.now()}` : null
      }
    });
  } catch (error) {
    console.error('Error logging notification:', error);
  }
}

async function runSmartNotifications() {
  console.log('ğŸ§  SISTEMA DE NOTIFICACIONES INTELIGENTES');
  console.log('=========================================');
  console.log('');

  try {
    // Cargar reglas habilitadas desde configuraciÃ³n
    const enabledRules = loadEnabledRules();
    console.log('ğŸ“‹ Reglas habilitadas:', enabledRules);
    
    // Filtrar solo las reglas habilitadas
    const activeRules = NOTIFICATION_RULES.filter(rule => enabledRules.includes(rule.id));
    console.log(`âœ… Evaluando ${activeRules.length} de ${NOTIFICATION_RULES.length} reglas disponibles`);
    
    if (activeRules.length === 0) {
      console.log('âš ï¸ No hay reglas habilitadas. ConfiguraciÃ³n necesaria.');
      return;
    }
    
    // Obtener todos los usuarios con sus estadÃ­sticas
    const users = await prisma.telegramUser.findMany({
      select: {
        firstName: true,
        lastName: true,
        totalPoints: true,
        level: true,
        streak: true,
        lastActivity: true,
        responses: {
          select: { id: true }
        }
      }
    });

    console.log(`ğŸ“Š Analizando ${users.length} usuarios...`);

    // Procesar cada regla habilitada
    for (const rule of activeRules) {
      console.log(`ğŸ” Evaluando regla: ${rule.name} (${rule.id})`);

      // Verificar cooldown
      const canSend = await checkNotificationCooldown(rule.id, rule.cooldown);
      if (!canSend) {
        console.log(`â° Regla ${rule.name} en cooldown, saltando...`);
        continue;
      }

      // Evaluar condiciÃ³n
      const matchingUsers = rule.condition(users);
      
      if (matchingUsers.length > 0) {
        console.log(`âœ… Regla ${rule.name} activada para ${matchingUsers.length} usuarios`);
        
        // Generar mensaje
        const message = rule.message(matchingUsers);
        
        // Enviar notificaciÃ³n
        const sent = await sendNotification(message);
        
        if (sent) {
          console.log(`ğŸ“¤ NotificaciÃ³n "${rule.name}" enviada exitosamente`);
          await logNotification(rule.id, true);
        } else {
          console.log(`âŒ Error enviando notificaciÃ³n "${rule.name}"`);
          await logNotification(rule.id, false);
        }
        
        // Solo enviar una notificaciÃ³n por ejecuciÃ³n para evitar spam
        break;
      } else {
        console.log(`âšª Regla ${rule.name} no cumple condiciones`);
      }
    }

    console.log('');
    console.log('âœ… AnÃ¡lisis de notificaciones completado');

  } catch (error) {
    console.error('âŒ Error en sistema de notificaciones:', error);
  } finally {
    await prisma.$disconnect();
  }
}

async function testNotification() {
  console.log('ğŸ§ª PRUEBA DE NOTIFICACIÃ“N');
  console.log('=========================');
  
  const testMessage = `ğŸ§ª <b>PRUEBA DEL SISTEMA DE NOTIFICACIONES</b> ğŸ§ª

Este es un mensaje de prueba para verificar que el sistema de notificaciones inteligentes funciona correctamente.

âœ… Si ves este mensaje, Â¡el sistema estÃ¡ funcionando!
ğŸ¤– Las notificaciones automÃ¡ticas estÃ¡n activas
ğŸ“Š El bot monitorearÃ¡ la actividad y enviarÃ¡ mensajes contextuales

ğŸ”” PrÃ³ximos tipos de notificaciones:
â€¢ ğŸ”¥ MotivaciÃ³n de rachas
â€¢ ğŸ† Celebraciones de nivel
â€¢ ğŸ‘‹ ReactivaciÃ³n de usuarios inactivos
â€¢ ğŸ‘‘ Reconocimiento a top performers
â€¢ âš”ï¸ Competencias reÃ±idas

Â¡Sistema de notificaciones activado! ğŸš€`;

  const sent = await sendNotification(testMessage);
  
  if (sent) {
    console.log('âœ… NotificaciÃ³n de prueba enviada exitosamente');
  } else {
    console.log('âŒ Error enviando notificaciÃ³n de prueba');
  }
}

async function main() {
  const args = process.argv.slice(2);
  
  if (args.includes('--test')) {
    await testNotification();
  } else if (args.includes('--help')) {
    console.log('ğŸ§  SISTEMA DE NOTIFICACIONES INTELIGENTES:');
    console.log('');
    console.log('  ğŸš€ Ejecutar anÃ¡lisis y envÃ­o:');
    console.log('     npx tsx scripts/smart-notifications.ts');
    console.log('');
    console.log('  ğŸ§ª Enviar notificaciÃ³n de prueba:');
    console.log('     npx tsx scripts/smart-notifications.ts --test');
    console.log('');
    console.log('  ğŸ“‹ Mostrar ayuda:');
    console.log('     npx tsx scripts/smart-notifications.ts --help');
    console.log('');
    
    // Mostrar reglas disponibles y cuÃ¡les estÃ¡n habilitadas
    const enabledRules = loadEnabledRules();
    console.log('ğŸ”” REGLAS DE NOTIFICACIÃ“N:');
    NOTIFICATION_RULES.forEach((rule, index) => {
      const isEnabled = enabledRules.includes(rule.id);
      const status = isEnabled ? 'âœ… HABILITADA' : 'âŒ DESHABILITADA';
      console.log(`   ${index + 1}. ${rule.name} - ${status} (cada ${rule.cooldown} min)`);
    });
    console.log('');
    console.log('ğŸ’¡ Configura las reglas en: http://localhost:3000/admin/scheduler');
  } else {
    await runSmartNotifications();
  }
}

main(); 