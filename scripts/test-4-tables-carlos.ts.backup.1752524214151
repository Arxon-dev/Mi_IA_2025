import { PrismaService } from '../src/services/prismaService';
import { parseSectionQuestionContent } from './sectionquestion-parser';

// Configuraci√≥n de Telegram
const BOT_TOKEN = process.env.TELEGRAM_BOT_TOKEN || '8039179482:AAG6bugxwgsmWLVHGoWpE5nih_PQpD3KPBs';
const CARLOS_CHAT_ID = '5793286375'; // Chat privado de Carlos_esp

// Funci√≥n para verificar si una pregunta cumple con los l√≠mites de Telegram
function checkTelegramLimits(question: string, title: string): boolean {
  const fullQuestion = `üß™ PRUEBA ${title.toUpperCase()}\n\n${question}`;
  const MAX_LENGTH = 300;
  
  if (fullQuestion.length > MAX_LENGTH) {
    console.log(`‚ö†Ô∏è  Pregunta demasiado larga: ${fullQuestion.length}/300 caracteres`);
    return false;
  }
  
  return true;
}

// Funci√≥n para enviar poll a Telegram
async function sendTelegramPoll(
  chatId: string, 
  question: string, 
  options: string[], 
  correctAnswerIndex: number, 
  questionId: string,
  sourceModel: string,
  title: string
): Promise<boolean> {
  try {
    console.log(`üó≥Ô∏è Enviando ${title} a Carlos...`);
    
    // Verificar l√≠mites antes de enviar
    if (!checkTelegramLimits(question, title)) {
      console.error(`‚ùå ${title} supera el l√≠mite de 300 caracteres`);
      return false;
    }
    
    const response = await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/sendPoll`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        chat_id: chatId,
        question: `üß™ PRUEBA ${title.toUpperCase()}\n\n${question}`,
        options: options,
        type: 'quiz',
        correct_option_id: correctAnswerIndex,
        is_anonymous: false,
        explanation: `üí° Esta es una pregunta de prueba de la tabla ${sourceModel}.`
      }),
    });

    const result = await response.json() as any;
    
    if (!result.ok) {
      console.error(`‚ùå Error enviando ${title}:`, result.description);
      return false;
    }

    // Registrar el poll en la BD
    const { PrismaClient } = await import('@prisma/client');
    const prisma = new PrismaClient();
    
    await prisma.telegramPoll.create({
      data: {
        pollId: result.result.poll.id,
        questionId: questionId,
        chatId: chatId,
        correctAnswerIndex: correctAnswerIndex,
        options: options,
        sourceModel: sourceModel,
        createdAt: new Date()
      }
    });

    console.log(`‚úÖ ${title} enviada exitosamente! Poll ID: ${result.result.poll.id}`);
    return true;
  } catch (error) {
    console.error(`‚ùå Error enviando ${title}:`, error);
    return false;
  }
}

async function testFourTables() {
  console.log('üß™ PRUEBA DE LAS 4 TABLAS PARA CARLOS_ESP');
  console.log('='.repeat(50));
  console.log(`üë§ Enviando a: Carlos_esp (${CARLOS_CHAT_ID})`);
  console.log(`ü§ñ Bot Token: ${BOT_TOKEN.substring(0, 20)}...`);
  console.log('');

  try {
    const { PrismaClient } = await import('@prisma/client');
    const prisma = new PrismaClient();

    // 1. üìÑ VALIDQUESTION
    console.log('1Ô∏è‚É£ Obteniendo pregunta de ValidQuestion...');
    const validQuestion = await prisma.validQuestion.findFirst({
      where: { isActive: true },
      orderBy: { sendCount: 'asc' }
    });

    if (validQuestion) {
      let parsedData;
      try {
        parsedData = JSON.parse(validQuestion.content);
      } catch {
        // Si no es JSON v√°lido, usar los campos parseados de ValidQuestion
        parsedData = {
          question: validQuestion.parsedQuestion,
          options: validQuestion.parsedOptions,
          correctAnswerIndex: validQuestion.correctAnswerIndex
        };
      }
      
      await sendTelegramPoll(
        CARLOS_CHAT_ID,
        parsedData.question,
        parsedData.options,
        parsedData.correctAnswerIndex,
        validQuestion.id,
        'validQuestion',
        'ValidQuestion'
      );
      
      // Actualizar contador
      await PrismaService.updateLastScheduledSendAt(validQuestion.id, 'validQuestion', true);
    } else {
      console.log('‚ùå No se encontr√≥ pregunta en ValidQuestion');
    }

    console.log('‚è≥ Esperando 3 segundos...\n');
    await new Promise(resolve => setTimeout(resolve, 3000));

    // 2. üéØ EXAMEN OFICIAL 2018
    console.log('2Ô∏è‚É£ Obteniendo pregunta de ExamenOficial2018...');
    const examen2018 = await prisma.examenOficial2018.findFirst({
      where: { isActive: true },
      orderBy: { sendCount: 'asc' }
    });

    if (examen2018) {
      await sendTelegramPoll(
        CARLOS_CHAT_ID,
        examen2018.question,
        examen2018.options,
        examen2018.correctAnswerIndex,
        examen2018.id,
        'examenOficial2018',
        'Examen 2018'
      );
      
      // Actualizar contador
      await PrismaService.updateLastScheduledSendAt(examen2018.id, 'examenOficial2018', true);
    } else {
      console.log('‚ùå No se encontr√≥ pregunta en ExamenOficial2018');
    }

    console.log('‚è≥ Esperando 3 segundos...\n');
    await new Promise(resolve => setTimeout(resolve, 3000));

    // 3. üéØ EXAMEN OFICIAL 2024
    console.log('3Ô∏è‚É£ Obteniendo pregunta de ExamenOficial2024...');
    const examen2024 = await (prisma as any).examenOficial2024.findFirst({
      where: { isActive: true },
      orderBy: { sendCount: 'asc' }
    });

    if (examen2024) {
      await sendTelegramPoll(
        CARLOS_CHAT_ID,
        examen2024.question,
        examen2024.options,
        examen2024.correctAnswerIndex,
        examen2024.id,
        'examenOficial2024',
        'Examen 2024'
      );
      
      // Actualizar contador
      await PrismaService.updateLastScheduledSendAt(examen2024.id, 'examenOficial2024', true);
    } else {
      console.log('‚ùå No se encontr√≥ pregunta en ExamenOficial2024');
    }

    console.log('‚è≥ Esperando 3 segundos...\n');
    await new Promise(resolve => setTimeout(resolve, 3000));

    // 4. üìö SECTION QUESTION
    console.log('4Ô∏è‚É£ Obteniendo pregunta de SectionQuestion...');
    const sectionQuestion = await prisma.sectionQuestion.findFirst({
      orderBy: { sendCount: 'asc' }
    });

    if (sectionQuestion) {
      // Parsear contenido de SectionQuestion
      let questionData;
      try {
        questionData = JSON.parse(sectionQuestion.content);
      } catch {
        // Si no es JSON, crear estructura b√°sica
        questionData = {
          question: sectionQuestion.content,
          options: ['Verdadero', 'Falso'],
          correctAnswerIndex: 0
        };
      }

      await sendTelegramPoll(
        CARLOS_CHAT_ID,
        questionData.question,
        questionData.options,
        questionData.correctAnswerIndex,
        sectionQuestion.id,
        'sectionQuestion',
        'SectionQuestion'
      );
      
      // Actualizar contador
      await PrismaService.updateLastScheduledSendAt(sectionQuestion.id, 'sectionQuestion', true);
    } else {
      console.log('‚ùå No se encontr√≥ pregunta en SectionQuestion');
    }

    console.log('\nüéâ PRUEBA COMPLETADA');
    console.log('üì± Revisa tu chat privado con el bot para ver las 4 preguntas!');
    console.log('üí° Cada pregunta est√° marcada con su tabla de origen.');
    
    await prisma.$disconnect();

  } catch (error) {
    console.error('‚ùå Error en la prueba:', error);
  }
}

// Funciones de reintento para buscar preguntas v√°lidas

// Funci√≥n para buscar una pregunta v√°lida de ValidQuestion
async function getValidQuestionWithRetry(prisma: any, maxAttempts: number = 5) {
  for (let attempt = 1; attempt <= maxAttempts; attempt++) {
    console.log(`üîç ValidQuestion - Intento ${attempt}/${maxAttempts}`);
    
    const validQuestion = await prisma.validQuestion.findFirst({
      where: { isActive: true },
      orderBy: { sendCount: 'asc' },
      skip: attempt - 1 // Saltear las ya probadas
    });
    
    if (!validQuestion) {
      console.log('‚ùå No se encontraron m√°s preguntas en ValidQuestion');
      return null;
    }

    let parsedData;
    try {
      parsedData = JSON.parse(validQuestion.content);
    } catch {
      parsedData = {
        question: validQuestion.parsedQuestion,
        options: validQuestion.parsedOptions,
        correctAnswerIndex: validQuestion.correctAnswerIndex
      };
    }

    if (checkTelegramLimits(parsedData.question, 'ValidQuestion')) {
      return { validQuestion, parsedData };
    }
    
    console.log(`‚ö†Ô∏è  Pregunta ${validQuestion.id} muy larga (${parsedData.question.length + 35} chars), buscando otra...`);
  }
  
  console.log(`‚ùå No se encontr√≥ pregunta v√°lida de ValidQuestion despu√©s de ${maxAttempts} intentos`);
  return null;
}

// Funci√≥n para buscar una pregunta v√°lida de ExamenOficial2018
async function getExamen2018WithRetry(prisma: any, maxAttempts: number = 5) {
  for (let attempt = 1; attempt <= maxAttempts; attempt++) {
    console.log(`üîç ExamenOficial2018 - Intento ${attempt}/${maxAttempts}`);
    
    const examen2018 = await prisma.examenOficial2018.findFirst({
      where: { isActive: true },
      orderBy: { sendCount: 'asc' },
      skip: attempt - 1
    });
    
    if (!examen2018) {
      console.log('‚ùå No se encontraron m√°s preguntas en ExamenOficial2018');
      return null;
    }

    if (checkTelegramLimits(examen2018.question, 'ExamenOficial2018')) {
      return examen2018;
    }
    
    console.log(`‚ö†Ô∏è  Pregunta ${examen2018.id} muy larga (${examen2018.question.length + 40} chars), buscando otra...`);
  }
  
  console.log(`‚ùå No se encontr√≥ pregunta v√°lida de ExamenOficial2018 despu√©s de ${maxAttempts} intentos`);
  return null;
}

// Funci√≥n para buscar una pregunta v√°lida de ExamenOficial2024
async function getExamen2024WithRetry(prisma: any, maxAttempts: number = 5) {
  for (let attempt = 1; attempt <= maxAttempts; attempt++) {
    console.log(`üîç ExamenOficial2024 - Intento ${attempt}/${maxAttempts}`);
    
    const examen2024 = await (prisma as any).examenOficial2024.findFirst({
      where: { isActive: true },
      orderBy: { sendCount: 'asc' },
      skip: attempt - 1
    });
    
    if (!examen2024) {
      console.log('‚ùå No se encontraron m√°s preguntas en ExamenOficial2024');
      return null;
    }

    if (checkTelegramLimits(examen2024.question, 'ExamenOficial2024')) {
      return examen2024;
    }
    
    console.log(`‚ö†Ô∏è  Pregunta ${examen2024.id} muy larga (${examen2024.question.length + 40} chars), buscando otra...`);
  }
  
  console.log(`‚ùå No se encontr√≥ pregunta v√°lida de ExamenOficial2024 despu√©s de ${maxAttempts} intentos`);
  return null;
}

// Funci√≥n para buscar una pregunta v√°lida de SectionQuestion
async function getSectionQuestionWithRetry(prisma: any, maxAttempts: number = 5) {
  for (let attempt = 1; attempt <= maxAttempts; attempt++) {
    console.log(`üîç SectionQuestion - Intento ${attempt}/${maxAttempts}`);
    
    const sectionQuestion = await prisma.sectionQuestion.findFirst({
      orderBy: { sendCount: 'asc' },
      skip: attempt - 1
    });
    
    if (!sectionQuestion) {
      console.log('‚ùå No se encontraron m√°s preguntas en SectionQuestion');
      return null;
    }

    console.log(`üìù Parseando contenido de ${sectionQuestion.id} (${sectionQuestion.content.length} chars originales)...`);
    
    // Usar el parser inteligente para SectionQuestion
    const parsed = parseSectionQuestionContent(sectionQuestion.content);
    
    if (!parsed.success) {
      console.log(`‚ùå Error al parsear pregunta ${sectionQuestion.id}: ${parsed.error}`);
      continue;
    }

    console.log(`‚úÖ Parsing exitoso: pregunta de ${parsed.question.length} chars, ${parsed.options.length} opciones`);

    if (checkTelegramLimits(parsed.question, 'SectionQuestion')) {
      return { 
        sectionQuestion, 
        questionData: {
          question: parsed.question,
          options: parsed.options,
          correctAnswerIndex: parsed.correctAnswerIndex
        }
      };
    }
    
    console.log(`‚ö†Ô∏è  Pregunta ${sectionQuestion.id} a√∫n muy larga despu√©s del parsing (${parsed.question.length + 45} chars), buscando otra...`);
  }
  
  console.log(`‚ùå No se encontr√≥ pregunta v√°lida de SectionQuestion despu√©s de ${maxAttempts} intentos`);
  return null;
}

// Nueva funci√≥n principal con sistema de reintentos
async function testFourTablesWithRetry() {
  console.log('üß™ PRUEBA DE LAS 4 TABLAS CON SISTEMA DE REINTENTOS');
  console.log('='.repeat(60));
  console.log(`üë§ Enviando a: Carlos_esp (${CARLOS_CHAT_ID})`);
  console.log(`ü§ñ Bot Token: ${BOT_TOKEN.substring(0, 20)}...`);
  console.log('üìè L√≠mite de Telegram: 300 caracteres por pregunta');
  console.log('');

  try {
    const { PrismaClient } = await import('@prisma/client');
    const prisma = new PrismaClient();

    // 1. üìÑ VALIDQUESTION CON REINTENTO
    console.log('1Ô∏è‚É£ Buscando pregunta v√°lida de ValidQuestion...');
    const validResult = await getValidQuestionWithRetry(prisma);
    if (validResult) {
      await sendTelegramPoll(
        CARLOS_CHAT_ID,
        validResult.parsedData.question,
        validResult.parsedData.options,
        validResult.parsedData.correctAnswerIndex,
        validResult.validQuestion.id,
        'validQuestion',
        'ValidQuestion'
      );
      
      // Actualizar contador
      await PrismaService.updateLastScheduledSendAt(validResult.validQuestion.id, 'validQuestion', true);
    }

    console.log('‚è≥ Esperando 3 segundos...\n');
    await new Promise(resolve => setTimeout(resolve, 3000));

    // 2. üéØ EXAMEN OFICIAL 2018 CON REINTENTO
    console.log('2Ô∏è‚É£ Buscando pregunta v√°lida de ExamenOficial2018...');
    const examen2018 = await getExamen2018WithRetry(prisma);
    if (examen2018) {
      await sendTelegramPoll(
        CARLOS_CHAT_ID,
        examen2018.question,
        examen2018.options,
        examen2018.correctAnswerIndex,
        examen2018.id,
        'examenOficial2018',
        'Examen 2018'
      );
      
      // Actualizar contador
      await PrismaService.updateLastScheduledSendAt(examen2018.id, 'examenOficial2018', true);
    }

    console.log('‚è≥ Esperando 3 segundos...\n');
    await new Promise(resolve => setTimeout(resolve, 3000));

    // 3. üéØ EXAMEN OFICIAL 2024 CON REINTENTO
    console.log('3Ô∏è‚É£ Buscando pregunta v√°lida de ExamenOficial2024...');
    const examen2024 = await getExamen2024WithRetry(prisma);
    if (examen2024) {
      await sendTelegramPoll(
        CARLOS_CHAT_ID,
        examen2024.question,
        examen2024.options,
        examen2024.correctAnswerIndex,
        examen2024.id,
        'examenOficial2024',
        'Examen 2024'
      );
      
      // Actualizar contador
      await PrismaService.updateLastScheduledSendAt(examen2024.id, 'examenOficial2024', true);
    }

    console.log('‚è≥ Esperando 3 segundos...\n');
    await new Promise(resolve => setTimeout(resolve, 3000));

    // 4. üìö SECTION QUESTION CON REINTENTO
    console.log('4Ô∏è‚É£ Buscando pregunta v√°lida de SectionQuestion...');
    const sectionResult = await getSectionQuestionWithRetry(prisma);
    if (sectionResult) {
      await sendTelegramPoll(
        CARLOS_CHAT_ID,
        sectionResult.questionData.question,
        sectionResult.questionData.options,
        sectionResult.questionData.correctAnswerIndex,
        sectionResult.sectionQuestion.id,
        'sectionQuestion',
        'SectionQuestion'
      );
      
      // Actualizar contador
      await PrismaService.updateLastScheduledSendAt(sectionResult.sectionQuestion.id, 'sectionQuestion', true);
    }

    console.log('\nüéâ PRUEBA CON REINTENTOS COMPLETADA');
    console.log('üì± Revisa tu chat privado con el bot para ver las preguntas v√°lidas!');
    console.log('üí° El sistema ahora busca autom√°ticamente preguntas que cumplan el l√≠mite de 300 chars.');
    
    await prisma.$disconnect();

  } catch (error) {
    console.error('‚ùå Error en la prueba:', error);
  }
}

// Ejecutar la nueva funci√≥n con reintentos
testFourTablesWithRetry().catch(console.error); 