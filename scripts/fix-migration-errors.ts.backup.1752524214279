#!/usr/bin/env ts-node

/**
 * Script para corregir errores de migraciÃ³n de PostgreSQL a MySQL
 * 
 * Este script automatiza las correcciones mÃ¡s comunes encontradas
 * despuÃ©s de migrar de PostgreSQL a MySQL.
 */

import * as fs from 'fs';
import * as path from 'path';

const WEBHOOK_FILE = 'src/app/api/telegram/webhook/route.ts';

interface ErrorFix {
  pattern: RegExp;
  replacement: string;
  description: string;
}

const FIXES: ErrorFix[] = [
  // Variables de scope
  {
    pattern: /\bpollId\b/g,
    replacement: 'pollid',
    description: 'Corregir variable pollId â†’ pollid'
  },
  {
    pattern: /\buserId\b/g,
    replacement: 'userid',
    description: 'Corregir variable userId â†’ userid'
  },
  {
    pattern: /\bfromUser\b/g,
    replacement: 'fromtelegramuser',
    description: 'Corregir variable fromUser â†’ fromtelegramuser'
  },
  
  // Propiedades de DuelStats
  {
    pattern: /\.questionscount\b/g,
    replacement: '.questionsCount',
    description: 'Corregir propiedad questionscount â†’ questionsCount'
  },
  
  // Propiedades de base de datos
  {
    pattern: /lastSuccessfulSendAt:/g,
    replacement: 'lastsuccessfulsendat:',
    description: 'Corregir campo lastSuccessfulSendAt â†’ lastsuccessfulsendat'
  },
  {
    pattern: /timeLimit:/g,
    replacement: 'timelimit:',
    description: 'Corregir campo timeLimit â†’ timelimit'
  },
  
  // Propiedades de usuario
  {
    pattern: /\.firstname\b/g,
    replacement: '.firstName',
    description: 'Corregir propiedad firstname â†’ firstName'
  },
  {
    pattern: /telegramuserid:/g,
    replacement: 'telegramUserId:',
    description: 'Corregir campo telegramuserid â†’ telegramUserId'
  },
  
  // Campos de respuesta
  {
    pattern: /"questionId"/g,
    replacement: '"questionid"',
    description: 'Corregir campo questionId â†’ questionid en consultas'
  },
  {
    pattern: /"isCorrect"/g,
    replacement: '"iscorrect"',
    description: 'Corregir campo isCorrect â†’ iscorrect en consultas'
  },
];

function applyFixes(content: string): { content: string; appliedFixes: string[] } {
  let modifiedContent = content;
  const appliedFixes: string[] = [];
  
  FIXES.forEach(fix => {
    if (fix.pattern.test(modifiedContent)) {
      modifiedContent = modifiedContent.replace(fix.pattern, fix.replacement);
      appliedFixes.push(fix.description);
    }
  });
  
  return { content: modifiedContent, appliedFixes };
}

function main() {
  console.log('ðŸ”§ Iniciando correcciÃ³n de errores de migraciÃ³n...\n');
  
  if (!fs.existsSync(WEBHOOK_FILE)) {
    console.error(`âŒ Archivo no encontrado: ${WEBHOOK_FILE}`);
    process.exit(1);
  }
  
  // Leer archivo
  const originalContent = fs.readFileSync(WEBHOOK_FILE, 'utf8');
  
  // Aplicar correcciones
  const { content: fixedContent, appliedFixes } = applyFixes(originalContent);
  
  if (appliedFixes.length === 0) {
    console.log('âœ… No se encontraron errores para corregir.');
    return;
  }
  
  // Crear backup
  const backupFile = `${WEBHOOK_FILE}.backup.${Date.now()}`;
  fs.writeFileSync(backupFile, originalContent);
  console.log(`ðŸ“¦ Backup creado: ${backupFile}`);
  
  // Escribir archivo corregido
  fs.writeFileSync(WEBHOOK_FILE, fixedContent);
  
  console.log('\nâœ… Correcciones aplicadas:');
  appliedFixes.forEach(fix => console.log(`  - ${fix}`));
  
  console.log(`\nðŸŽ‰ Archivo corregido: ${WEBHOOK_FILE}`);
  console.log('\nðŸ“‹ Siguientes pasos:');
  console.log('1. Ejecutar: npx prisma generate');
  console.log('2. Verificar que la aplicaciÃ³n compile sin errores');
  console.log('3. Probar funcionalidad crÃ­tica');
  console.log('4. Si hay problemas, restaurar desde backup');
}

if (require.main === module) {
  main();
} 