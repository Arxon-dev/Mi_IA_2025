import { PrismaClient } from '@prisma/client';
import fetch from 'node-fetch';

const prisma = new PrismaClient();
const BOT_TOKEN = process.env.TELEGRAM_BOT_TOKEN || '8039179482:AAG6bugxwgsmWLVHGoWpE5nih_PQpD3KPBs';
const CHAT_ID = process.env.TELEGRAM_CHAT_ID || '-1002519334308';

interface SystemHealth {
  database: boolean;
  webhook: boolean;
  telegram: boolean;
  ngrok?: boolean;
}

async function checkDatabaseHealth(): Promise<boolean> {
  try {
    await prisma.$queryRaw`SELECT 1`;
    return true;
  } catch (error) {
    console.error('‚ùå Database error:', error);
    return false;
  }
}

async function checkWebhookHealth(): Promise<boolean> {
  try {
    const webhookResponse = await fetch('http://localhost:3000/api/telegram/webhook', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ test: 'health_check' })
    });
    return webhookResponse.ok;
  } catch (error) {
    console.error('‚ùå Webhook error:', error);
    return false;
  }
}

async function checkTelegramBot(): Promise<boolean> {
  try {
    const response = await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/getMe`);
    const data = await response.json() as any;
    return data.ok;
  } catch (error) {
    console.error('‚ùå Telegram bot error:', error);
    return false;
  }
}

async function getSystemStatistics() {
  try {
    // Estad√≠sticas b√°sicas
    const totalUsers = await prisma.telegramUser.count();
    const totalPollsSent = await prisma.telegramPoll.count();
    const totalResponses = await prisma.telegramResponse.count();
    
    // Actividad reciente (√∫ltimas 24 horas)
    const last24Hours = new Date(Date.now() - 24 * 60 * 60 * 1000);
    
    const recentPollsSent = await prisma.telegramPoll.count({
      where: { createdAt: { gte: last24Hours } }
    });
    
    const recentResponses = await prisma.telegramResponse.count({
      where: { answeredAt: { gte: last24Hours } }
    });
    
    // Top 5 usuarios m√°s activos
    const topUsers = await prisma.telegramUser.findMany({
      orderBy: { totalPoints: 'desc' },
      take: 5,
      select: {
        firstName: true,
        lastName: true,
        totalPoints: true,
        level: true,
        responses: {
          select: {
            id: true
          }
        }
      }
    });
    
    // Procesar conteo de respuestas
    const processedUsers = topUsers.map((user: any) => ({
      firstName: user.firstName,
      lastName: user.lastName,
      totalPoints: user.totalPoints,
      currentLevel: user.level,
      totalResponses: user.responses.length
    }));
    
    // √öltimos polls enviados (sin relaci√≥n a question)
    const recentPolls = await prisma.telegramPoll.findMany({
      orderBy: { createdAt: 'desc' },
      take: 3,
      select: {
        id: true,
        pollId: true,
        questionId: true,
        sourceModel: true,
        createdAt: true
      }
    });
    
    return {
      totalUsers,
      totalPollsSent,
      totalResponses,
      recentPollsSent,
      recentResponses,
      topUsers: processedUsers,
      recentPolls
    };
    
  } catch (error) {
    console.error('‚ùå Error obteniendo estad√≠sticas:', error);
    return null;
  }
}

async function runSystemCheck() {
  console.log('üîç MONITOREO DEL SISTEMA DE POLLS');
  console.log('=================================');
  console.log('');
  
  const health: SystemHealth = {
    database: await checkDatabaseHealth(),
    webhook: await checkWebhookHealth(), 
    telegram: await checkTelegramBot()
  };
  
  // Mostrar estado de componentes
  console.log('üè• ESTADO DE COMPONENTES:');
  console.log('-------------------------');
  console.log(`üìä Base de datos: ${health.database ? '‚úÖ OK' : '‚ùå ERROR'}`);
  console.log(`üåê Webhook (puerto 3000): ${health.webhook ? '‚úÖ OK' : '‚ùå ERROR'}`);
  console.log(`ü§ñ Bot de Telegram: ${health.telegram ? '‚úÖ OK' : '‚ùå ERROR'}`);
  console.log('');
  
  // Estado general del sistema
  const isHealthy = health.database && health.webhook && health.telegram;
  console.log(`üéØ ESTADO GENERAL: ${isHealthy ? '‚úÖ SISTEMA FUNCIONANDO' : '‚ùå SISTEMA CON PROBLEMAS'}`);
  console.log('');
  
  // Obtener estad√≠sticas
  const stats = await getSystemStatistics();
  
  if (stats) {
    console.log('üìä ESTAD√çSTICAS DEL SISTEMA:');
    console.log('-----------------------------');
    console.log(`üë• Total usuarios registrados: ${stats.totalUsers}`);
    console.log(`üó≥Ô∏è  Total polls enviados: ${stats.totalPollsSent}`);
    console.log(`üí¨ Total respuestas: ${stats.totalResponses}`);
    console.log('');
    
    console.log('üìà ACTIVIDAD √öLTIMAS 24 HORAS:');
    console.log('-------------------------------');
    console.log(`üó≥Ô∏è  Polls enviados: ${stats.recentPollsSent}`);
    console.log(`üí¨ Respuestas recibidas: ${stats.recentResponses}`);
    console.log('');
    
    if (stats.topUsers.length > 0) {
      console.log('üèÜ TOP 5 USUARIOS M√ÅS ACTIVOS:');
      console.log('-------------------------------');
      stats.topUsers.forEach((user: any, index: number) => {
        const name = `${user.firstName} ${user.lastName || ''}`.trim();
        console.log(`${index + 1}. ${name} - üèÜ ${user.totalPoints} pts - üìä Nivel ${user.currentLevel} - üí¨ ${user.totalResponses} respuestas`);
      });
      console.log('');
    }
    
    if (stats.recentPolls.length > 0) {
      console.log('üìù √öLTIMOS POLLS ENVIADOS:');
      console.log('---------------------------');
      stats.recentPolls.forEach((poll: any, index: number) => {
        console.log(`${index + 1}. Poll ID: ${poll.pollId}`);
        console.log(`   üìã Pregunta ID: ${poll.questionId}`);
        console.log(`   üìÇ Fuente: ${poll.sourceModel}`);
        console.log(`   üìÖ ${poll.createdAt.toLocaleString()}`);
        console.log('');
      });
    }
  }
  
  console.log('');
  console.log('üîÑ Para ejecutar de nuevo: npx tsx scripts/monitor-system.ts');
  console.log('‚è∞ Para scheduler autom√°tico: npx tsx scripts/scheduler.ts');
  console.log('üì§ Para env√≠o manual: npx tsx scripts/send-poll-question.ts --list');
}

async function main() {
  try {
    const args = process.argv.slice(2);
    
    if (args.includes('--help')) {
      console.log('üìã MONITOREO DEL SISTEMA:');
      console.log('');
      console.log('  üîç Ejecutar chequeo completo:');
      console.log('     npx tsx scripts/monitor-system.ts');
      console.log('');
      console.log('  üìã Mostrar esta ayuda:');
      console.log('     npx tsx scripts/monitor-system.ts --help');
      console.log('');
      console.log('üîç WHAT THIS SCRIPT CHECKS:');
      console.log('   ‚Ä¢ Database connectivity');
      console.log('   ‚Ä¢ Webhook server status');
      console.log('   ‚Ä¢ Telegram bot status');
      console.log('   ‚Ä¢ System statistics');
      console.log('   ‚Ä¢ Recent activity');
      console.log('   ‚Ä¢ Top users');
      return;
    }
    
    await runSystemCheck();
    
  } catch (error) {
    console.error('‚ùå Error en monitoreo:', error);
  } finally {
    await prisma.$disconnect();
  }
}

main(); 