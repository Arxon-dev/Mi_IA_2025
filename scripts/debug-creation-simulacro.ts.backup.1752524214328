import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

async function debugSimulacroCreation() {
  try {
    console.log('üîç DEBUGGING SIMULACRO CREATION PROCESS');
    console.log('======================================');

    const CARLOS_TELEGRAM_ID = '5793286375';

    // 1. Buscar usuario Carlos
    const user = await prisma.telegramUser.findUnique({
      where: { telegramUserId: CARLOS_TELEGRAM_ID }
    });

    if (!user) {
      console.error('‚ùå Usuario no encontrado');
      return;
    }

    console.log('‚úÖ Usuario encontrado:', user.firstName);

    // 2. Verificar si hay simulacros existentes activos
    const activeSimulacros = await prisma.simulacro.findMany({
      where: {
        userId: user.id,
        status: 'in_progress'
      }
    });

    if (activeSimulacros.length > 0) {
      console.log('‚ö†Ô∏è Ya hay simulacros activos, limpiando primero...');
      for (const sim of activeSimulacros) {
        await prisma.simulacroResponse.deleteMany({
          where: { simulacroId: sim.id }
        });
        await prisma.simulacro.delete({
          where: { id: sim.id }
        });
      }
      console.log('‚úÖ Simulacros activos eliminados');
    }

    // 3. Simular creaci√≥n de simulacro paso a paso
    console.log('\nüèóÔ∏è INICIANDO CREACI√ìN DE SIMULACRO...');
    console.log('=====================================');

    // Paso 1: Obtener preguntas del examen
    const allQuestions = await prisma.examenOficial2018.findMany({
      where: { isActive: true },
      orderBy: { questionNumber: 'asc' },
      take: 5 // Solo 5 para debugging
    });

    console.log('üìö Preguntas obtenidas:', allQuestions.length);

    // Paso 2: Crear el simulacro
    console.log('\nüìù CREANDO SIMULACRO...');
    const simulacro = await prisma.simulacro.create({
      data: {
        userId: user.id,
        status: 'in_progress',
        timeLimit: 10800,
        totalQuestions: 5, // Solo 5 para debugging
        currentQuestionIndex: 0
      }
    });

    console.log('‚úÖ Simulacro creado:', {
      id: simulacro.id,
      status: simulacro.status,
      totalQuestions: simulacro.totalQuestions
    });

    // Paso 3: Crear respuestas una por una y verificar el estado
    console.log('\nüìã CREANDO RESPUESTAS UNA POR UNA...');
    console.log('====================================');

    for (let i = 0; i < allQuestions.length; i++) {
      const question = allQuestions[i];
      
      console.log(`\n${i + 1}. Creando respuesta para pregunta ${i + 1}:`);
      
      // Crear la respuesta
      const response = await prisma.simulacroResponse.create({
        data: {
          simulacroId: simulacro.id,
          questionId: question.id,
          questionNumber: i + 1,
          questionCategory: question.category,
          questionDifficulty: question.difficulty,
          answeredAt: null,  // ‚Üê EXPL√çCITAMENTE NULL
          selectedOption: null,
          isCorrect: null,
          responseTime: null,
          skipped: false
        }
      });

      console.log(`   ‚úÖ Response creada: ${response.id}`);
      console.log(`   üìä answeredAt: ${response.answeredAt}`);
      console.log(`   üìä selectedOption: ${response.selectedOption}`);
      console.log(`   üìä isCorrect: ${response.isCorrect}`);

      // Verificar inmediatamente despu√©s de crear cada respuesta
      const verifyResponse = await prisma.simulacroResponse.findUnique({
        where: { id: response.id }
      });

      if (!verifyResponse) {
        console.log(`   ‚ùå ERROR: No se pudo verificar la respuesta reci√©n creada`);
        break;
      }

      console.log(`   üîç VERIFICACI√ìN INMEDIATA:`);
      console.log(`      answeredAt: ${verifyResponse.answeredAt}`);
      console.log(`      selectedOption: ${verifyResponse.selectedOption}`);
      console.log(`      isCorrect: ${verifyResponse.isCorrect}`);

      if (verifyResponse.answeredAt !== null) {
        console.log(`   üö® CORRUPCI√ìN DETECTADA: answeredAt se estableci√≥ autom√°ticamente!`);
        console.log(`      Valor inesperado: ${verifyResponse.answeredAt}`);
        break;
      }

      // Verificar el conteo total de respuestas "respondidas"
      const answeredCount = await prisma.simulacroResponse.count({
        where: {
          simulacroId: simulacro.id,
          answeredAt: { not: null }
        }
      });

      console.log(`   üìà Total respondidas hasta ahora: ${answeredCount}`);

      if (answeredCount > 0) {
        console.log(`   üö® PROBLEMA: Hay ${answeredCount} respuestas marcadas como respondidas cuando no deber√≠a haber ninguna!`);
        
        // Investigar cu√°les est√°n marcadas
        const unexpectedAnswered = await prisma.simulacroResponse.findMany({
          where: {
            simulacroId: simulacro.id,
            answeredAt: { not: null }
          },
          take: 3
        });

        console.log(`   üîç Respuestas inesperadamente marcadas:`);
        unexpectedAnswered.forEach(r => {
          console.log(`      Q${r.questionNumber}: answeredAt=${r.answeredAt}, option=${r.selectedOption}`);
        });
        break;
      }
    }

    // Verificaci√≥n final
    console.log('\nüìä VERIFICACI√ìN FINAL:');
    console.log('======================');

    const finalResponses = await prisma.simulacroResponse.findMany({
      where: { simulacroId: simulacro.id },
      orderBy: { questionNumber: 'asc' }
    });

    console.log(`Total respuestas creadas: ${finalResponses.length}`);

    const finalAnsweredCount = finalResponses.filter(r => r.answeredAt !== null).length;
    const finalNullCount = finalResponses.filter(r => r.answeredAt === null).length;

    console.log(`Respuestas con answeredAt != null: ${finalAnsweredCount}`);
    console.log(`Respuestas con answeredAt == null: ${finalNullCount}`);

    if (finalAnsweredCount > 0) {
      console.log('üö® PROBLEMA CONFIRMADO: Hay respuestas marcadas como respondidas sin ser respondidas');
      
      // Verificar si hay alg√∫n patr√≥n en las fechas
      const answeredTimes = finalResponses
        .filter(r => r.answeredAt !== null)
        .map(r => r.answeredAt)
        .filter((time, index, arr) => arr.findIndex(t => t?.getTime() === time?.getTime()) === index);

      console.log('Fechas de answeredAt √∫nicas:', answeredTimes);
      
      if (answeredTimes.length === 1) {
        console.log('üîç Todas las respuestas tienen la misma fecha - posible batch update');
        console.log('   Fecha com√∫n:', answeredTimes[0]);
        console.log('   ¬øEs la fecha de creaci√≥n del simulacro?', answeredTimes[0]?.getTime() === simulacro.startedAt.getTime());
      }
    } else {
      console.log('‚úÖ Todas las respuestas est√°n correctamente marcadas como no respondidas');
    }

    // Limpiar el simulacro de prueba
    console.log('\nüóëÔ∏è LIMPIANDO SIMULACRO DE PRUEBA...');
    await prisma.simulacroResponse.deleteMany({
      where: { simulacroId: simulacro.id }
    });
    await prisma.simulacro.delete({
      where: { id: simulacro.id }
    });
    console.log('‚úÖ Simulacro de prueba eliminado');

  } catch (error) {
    console.error('‚ùå Error en debug de creaci√≥n:', error);
  } finally {
    await prisma.$disconnect();
  }
}

// Ejecutar el debug
debugSimulacroCreation(); 