import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

async function traceSimulacroCorruption() {
  try {
    console.log('üïµÔ∏è TRAZANDO CORRUPCI√ìN DE SIMULACRO');
    console.log('=================================');

    const CARLOS_TELEGRAM_ID = '5793286375';

    // 1. Buscar usuario Carlos
    const user = await prisma.telegramUser.findUnique({
      where: { telegramUserId: CARLOS_TELEGRAM_ID }
    });

    if (!user) {
      console.error('‚ùå Usuario no encontrado');
      return;
    }

    console.log('‚úÖ Usuario encontrado:', user.firstName);

    // 2. Limpiar cualquier simulacro existente
    console.log('\nüßπ LIMPIANDO SIMULACROS EXISTENTES...');
    const existingSimulacros = await prisma.simulacro.findMany({
      where: {
        userId: user.id,
        status: 'in_progress'
      }
    });

    for (const sim of existingSimulacros) {
      await prisma.simulacroResponse.deleteMany({
        where: { simulacroId: sim.id }
      });
      await prisma.simulacro.delete({
        where: { id: sim.id }
      });
    }
    console.log(`‚úÖ Eliminados ${existingSimulacros.length} simulacros existentes`);

    // 3. Crear simulacro usando el MISMO c√≥digo que SimulacroService
    console.log('\nüèóÔ∏è CREANDO SIMULACRO USANDO C√ìDIGO REAL...');
    console.log('============================================');

    // Obtener 100 preguntas aleatorias del examen
    const allQuestions = await prisma.examenOficial2018.findMany({
      where: { isActive: true },
      orderBy: { questionNumber: 'asc' }
    });

    console.log('üìö Preguntas obtenidas:', allQuestions.length);

    // Crear el simulacro (EXACTO igual al SimulacroService)
    const simulacro = await prisma.simulacro.create({
      data: {
        userId: user.id,
        status: 'in_progress',
        timeLimit: 10800, // 180 minutos
        totalQuestions: 100,
        currentQuestionIndex: 0
      }
    });

    console.log('‚úÖ Simulacro creado:', {
      id: simulacro.id,
      status: simulacro.status,
      startedAt: simulacro.startedAt
    });

    // Snapshot inicial (antes de crear respuestas)
    console.log('\nüì∏ SNAPSHOT INICIAL (antes de crear respuestas):');
    const responsesBeforeCreation = await prisma.simulacroResponse.count({
      where: { simulacroId: simulacro.id }
    });
    console.log(`   Respuestas existentes: ${responsesBeforeCreation}`);

    // Crear todas las respuestas del simulacro (EXACTO igual al SimulacroService)
    console.log('\nüìã CREANDO 100 RESPUESTAS...');
    for (let i = 0; i < 100; i++) {
      const question = allQuestions[i];
      await prisma.simulacroResponse.create({
        data: {
          simulacroId: simulacro.id,
          questionId: question.id,
          questionNumber: i + 1,
          questionCategory: question.category,
          questionDifficulty: question.difficulty,
          answeredAt: null,
          selectedOption: null,
          isCorrect: null,
          responseTime: null,
          skipped: false
        }
      });

      // Checkpoint cada 10 respuestas
      if ((i + 1) % 10 === 0) {
        const answeredSoFar = await prisma.simulacroResponse.count({
          where: {
            simulacroId: simulacro.id,
            answeredAt: { not: null }
          }
        });
        
        if (answeredSoFar > 0) {
          console.log(`üö® CORRUPCI√ìN DETECTADA en respuesta ${i + 1}: ${answeredSoFar} marcadas como respondidas`);
          break;
        } else {
          console.log(`   ‚úÖ Checkpoint ${i + 1}/100: Sin corrupci√≥n`);
        }
      }
    }

    // Verificaci√≥n despu√©s de crear todas las respuestas
    console.log('\nüìä VERIFICACI√ìN POST-CREACI√ìN:');
    const totalResponses = await prisma.simulacroResponse.count({
      where: { simulacroId: simulacro.id }
    });

    const answeredResponses = await prisma.simulacroResponse.count({
      where: {
        simulacroId: simulacro.id,
        answeredAt: { not: null }
      }
    });

    console.log(`   Total respuestas: ${totalResponses}`);
    console.log(`   Marcadas como respondidas: ${answeredResponses}`);

    if (answeredResponses > 0) {
      console.log('üö® PROBLEMA DETECTADO DESPU√âS DE CREACI√ìN');
      
      // Investigar las respuestas corruptas
      const corruptedResponses = await prisma.simulacroResponse.findMany({
        where: {
          simulacroId: simulacro.id,
          answeredAt: { not: null }
        },
        take: 5,
        orderBy: { questionNumber: 'asc' }
      });

      console.log('üîç Primeras 5 respuestas corruptas:');
      corruptedResponses.forEach(r => {
        console.log(`   Q${r.questionNumber}: answeredAt=${r.answeredAt}, option=${r.selectedOption}, correct=${r.isCorrect}`);
      });

      // ¬øTodas tienen la misma fecha?
      const uniqueDates = [...new Set(corruptedResponses.map(r => r.answeredAt?.getTime()))];
      console.log('Fechas √∫nicas de corrupci√≥n:', uniqueDates.length);
      
      if (uniqueDates.length === 1) {
        console.log('Todas corrompidas en el mismo momento:', new Date(uniqueDates[0] || 0));
      }

      return simulacro.id; // Devolver ID para continuar investigaci√≥n
    }

    console.log('‚úÖ SIMULACRO CREADO CORRECTAMENTE');

    // 4. Simular el tiempo que pasa hasta que llega la primera respuesta
    console.log('\n‚è∞ SIMULANDO TIEMPO TRANSCURRIDO...');
    console.log('===================================');

    // Esperar 2 segundos (simular tiempo real)
    await new Promise(resolve => setTimeout(resolve, 2000));

    // Verificar si algo cambi√≥ durante la espera
    const answeredAfterWait = await prisma.simulacroResponse.count({
      where: {
        simulacroId: simulacro.id,
        answeredAt: { not: null }
      }
    });

    console.log(`üìä Despu√©s de 2 segundos: ${answeredAfterWait} respuestas marcadas como respondidas`);

    if (answeredAfterWait > 0) {
      console.log('üö® CORRUPCI√ìN DETECTADA DESPU√âS DE ESPERAR');
      return simulacro.id;
    }

    // 5. Simular obtener la pregunta actual (como hace el webhook)
    console.log('\nüîç SIMULANDO OBTENCI√ìN DE PREGUNTA ACTUAL...');
    console.log('==============================================');

    const { SimulacroService } = await import('../src/services/simulacroService');
    const currentQuestion = await SimulacroService.getCurrentQuestion(simulacro.id);

    if (currentQuestion) {
      console.log('‚úÖ getCurrentQuestion() funciona:', currentQuestion.questionNumber);
    } else {
      console.log('‚ùå getCurrentQuestion() devolvi√≥ null');
    }

    // Verificar despu√©s de getCurrentQuestion
    const answeredAfterGetCurrent = await prisma.simulacroResponse.count({
      where: {
        simulacroId: simulacro.id,
        answeredAt: { not: null }
      }
    });

    console.log(`üìä Despu√©s de getCurrentQuestion: ${answeredAfterGetCurrent} respondidas`);

    if (answeredAfterGetCurrent > 0) {
      console.log('üö® CORRUPCI√ìN DETECTADA DESPU√âS DE getCurrentQuestion()');
      return simulacro.id;
    }

    // 6. Todo bien hasta aqu√≠, limpiar
    console.log('\n‚úÖ SIMULACRO PERMANECE √çNTEGRO');
    console.log('No se detect√≥ corrupci√≥n en el proceso normal');
    
    // Limpiar el simulacro de prueba
    await prisma.simulacroResponse.deleteMany({
      where: { simulacroId: simulacro.id }
    });
    await prisma.simulacro.delete({
      where: { id: simulacro.id }
    });
    console.log('üóëÔ∏è Simulacro de prueba eliminado');

    return null;

  } catch (error) {
    console.error('‚ùå Error en trazado:', error);
    return null;
  } finally {
    await prisma.$disconnect();
  }
}

// Ejecutar el trazado
traceSimulacroCorruption().then(corruptedId => {
  if (corruptedId) {
    console.log(`\nüéØ INVESTIGACI√ìN NECESARIA: Simulacro ${corruptedId} se corrompi√≥ durante el proceso`);
    console.log('Ejecuta debug-simulacro.ts para investigar m√°s');
  }
}); 