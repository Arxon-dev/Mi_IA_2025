#!/usr/bin/env tsx

/**
 * GESTOR DE PREGUNTAS TRUNCADAS
 * 
 * Identifica y gestiona preguntas que requieren truncamiento para cumplir
 * con las limitaciones de Telegram, ofreciendo opciones para:
 * - Listar preguntas truncadas
 * - Migrar solo preguntas sin truncamiento
 * - Eliminar preguntas truncadas de ValidQuestion
 * - Generar reporte detallado
 */

import { PrismaClient } from '@prisma/client';
import { parseGIFTImproved, type ParsedQuestion } from './gift-parser-improved';
import fs from 'fs';
import path from 'path';

const prisma = new PrismaClient();

interface TruncatedAnalysis {
  totalQuestions: number;
  noTruncation: number;
  questionTruncated: number;
  optionsTruncated: number;
  bothTruncated: number;
  examples: {
    noTruncation: ParsedQuestion[];
    questionTruncated: ParsedQuestion[];
    optionsTruncated: ParsedQuestion[];
    bothTruncated: ParsedQuestion[];
  };
}

/**
 * Analizar preguntas y clasificar por tipo de truncamiento
 */
async function analyzeTruncatedQuestions(): Promise<TruncatedAnalysis> {
  console.log('üîç Analizando preguntas por tipo de truncamiento...\n');
  
  const analysis: TruncatedAnalysis = {
    totalQuestions: 0,
    noTruncation: 0,
    questionTruncated: 0,
    optionsTruncated: 0,
    bothTruncated: 0,
    examples: {
      noTruncation: [],
      questionTruncated: [],
      optionsTruncated: [],
      bothTruncated: []
    }
  };
  
  const batchSize = 100;
  const totalQuestions = await prisma.question.count({ where: { archived: false } });
  
  console.log(`üìä Total de preguntas a analizar: ${totalQuestions.toLocaleString()}\n`);
  
  for (let offset = 0; offset < totalQuestions; offset += batchSize) {
    const batch = await prisma.question.findMany({
      skip: offset,
      take: batchSize,
      select: {
        id: true,
        content: true,
        type: true,
        difficulty: true
      },
      where: {
        archived: false
      }
    });
    
    for (const question of batch) {
      const parsed = parseGIFTImproved(question.content, question.id);
      
      if (parsed?.isValid) {
        analysis.totalQuestions++;
        
        const hasQuestionTruncation = parsed.truncated.question;
        const hasOptionsTruncation = parsed.truncated.options.some(t => t);
        
        if (!hasQuestionTruncation && !hasOptionsTruncation) {
          analysis.noTruncation++;
          if (analysis.examples.noTruncation.length < 3) {
            analysis.examples.noTruncation.push(parsed);
          }
        } else if (hasQuestionTruncation && !hasOptionsTruncation) {
          analysis.questionTruncated++;
          if (analysis.examples.questionTruncated.length < 3) {
            analysis.examples.questionTruncated.push(parsed);
          }
        } else if (!hasQuestionTruncation && hasOptionsTruncation) {
          analysis.optionsTruncated++;
          if (analysis.examples.optionsTruncated.length < 3) {
            analysis.examples.optionsTruncated.push(parsed);
          }
        } else {
          analysis.bothTruncated++;
          if (analysis.examples.bothTruncated.length < 3) {
            analysis.examples.bothTruncated.push(parsed);
          }
        }
      }
      
      // Mostrar progreso cada 1000 preguntas
      if (analysis.totalQuestions % 1000 === 0 && analysis.totalQuestions > 0) {
        const progress = ((offset + batch.indexOf(question) + 1) / totalQuestions * 100).toFixed(1);
        console.log(`Progreso: ${analysis.totalQuestions} procesadas (${progress}%)`);
      }
    }
  }
  
  return analysis;
}

/**
 * Migrar solo preguntas sin truncamiento
 */
async function migrateOnlyNonTruncated(dryRun: boolean = true): Promise<void> {
  console.log(`üöÄ ${dryRun ? 'SIMULANDO' : 'EJECUTANDO'} migraci√≥n de preguntas sin truncamiento...\n`);
  
  let migrated = 0;
  let skipped = 0;
  let errors = 0;
  
  const batchSize = 50;
  const totalQuestions = await prisma.question.count({ where: { archived: false } });
  
  for (let offset = 0; offset < totalQuestions; offset += batchSize) {
    const batch = await prisma.question.findMany({
      skip: offset,
      take: batchSize,
      select: {
        id: true,
        content: true,
        type: true,
        difficulty: true,
        documentId: true
      },
      where: {
        archived: false
      }
    });
    
    for (const question of batch) {
      const parsed = parseGIFTImproved(question.content, question.id);
      
      if (!parsed || !parsed.isValid) {
        errors++;
        continue;
      }
      
      const hasAnyTruncation = parsed.truncated.question || parsed.truncated.options.some(t => t);
      
      if (hasAnyTruncation) {
        skipped++;
        continue;
      }
      
      // Esta pregunta no tiene truncamiento, migrarla
      if (!dryRun) {
        try {
          await prisma.validQuestion.create({
            data: {
              originalQuestionId: question.id,
              content: question.content,
              parsedQuestion: parsed.question,
              parsedOptions: parsed.options,
              correctAnswerIndex: parsed.correctAnswerIndex,
              parsedExplanation: parsed.explanation || null,
              parseMethod: 'GIFT',
              type: question.type || 'multiplechoice',
              difficulty: question.difficulty || 'unknown',
              bloomLevel: null,
              documentId: question.documentId || null,
              isActive: true
            }
          });
        } catch (error) {
          errors++;
          console.error(`‚ùå Error migrando ${question.id}:`, error);
          continue;
        }
      }
      
      migrated++;
      
      if (migrated % 100 === 0) {
        console.log(`üìä Progreso: ${migrated} migradas | ${skipped} truncadas saltadas | ${errors} errores`);
      }
    }
  }
  
  console.log('\nüéâ PROCESO COMPLETADO:');
  console.log(`‚úÖ Preguntas ${dryRun ? 'que se migrar√≠an' : 'migradas'}: ${migrated.toLocaleString()}`);
  console.log(`‚è≠Ô∏è Preguntas truncadas saltadas: ${skipped.toLocaleString()}`);
  console.log(`‚ùå Errores: ${errors.toLocaleString()}`);
}

/**
 * Eliminar preguntas truncadas de ValidQuestion
 */
async function removeTruncatedFromValidQuestion(dryRun: boolean = true): Promise<void> {
  console.log(`üîç ${dryRun ? 'IDENTIFICANDO' : 'ELIMINANDO'} preguntas truncadas en ValidQuestion...\n`);
  
  const validQuestions = await prisma.validQuestion.findMany({
    where: { isActive: true }
  });
  
  console.log(`üìä Total de preguntas en ValidQuestion: ${validQuestions.length}\n`);
  
  let truncatedCount = 0;
  let removedCount = 0;
  
  for (const validQuestion of validQuestions) {
    // Re-parsear para verificar si est√° truncada
    const parsed = parseGIFTImproved(validQuestion.content, validQuestion.id);
    
    if (parsed?.isValid) {
      const hasAnyTruncation = parsed.truncated.question || parsed.truncated.options.some(t => t);
      
      if (hasAnyTruncation) {
        truncatedCount++;
        
        if (!dryRun) {
          try {
            await prisma.validQuestion.delete({
              where: { id: validQuestion.id }
            });
            removedCount++;
          } catch (error) {
            console.error(`‚ùå Error eliminando ${validQuestion.id}:`, error);
          }
        }
        
        if (truncatedCount <= 5) {
          console.log(`üîç Pregunta truncada encontrada: ${validQuestion.id}`);
          console.log(`   Pregunta: ${parsed.question.substring(0, 100)}...`);
          console.log(`   Truncada: Pregunta=${parsed.truncated.question}, Opciones=${parsed.truncated.options.some(t => t)}\n`);
        }
      }
    }
  }
  
  console.log('\nüìä RESULTADOS:');
  console.log(`üîç Preguntas truncadas encontradas: ${truncatedCount.toLocaleString()}`);
  if (!dryRun) {
    console.log(`üóëÔ∏è Preguntas eliminadas: ${removedCount.toLocaleString()}`);
    console.log(`‚úÖ Preguntas no truncadas restantes: ${(validQuestions.length - removedCount).toLocaleString()}`);
  }
}

/**
 * Generar reporte detallado de truncamiento
 */
function generateTruncationReport(analysis: TruncatedAnalysis): string {
  const report = `
# üìä REPORTE DE AN√ÅLISIS DE TRUNCAMIENTO

**Fecha:** ${new Date().toLocaleString()}

## üéØ RESUMEN EJECUTIVO

De **${analysis.totalQuestions.toLocaleString()}** preguntas v√°lidas analizadas:

- ‚úÖ **Sin truncamiento:** ${analysis.noTruncation.toLocaleString()} (${(analysis.noTruncation/analysis.totalQuestions*100).toFixed(2)}%)
- ‚ö†Ô∏è **Solo pregunta truncada:** ${analysis.questionTruncated.toLocaleString()} (${(analysis.questionTruncated/analysis.totalQuestions*100).toFixed(2)}%)
- ‚ö†Ô∏è **Solo opciones truncadas:** ${analysis.optionsTruncated.toLocaleString()} (${(analysis.optionsTruncated/analysis.totalQuestions*100).toFixed(2)}%)
- üö® **Ambos truncados:** ${analysis.bothTruncated.toLocaleString()} (${(analysis.bothTruncated/analysis.totalQuestions*100).toFixed(2)}%)

## üí° RECOMENDACIONES

### Estrategia de Migraci√≥n √ìptima

1. **Migrar solo preguntas sin truncamiento:** ${analysis.noTruncation.toLocaleString()} preguntas perfectas
2. **Revisar preguntas con truncamiento menor:** Especialmente las ${analysis.questionTruncated.toLocaleString()} con solo pregunta truncada
3. **Considerar exclusi√≥n:** Las ${analysis.bothTruncated.toLocaleString()} preguntas con ambos truncados

### Calidad del Contenido

- **${analysis.noTruncation.toLocaleString()} preguntas (${(analysis.noTruncation/analysis.totalQuestions*100).toFixed(1)}%)** son perfectas para Telegram
- **${(analysis.questionTruncated + analysis.optionsTruncated + analysis.bothTruncated).toLocaleString()} preguntas** requieren alg√∫n tipo de truncamiento

## üìã EJEMPLOS REPRESENTATIVOS

### ‚úÖ Preguntas Sin Truncamiento
${analysis.examples.noTruncation.map((q, i) => `
**Ejemplo ${i + 1}:**
- Pregunta (${q.originalLength.question} chars): ${q.question}
- Opciones: ${q.options.length} (m√°x ${q.originalLength.longestOption} chars)
`).join('')}

### ‚ö†Ô∏è Preguntas con Truncamiento
${analysis.examples.questionTruncated.length > 0 ? `
**Solo Pregunta Truncada:**
${analysis.examples.questionTruncated.map((q, i) => `
- Original: ${q.originalLength.question} chars ‚Üí Truncado: ${q.question.length} chars
- Pregunta: ${q.question}
`).join('')}` : ''}

${analysis.examples.optionsTruncated.length > 0 ? `
**Solo Opciones Truncadas:**
${analysis.examples.optionsTruncated.map((q, i) => `
- Pregunta OK: ${q.question.substring(0, 80)}...
- Opciones truncadas: ${q.truncated.options.filter(t => t).length}/${q.options.length}
`).join('')}` : ''}

## üöÄ PR√ìXIMOS PASOS

1. **Ejecutar migraci√≥n selectiva:** Solo preguntas sin truncamiento
2. **Revisar manualmente:** Preguntas con truncamiento m√≠nimo
3. **Optimizar contenido:** Mejorar preguntas con truncamiento excesivo

---
*An√°lisis generado el ${new Date().toLocaleString()}*
`;
  
  return report;
}

/**
 * Funci√≥n principal
 */
async function main() {
  const args = process.argv.slice(2);
  const command = args[0] || 'analyze';
  const dryRun = !args.includes('--execute');
  
  try {
    switch (command) {
      case 'analyze':
        console.log('üìä AN√ÅLISIS DE PREGUNTAS TRUNCADAS\n');
        const analysis = await analyzeTruncatedQuestions();
        
        const report = generateTruncationReport(analysis);
        const reportPath = path.join(process.cwd(), 'scripts', 'output', 'truncation-analysis.md');
        const outputDir = path.dirname(reportPath);
        
        if (!fs.existsSync(outputDir)) {
          fs.mkdirSync(outputDir, { recursive: true });
        }
        
        fs.writeFileSync(reportPath, report, 'utf-8');
        
        console.log('\nüìä RESULTADOS FINALES:');
        console.log(`‚úÖ Sin truncamiento: ${analysis.noTruncation.toLocaleString()} (${(analysis.noTruncation/analysis.totalQuestions*100).toFixed(1)}%)`);
        console.log(`‚ö†Ô∏è Con truncamiento: ${(analysis.totalQuestions - analysis.noTruncation).toLocaleString()} (${((analysis.totalQuestions - analysis.noTruncation)/analysis.totalQuestions*100).toFixed(1)}%)`);
        console.log(`\nüìÑ Reporte detallado guardado en: ${reportPath}`);
        break;
        
      case 'migrate-clean':
        await migrateOnlyNonTruncated(dryRun);
        break;
        
      case 'remove-truncated':
        await removeTruncatedFromValidQuestion(dryRun);
        break;
        
      default:
        console.log(`
Uso: npx tsx manage-truncated-questions.ts [comando] [--execute]

Comandos:
  analyze           Analizar todas las preguntas por tipo de truncamiento
  migrate-clean     Migrar solo preguntas sin ning√∫n truncamiento
  remove-truncated  Eliminar preguntas truncadas de ValidQuestion

Opciones:
  --execute         Ejecutar cambios reales (por defecto es dry-run)

Ejemplos:
  npx tsx manage-truncated-questions.ts analyze
  npx tsx manage-truncated-questions.ts migrate-clean
  npx tsx manage-truncated-questions.ts migrate-clean --execute
  npx tsx manage-truncated-questions.ts remove-truncated --execute
        `);
    }
    
  } catch (error) {
    console.error('üí• Error:', error);
  } finally {
    await prisma.$disconnect();
  }
}

// Ejecutar si se llama directamente
if (require.main === module) {
  main();
}

export { analyzeTruncatedQuestions, migrateOnlyNonTruncated, removeTruncatedFromValidQuestion }; 