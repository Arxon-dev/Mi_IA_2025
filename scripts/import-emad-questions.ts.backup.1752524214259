import { prisma, closePrismaConnection } from '../src/lib/prisma';
import fs from 'fs';
import path from 'path';

interface ParsedQuestion {
  question: string;
  options: string[];
  correctAnswerIndex: number;
  feedback?: string;
  title?: string;
  sourceReference?: string;
}

function parseGiftFile(filePath: string): ParsedQuestion[] {
  const content = fs.readFileSync(filePath, 'utf-8');
  const questions: ParsedQuestion[] = [];
  
  // Dividir por preguntas individuales (cada pregunta empieza con <b>55/2021 DEL EMAD</b>)
  const questionBlocks = content.split('<b>55/2021 DEL EMAD</b><br><br>').filter(block => block.trim().length > 0);
  
  let questionNumber = 1;
  
  for (const block of questionBlocks) {
    try {
      const parsedQuestion = parseQuestionBlock(block.trim(), questionNumber);
      if (parsedQuestion) {
        questions.push(parsedQuestion);
        questionNumber++;
      }
    } catch (error) {
      console.error(`Error al parsear pregunta ${questionNumber}:`, error);
    }
  }
  
  return questions;
}

function parseQuestionBlock(block: string, questionNumber: number): ParsedQuestion | null {
  // Extraer la pregunta principal (hasta el primer {)
  const questionMatch = block.match(/^([^{]+)\{/);
  if (!questionMatch) {
    console.warn(`No se pudo extraer la pregunta del bloque ${questionNumber}`);
    return null;
  }
  
  const question = questionMatch[1].trim();
  
  // Extraer opciones (entre { y })
  const optionsMatch = block.match(/\{([^}]+)\}/);
  if (!optionsMatch) {
    console.warn(`No se pudieron extraer las opciones del bloque ${questionNumber}`);
    return null;
  }
  
  const optionsSection = optionsMatch[1];
  const options: string[] = [];
  let correctAnswerIndex = -1;
  
  // Parsear opciones
  const optionLines = optionsSection.split('\n').filter(line => line.trim().length > 0);
  
  for (const line of optionLines) {
    const trimmedLine = line.trim();
    
    // Respuesta correcta (=)
    if (trimmedLine.startsWith('=')) {
      correctAnswerIndex = options.length;
      options.push(trimmedLine.substring(1).trim());
    }
    // Respuesta incorrecta (~)
    else if (trimmedLine.startsWith('~')) {
      // Remover el porcentaje negativo si existe
      const cleanOption = trimmedLine.replace(/^~%-?\d+(\.\d+)?%/, '').trim();
      if (cleanOption) {
        options.push(cleanOption);
      }
    }
    // Ignorar l√≠neas que no son opciones
    else if (!trimmedLine.startsWith('####') && !trimmedLine.startsWith('<b>') && !trimmedLine.startsWith('"')) {
      // Podr√≠a ser continuaci√≥n de una opci√≥n anterior
      continue;
    }
  }
  
  // Extraer feedback (despu√©s de ####RETROALIMENTACI√ìN:)
  let feedback = '';
  const feedbackMatch = block.match(/####RETROALIMENTACI√ìN:<br>\s*([^]*?)(?=<b>REGLA CLAVE:<\/b>|$)/);
  if (feedbackMatch) {
    feedback = feedbackMatch[1].trim()
      .replace(/<br>/g, '\n')
      .replace(/"/g, '')
      .trim();
  }
  
  // Extraer reglas clave
  const rulesMatch = block.match(/<b>REGLA CLAVE:<\/b><br>\s*([^]*?)(?=\}|$)/);
  if (rulesMatch) {
    const rules = rulesMatch[1].trim()
      .replace(/<br>/g, '\n')
      .replace(/"/g, '')
      .trim();
    
    if (feedback) {
      feedback += '\n\nREGLA CLAVE:\n' + rules;
    } else {
      feedback = 'REGLA CLAVE:\n' + rules;
    }
  }
  
  if (correctAnswerIndex === -1) {
    console.warn(`No se encontr√≥ respuesta correcta en la pregunta ${questionNumber}`);
    return null;
  }
  
  if (options.length < 2) {
    console.warn(`Pregunta ${questionNumber} tiene menos de 2 opciones`);
    return null;
  }
  
  return {
    question,
    options,
    correctAnswerIndex,
    feedback: feedback || undefined,
    title: `Pregunta ${questionNumber} - EMAD 55/2021`,
    sourceReference: '55/2021 DEL EMAD'
  };
}

async function importQuestions() {
  try {
    console.log('üöÄ Iniciando importaci√≥n de preguntas EMAD...');
    
    const filePath = path.join(process.cwd(), 'docs', 'emad.gift');
    
    if (!fs.existsSync(filePath)) {
      throw new Error(`No se encontr√≥ el archivo: ${filePath}`);
    }
    
    console.log('üìñ Parseando archivo GIFT...');
    const questions = parseGiftFile(filePath);
    
    console.log(`‚úÖ Se parsearon ${questions.length} preguntas`);
    
    if (questions.length === 0) {
      console.log('‚ö†Ô∏è  No se encontraron preguntas para importar');
      return;
    }
    
    console.log('üîå Conectando a la base de datos...');
    // No necesitamos llamar expl√≠citamente $connect() ya que Prisma se conecta autom√°ticamente
    
    console.log('üóÑÔ∏è  Importando preguntas a la base de datos...');
    
    // Limpiar tabla existente si es necesario
    console.log('üîç Verificando tabla existente...');
    const existingCount = await prisma.emad.count();
    if (existingCount > 0) {
      console.log(`‚ö†Ô∏è  Se encontraron ${existingCount} preguntas existentes en la tabla emad`);
      console.log('üßπ Eliminando preguntas existentes...');
      await prisma.emad.deleteMany({});
      console.log('‚úÖ Tabla limpiada');
    }
    
    // Importar preguntas en lotes m√°s peque√±os para reducir la carga
    const batchSize = 20;
    let imported = 0;
    
    for (let i = 0; i < questions.length; i += batchSize) {
      const batch = questions.slice(i, i + batchSize);
      
      const dataToInsert = batch.map((q, index) => ({
        questionNumber: i + index + 1,
        question: q.question,
        options: q.options,
        correctAnswerIndex: q.correctAnswerIndex,
        category: 'emad',
        difficulty: 'OFICIAL',
        isActive: true,
        feedback: q.feedback,
        type: 'gift',
        title: q.title,
        titleSourceReference: q.sourceReference,
        titleSourceDocument: '55/2021 DEL EMAD'
      }));
      
      await prisma.emad.createMany({
        data: dataToInsert
      });
      
      imported += batch.length;
      console.log(`üìù Importadas ${imported}/${questions.length} preguntas`);
      
      // Peque√±a pausa entre lotes para evitar sobrecargar la DB
      await new Promise(resolve => setTimeout(resolve, 100));
    }
    
    console.log('‚úÖ Importaci√≥n completada exitosamente!');
    console.log(`üìä Resumen:`);
    console.log(`   - Preguntas importadas: ${imported}`);
    console.log(`   - Tabla: emad`);
    console.log(`   - Formato: GIFT`);
    console.log(`   - Documento fuente: 55/2021 DEL EMAD`);
    
    // Verificar importaci√≥n
    const finalCount = await prisma.emad.count();
    console.log(`üîç Verificaci√≥n: ${finalCount} preguntas en la tabla emad`);
    
  } catch (error) {
    console.error('‚ùå Error durante la importaci√≥n:', error);
    throw error;
  } finally {
    console.log('üîå Cerrando conexi√≥n a la base de datos...');
    await closePrismaConnection();
  }
}

// Manejar se√±ales de interrupci√≥n correctamente
process.on('SIGINT', async () => {
  console.log('\nüîå Cerrando conexiones por interrupci√≥n...');
  await closePrismaConnection();
  process.exit(0);
});

process.on('SIGTERM', async () => {
  console.log('\nüîå Cerrando conexiones por terminaci√≥n...');
  await closePrismaConnection();
  process.exit(0);
});

process.on('beforeExit', async () => {
  await closePrismaConnection();
});

// Ejecutar solo si se llama directamente
if (require.main === module) {
  importQuestions().catch(console.error);
}

export { importQuestions, parseGiftFile }; 