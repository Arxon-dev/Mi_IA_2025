// Script para limpiar registros problemÃ¡ticos de TournamentResponse
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

async function fixTournamentResponses() {
  try {
    console.log('ğŸ”§ LIMPIEZA DE REGISTROS PROBLEMÃTICOS EN TournamentResponse');
    console.log('===========================================================');
    
    // 1. Encontrar respuestas sin pollId
    console.log('ğŸ” 1. IDENTIFICANDO REGISTROS PROBLEMÃTICOS:');
    console.log('=============================================');
    
    const responsesSinPollId = await prisma.tournamentResponse.findMany({
      where: {
        OR: [
          { pollId: null },
          { pollId: '' }
        ]
      },
      include: {
        participant: {
          include: {
            user: { select: { firstName: true, telegramUserId: true } },
            tournament: { select: { name: true, status: true } }
          }
        }
      }
    });
    
    console.log(`ğŸ“Š Encontradas ${responsesSinPollId.length} respuestas problemÃ¡ticas:`);
    
    responsesSinPollId.forEach((resp, i) => {
      console.log(`   ${i + 1}. Usuario: ${resp.participant.user.firstName}`);
      console.log(`      Torneo: ${resp.participant.tournament.name}`);
      console.log(`      Status torneo: ${resp.participant.tournament.status}`);
      console.log(`      Pregunta #: ${resp.questionNumber}`);
      console.log(`      Poll ID: ${resp.pollId || 'NULL'}`);
      console.log(`      Respondido: ${resp.answeredAt ? 'SÃ­' : 'No'}`);
      console.log('');
    });
    
    if (responsesSinPollId.length === 0) {
      console.log('âœ… No se encontraron registros problemÃ¡ticos. El problema puede estar en otro lado.');
      return { cleaned: 0, message: 'No hay registros para limpiar' };
    }
    
    // 2. Decidir quÃ© hacer con cada tipo
    console.log('ğŸ¯ 2. ESTRATEGIA DE LIMPIEZA:');
    console.log('=============================');
    
    const sinResponder = responsesSinPollId.filter(r => !r.answeredAt);
    const respondidas = responsesSinPollId.filter(r => r.answeredAt);
    
    console.log(`ğŸ“‹ Respuestas sin responder: ${sinResponder.length}`);
    console.log(`âœ… Respuestas ya respondidas: ${respondidas.length}`);
    
    // 3. Limpiar respuestas sin responder (son registros "fantasma")
    let cleaned = 0;
    
    if (sinResponder.length > 0) {
      console.log('\\nğŸ—‘ï¸ ELIMINANDO RESPUESTAS SIN RESPONDER (registros fantasma):');
      console.log('==============================================================');
      
      for (const resp of sinResponder) {
        console.log(`   ğŸ—‘ï¸ Eliminando: ${resp.participant.user.firstName} - Torneo "${resp.participant.tournament.name}" - Pregunta ${resp.questionNumber}`);
        
        await prisma.tournamentResponse.delete({
          where: { id: resp.id }
        });
        
        cleaned++;
      }
      
      console.log(`âœ… ${cleaned} registros fantasma eliminados.`);
    }
    
    // 4. Para respuestas ya respondidas, generar pollIds Ãºnicos
    if (respondidas.length > 0) {
      console.log('\\nğŸ”§ REPARANDO RESPUESTAS YA RESPONDIDAS:');
      console.log('=======================================');
      
      for (const resp of respondidas) {
        // Generar un pollId Ãºnico basado en timestamp
        const fakePollId = `tournament_${resp.participant.tournament.name.replace(/\\s+/g, '_')}_${resp.questionNumber}_${Date.now()}`;
        
        console.log(`   ğŸ”§ Reparando: ${resp.participant.user.firstName} - Pregunta ${resp.questionNumber}`);
        console.log(`      Nuevo Poll ID: ${fakePollId}`);
        
        await prisma.tournamentResponse.update({
          where: { id: resp.id },
          data: { pollId: fakePollId }
        });
        
        cleaned++;
      }
      
      console.log(`âœ… ${respondidas.length} respuestas reparadas con pollIds Ãºnicos.`);
    }
    
    // 5. VerificaciÃ³n final
    console.log('\\nğŸ” 3. VERIFICACIÃ“N FINAL:');
    console.log('==========================');
    
    const remaining = await prisma.tournamentResponse.count({
      where: {
        OR: [
          { pollId: null },
          { pollId: '' }
        ]
      }
    });
    
    console.log(`ğŸ“Š Registros problemÃ¡ticos restantes: ${remaining}`);
    
    return { 
      cleaned, 
      message: cleaned > 0 ? `${cleaned} registros limpiados exitosamente` : 'No habÃ­a registros para limpiar'
    };
    
  } catch (error) {
    console.error('âŒ Error durante la limpieza:', error);
    return { cleaned: 0, message: 'Error durante la limpieza' };
  } finally {
    await prisma.$disconnect();
  }
}

async function main() {
  console.log('ğŸš€ INICIANDO LIMPIEZA DE TournamentResponse...');
  console.log('===============================================');
  
  const result = await fixTournamentResponses();
  
  console.log('\\nğŸ“‹ RESULTADO FINAL:');
  console.log('===================');
  console.log(`ğŸ¯ ${result.message}`);
  
  if (result.cleaned > 0) {
    console.log('\\nâœ… PROBLEMA SOLUCIONADO!');
    console.log('ğŸ‰ Los usuarios ahora deberÃ­an recibir puntos por preguntas regulares.');
    console.log('ğŸ§ª Puedes probar enviando /test al grupo para verificar.');
  } else {
    console.log('\\nğŸ¤” Si el problema persiste, puede estar en la lÃ³gica de handleTournamentPollAnswer.');
    console.log('ğŸ” Revisa los logs del webhook cuando llegue una respuesta de poll.');
  }
}

main(); 