import { PrismaService } from '../src/services/prismaService';
import { prisma } from '../src/lib/prisma';

async function testIntegratedScheduler() {
  try {
    console.log('ðŸ§ª PRUEBA DEL SCHEDULER INTEGRADO (ValidQuestion + ExamenOficial2018 + ExamenOficial2024 + SectionQuestion)');
    console.log('=' .repeat(80));
    
    // 1. Verificar que las cuatro tablas tengan datos
    console.log('\nðŸ“Š VERIFICANDO DATOS DISPONIBLES:');
    
    const totalValidQuestions = await prisma.validQuestion.count({ where: { isActive: true } });
    const totalExam2018Questions = await prisma.examenOficial2018.count({ where: { isActive: true } });
    const totalExam2024Questions = await (prisma as any).examenOficial2024.count({ where: { isActive: true } });
    const totalSectionQuestions = await prisma.sectionQuestion.count();
    
    console.log(`   ðŸ“„ ValidQuestion activas: ${totalValidQuestions}`);
    console.log(`   ðŸŽ¯ ExamenOficial2018 activas: ${totalExam2018Questions}`);
    console.log(`   ðŸŽ¯ ExamenOficial2024 activas: ${totalExam2024Questions}`);
    console.log(`   ðŸ“š SectionQuestion activas: ${totalSectionQuestions}`);
    
    if (totalValidQuestions === 0 && totalExam2018Questions === 0 && totalExam2024Questions === 0 && totalSectionQuestions === 0) {
      console.log('âŒ No hay preguntas disponibles para probar');
      return;
    }
    
    // 2. Probar el scheduler con diferentes cantidades
    const testQuantities = [1, 3, 5, 10];
    
    for (const quantity of testQuantities) {
      console.log(`\nðŸ”„ PROBANDO CON ${quantity} PREGUNTAS:`);
      console.log('-' .repeat(50));
      
      const questions = await PrismaService.getQuestionsForTelegramScheduler(quantity, 0, 30);
      
      console.log(`   âœ… Obtenidas: ${questions.length} preguntas`);
      
      // Analizar distribuciÃ³n por sourceModel
      const distribution = questions.reduce((acc, q) => {
        acc[q.sourceModel] = (acc[q.sourceModel] || 0) + 1;
        return acc;
      }, {} as Record<string, number>);
      
      console.log('   ðŸ“Š DistribuciÃ³n por fuente:');
      Object.entries(distribution).forEach(([source, count]) => {
        const percentage = ((count / questions.length) * 100).toFixed(1);
        console.log(`      ${source}: ${count} (${percentage}%)`);
      });
      
      // Verificar que el contenido estÃ© bien formateado
      if (questions.length > 0) {
        const sampleQuestion = questions[0];
        console.log(`   ðŸ” Muestra (${sampleQuestion.sourceModel}):`);
        
        try {
          const parsedContent = JSON.parse(sampleQuestion.content);
          console.log(`      Pregunta: ${parsedContent.question.substring(0, 60)}...`);
          console.log(`      Opciones: ${parsedContent.options.length}`);
          console.log(`      Respuesta correcta: ${parsedContent.correctAnswerIndex}`);
          console.log(`      ExplicaciÃ³n: ${parsedContent.explanation ? 'SÃ­' : 'No'}`);
        } catch (error) {
          console.log(`      âŒ Error parseando contenido: ${error}`);
        }
      }
    }
    
    // 3. Verificar rotaciÃ³n - las preguntas con menor sendCount deben aparecer primero
    console.log(`\nðŸ”„ VERIFICANDO ROTACIÃ“N:`);
    console.log('-' .repeat(50));
    
    const largeSet = await PrismaService.getQuestionsForTelegramScheduler(20, 0, 30);
    
    if (largeSet.length > 0) {
      const sendCounts = largeSet.map(q => q.sendCount);
      const minSendCount = Math.min(...sendCounts);
      const maxSendCount = Math.max(...sendCounts);
      
      console.log(`   ðŸ“ˆ Rango de sendCount: ${minSendCount} - ${maxSendCount}`);
      
      // Verificar que las primeras preguntas tengan el menor sendCount
      const firstFive = largeSet.slice(0, 5);
      const allHaveMinCount = firstFive.every(q => q.sendCount === minSendCount);
      
      if (allHaveMinCount) {
        console.log('   âœ… RotaciÃ³n correcta: preguntas menos enviadas aparecen primero');
      } else {
        console.log('   âš ï¸  Posible problema de rotaciÃ³n');
        firstFive.forEach((q, i) => {
          console.log(`      ${i+1}. ${q.sourceModel} - sendCount: ${q.sendCount}`);
        });
      }
    }
    
    // 4. Simular un envÃ­o para verificar actualizaciÃ³n
    if (largeSet.length > 0) {
      console.log(`\nðŸ“¤ SIMULANDO ENVÃO Y ACTUALIZACIÃ“N:`);
      console.log('-' .repeat(50));
      
      const testQuestion = largeSet[0];
      const originalSendCount = testQuestion.sendCount;
      
      console.log(`   ðŸŽ¯ Pregunta seleccionada: ${testQuestion.sourceModel} (sendCount: ${originalSendCount})`);
      
      // Simular envÃ­o exitoso
      await PrismaService.updateLastScheduledSendAt(
        testQuestion.id, 
        testQuestion.sourceModel as any,
        true, 
        'test_msg_123',
        undefined
      );
      
      console.log('   âœ… EnvÃ­o simulado exitosamente');
      
      // Verificar que se actualizÃ³ correctamente
      let updatedQuestion;
      if (testQuestion.sourceModel === 'validQuestion') {
        updatedQuestion = await prisma.validQuestion.findUnique({
          where: { id: testQuestion.id }
        });
      } else if (testQuestion.sourceModel === 'examenOficial2018') {
        updatedQuestion = await prisma.examenOficial2018.findUnique({
          where: { id: testQuestion.id }
        });
      } else if (testQuestion.sourceModel === 'examenOficial2024') {
        updatedQuestion = await (prisma as any).examenOficial2024.findUnique({
          where: { id: testQuestion.id }
        });
      } else if (testQuestion.sourceModel === 'sectionQuestion') {
        updatedQuestion = await prisma.sectionQuestion.findUnique({
          where: { id: testQuestion.id }
        });
      }
      
      if (updatedQuestion) {
        console.log(`   ðŸ“Š SendCount actualizado: ${originalSendCount} â†’ ${updatedQuestion.sendCount}`);
        console.log(`   â° LastSuccessfulSendAt: ${updatedQuestion.lastSuccessfulSendAt ? 'Actualizado' : 'Sin cambios'}`);
      }
    }
    
    console.log('\nðŸŽ‰ PRUEBA DEL SCHEDULER INTEGRADO COMPLETADA');
    console.log('âœ… El scheduler estÃ¡ funcionando correctamente con las tres fuentes');
    
  } catch (error) {
    console.error('ðŸ’¥ Error en la prueba del scheduler:', error);
  } finally {
    await prisma.$disconnect();
  }
}

// Ejecutar si es llamado directamente
if (require.main === module) {
  testIntegratedScheduler()
    .then(() => {
      console.log('\nâœ… Prueba completada');
      process.exit(0);
    })
    .catch((error) => {
      console.error('ðŸ’¥ Error fatal:', error);
      process.exit(1);
    });
}

export { testIntegratedScheduler }; 