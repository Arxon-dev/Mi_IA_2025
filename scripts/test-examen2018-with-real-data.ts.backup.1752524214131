import { config } from 'dotenv';

config();

async function testExamen2018WithRealData() {
  try {
    console.log('üß™ PROBANDO /examen2018stats CON DATOS REALES');
    console.log('=' .repeat(60));
    
    const { PrismaClient } = await import('@prisma/client');
    const prisma = new PrismaClient();
    
    await prisma.$connect();
    
    // 1. Verificar datos existentes
    console.log('\nüîç 1. VERIFICANDO DATOS EXISTENTES...');
    
    const totalUsers = await prisma.telegramUser.count();
    const totalResponses = await prisma.telegramResponse.count();
    const totalPolls = await prisma.telegramPoll.count({
      where: { sourceModel: 'examenOficial2018' }
    });
    
    console.log(`   üë• Usuarios: ${totalUsers}`);
    console.log(`   üìù Respuestas: ${totalResponses}`);
    console.log(`   üéØ Polls examen2018: ${totalPolls}`);
    
    // 2. Buscar usuario de prueba
    const testUserId = '5793286375'; // Carlos
    const testUser = await prisma.telegramUser.findUnique({
      where: { telegramUserId: testUserId }
    });
    
    if (!testUser) {
      console.log('\n‚ùå Usuario de prueba no encontrado, creando...');
      
      const newUser = await prisma.telegramUser.create({
        data: {
          telegramUserId: testUserId,
          username: 'Carlos_esp',
          firstName: 'Carlos',
          totalPoints: 100,
          level: 2,
          streak: 3
        }
      });
      
      console.log('‚úÖ Usuario creado:', newUser.firstName);
    } else {
      console.log('‚úÖ Usuario encontrado:', testUser.firstName);
    }
    
    // 3. Verificar respuestas del usuario al examen2018
    console.log('\nüìä 3. VERIFICANDO RESPUESTAS DEL USUARIO...');
    
    const userExamenResponses = await prisma.$queryRaw`
      SELECT 
        tr."isCorrect",
        tr."answeredAt",
        tp."questionId",
        eo."questionNumber",
        eo.category
      FROM "TelegramResponse" tr
      JOIN "TelegramPoll" tp ON tr."questionId" = tp."pollId"
      JOIN "ExamenOficial2018" eo ON tp."questionId" = eo.id
      JOIN "TelegramUser" tu ON tr."userId" = tu.id
      WHERE tu."telegramUserId" = ${testUserId}
      AND tp."sourceModel" = 'examenOficial2018'
      ORDER BY tr."answeredAt" DESC
      LIMIT 10
    ` as any[];
    
    console.log(`   üìù Respuestas del usuario al examen: ${userExamenResponses.length}`);
    
    if (userExamenResponses.length > 0) {
      console.log('   üéØ √öltimas respuestas:');
      userExamenResponses.slice(0, 3).forEach((response, index) => {
        const emoji = response.isCorrect ? '‚úÖ' : '‚ùå';
        console.log(`      ${emoji} P${response.questionNumber} - ${response.category}`);
      });
    }
    
    // 4. Si no hay respuestas, crear algunas de prueba
    if (userExamenResponses.length === 0) {
      console.log('\nüîß 4. CREANDO DATOS DE PRUEBA...');
      
      // Obtener algunas preguntas del examen
      const sampleQuestions = await prisma.examenOficial2018.findMany({
        take: 5,
        orderBy: { questionNumber: 'asc' }
      });
      
      if (sampleQuestions.length > 0) {
        console.log(`   üìù Encontradas ${sampleQuestions.length} preguntas para crear respuestas`);
        
        // Crear polls ficticios para las pruebas
        for (const question of sampleQuestions) {
          // Crear poll ficticio
          const poll = await prisma.telegramPoll.create({
            data: {
              pollId: `test-poll-${question.id}`,
              questionId: question.id,
              sourceModel: 'examenOficial2018',
              correctAnswerIndex: question.correctAnswerIndex,
              options: question.options,
              chatId: testUserId
            }
          });
          
          // Crear respuesta ficticia
          await prisma.telegramResponse.create({
            data: {
              userId: testUser!.id,
              questionId: poll.pollId,
              isCorrect: Math.random() > 0.3, // 70% de acierto
              responseTime: Math.floor(Math.random() * 30) + 10, // 10-40 segundos
              points: Math.random() > 0.3 ? 20 : 0,
              answeredAt: new Date(Date.now() - Math.random() * 7 * 24 * 60 * 60 * 1000) // √öltima semana
            }
          });
        }
        
        console.log('‚úÖ Datos de prueba creados');
      }
    }
    
    // 5. Probar el comando stats
    console.log('\nüéØ 5. PROBANDO COMANDO /examen2018stats...');
    
    const testMessage = {
      message_id: Date.now(),
      from: {
        id: parseInt(testUserId),
        is_bot: false,
        first_name: "Carlos",
        username: "Carlos_esp"
      },
      chat: {
        id: parseInt(testUserId),
        type: "private"
      },
      date: Math.floor(Date.now() / 1000),
      text: "/examen2018stats"
    };
    
    const webhookResponse = await fetch('http://localhost:3000/api/telegram/webhook', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        update_id: Date.now(),
        message: testMessage
      })
    });
    
    if (webhookResponse.ok) {
      console.log('‚úÖ Comando procesado exitosamente');
      console.log('üí¨ El bot deber√≠a haber enviado estad√≠sticas por privado');
    } else {
      console.log('‚ùå Error en webhook:', webhookResponse.status);
    }
    
    await prisma.$disconnect();
    
    console.log('\nüéâ PRUEBA COMPLETADA');
    console.log('üì± Ve a tu chat privado con @OpoMelillaBot para ver las estad√≠sticas');
    
  } catch (error) {
    console.error('‚ùå ERROR:', error);
  }
}

testExamen2018WithRealData(); 