import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

async function testQuotaTracking() {
  try {
    console.log('üß™ TESTING QUOTA TRACKING SYSTEM\n');
    
    const testUserId = '1234567890'; // Usuario de prueba
    const testUserName = 'UsuarioPrueba';
    
    // === PASO 1: Verificar/Crear usuario de prueba ===
    console.log('üë§ PASO 1: Configurando usuario de prueba...');
    
    let user = await prisma.telegramUser.findUnique({
      where: { telegramUserId: testUserId }
    });
    
    if (!user) {
      user = await prisma.telegramUser.create({
        data: {
          telegramUserId: testUserId,
          firstName: testUserName,
          username: testUserName,
          totalPoints: 0,
          level: 1,
          streak: 0
        }
      });
      console.log('‚úÖ Usuario de prueba creado');
    } else {
      console.log('‚úÖ Usuario de prueba ya existe');
    }
    
    // === PASO 2: Verificar/Crear plan b√°sico ===
    console.log('\nüí∞ PASO 2: Verificando plan b√°sico...');
    
    const existingPlan = await prisma.$queryRaw`
      SELECT * FROM "SubscriptionPlan" WHERE "name" = 'basic' LIMIT 1
    ` as any[];
    
    let basicPlan;
    
    if (existingPlan.length === 0) {
      // Generar ID √∫nico para el plan
      const planId = `plan_basic_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      
      await prisma.$executeRaw`
        INSERT INTO "SubscriptionPlan" (
          "id", "name", "displayName", "description", "price", "currency", "billingPeriod",
          "dailyQuestionsLimit", "monthlyQuestionsLimit", "canUseFailedQuestions",
          "canUseAdvancedStats", "canUseSimulations", "canUseAIAnalysis", 
          "canUseCustomExams", "canUseMoodleIntegration", "maxSimulationsPerDay",
          "maxReportsPerMonth", "isActive", "createdAt", "updatedAt"
        ) VALUES (
          ${planId}, 'basic', 'B√°sico', '100 preguntas/d√≠a, sistema de preguntas falladas, estad√≠sticas b√°sicas',
          4.99, 'EUR', 'monthly', 100, 3000, true, false, false, false, false, false, 1, 4, true, NOW(), NOW()
        )
      `;
      
      const newPlan = await prisma.$queryRaw`
        SELECT * FROM "SubscriptionPlan" WHERE "name" = 'basic' LIMIT 1
      ` as any[];
      basicPlan = newPlan[0];
      console.log('‚úÖ Plan b√°sico creado');
    } else {
      basicPlan = existingPlan[0];
      console.log('‚úÖ Plan b√°sico ya existe');
    }
    
    // === PASO 3: Verificar/Crear suscripci√≥n activa ===
    console.log('\nüìã PASO 3: Configurando suscripci√≥n activa...');
    
    const existingSubscription = await prisma.$queryRaw`
      SELECT * FROM "UserSubscription" WHERE "userId" = ${user.id} LIMIT 1
    ` as any[];
    
    const now = new Date();
    const endDate = new Date(now);
    endDate.setMonth(endDate.getMonth() + 1);
    
    let currentSubscriptionId;
    
    if (existingSubscription.length === 0) {
      // Generar UUID para el ID
      currentSubscriptionId = `sub_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      
      await prisma.$executeRaw`
        INSERT INTO "UserSubscription" (
          "id", "userId", "planId", "status", "startDate", "endDate", "autoRenew", "createdAt", "updatedAt"
        ) VALUES (
          ${currentSubscriptionId}, ${user.id}, ${basicPlan.id}, 'active', ${now}, ${endDate}, true, NOW(), NOW()
        )
      `;
      console.log('‚úÖ Suscripci√≥n creada');
    } else {
      currentSubscriptionId = existingSubscription[0].id;
      await prisma.$executeRaw`
        UPDATE "UserSubscription" 
        SET "planId" = ${basicPlan.id}, "status" = 'active', "endDate" = ${endDate}, "updatedAt" = NOW()
        WHERE "userId" = ${user.id}
      `;
      console.log('‚úÖ Suscripci√≥n actualizada');
    }
    
    // === PASO 4: Verificar estado inicial ===
    console.log('\nüìä PASO 4: Verificando estado inicial...');
    
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    
    const initialUsage = await prisma.$queryRaw`
      SELECT 
        "questionsUsed",
        "failedQuestionsUsed",
        "simulationsUsed"
      FROM "UserQuotaUsage"
      WHERE "userId" = ${user.id} AND "date" = ${today}
      LIMIT 1
    ` as any[];
    
    console.log('üìà Uso inicial del d√≠a:', initialUsage[0] || 'Sin uso registrado');
    
    // === PASO 5: Simular tracking de preguntas normales ===
    console.log('\nüéØ PASO 5: Simulando tracking de preguntas normales...');
    
    const questionsToAdd = 5;
    
    try {
      if (initialUsage.length > 0) {
        // Actualizar uso existente
        const currentQuestions = initialUsage[0].questionsUsed || 0;
        
        await prisma.$executeRaw`
          UPDATE "UserQuotaUsage" 
          SET "questionsUsed" = ${currentQuestions + questionsToAdd},
              "updatedAt" = NOW()
          WHERE "userId" = ${user.id} AND "date" = ${today}
        `;
        console.log(`‚úÖ Incrementado uso existente: +${questionsToAdd} preguntas normales`);
      } else {
        // Crear nuevo registro
        const quotaId = `quota_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        
        await prisma.$executeRaw`
          INSERT INTO "UserQuotaUsage" ("id", "userId", "subscriptionId", "date", "questionsUsed", "failedQuestionsUsed", "simulationsUsed", "reportsGenerated", "aiAnalysisUsed", "createdAt", "updatedAt")
          VALUES (${quotaId}, ${user.id}, ${currentSubscriptionId}, ${today}, ${questionsToAdd}, 0, 0, 0, 0, NOW(), NOW())
        `;
        console.log(`‚úÖ Creado nuevo registro: ${questionsToAdd} preguntas normales`);
      }
    } catch (error) {
      console.error('‚ùå Error en tracking de preguntas normales:', error);
    }
    
    // === PASO 6: Simular tracking de preguntas falladas ===
    console.log('\nüîÑ PASO 6: Simulando tracking de preguntas falladas...');
    
    const failedQuestionsToAdd = 3;
    
    try {
      const currentUsage = await prisma.$queryRaw`
        SELECT 
          "questionsUsed",
          "failedQuestionsUsed"
        FROM "UserQuotaUsage"
        WHERE "userId" = ${user.id} AND "date" = ${today}
        LIMIT 1
      ` as any[];
      
      const current = currentUsage[0];
      const currentFailed = current.failedQuestionsUsed || 0;
      
      await prisma.$executeRaw`
        UPDATE "UserQuotaUsage" 
        SET "failedQuestionsUsed" = ${currentFailed + failedQuestionsToAdd},
            "updatedAt" = NOW()
        WHERE "userId" = ${user.id} AND "date" = ${today}
      `;
      console.log(`‚úÖ Incrementado: +${failedQuestionsToAdd} preguntas falladas`);
    } catch (error) {
      console.error('‚ùå Error en tracking de preguntas falladas:', error);
    }
    
    // === PASO 7: Verificar resultado final ===
    console.log('\nüìã PASO 7: Verificando resultado final...');
    
    const finalUsage = await prisma.$queryRaw`
      SELECT 
        "questionsUsed",
        "failedQuestionsUsed",
        "simulationsUsed"
      FROM "UserQuotaUsage"
      WHERE "userId" = ${user.id} AND "date" = ${today}
      LIMIT 1
    ` as any[];
    
    const usage = finalUsage[0];
    const totalQuestions = (usage.questionsUsed || 0) + (usage.failedQuestionsUsed || 0);
    
    console.log('üìä USO FINAL DEL D√çA:');
    console.log(`   üéØ Preguntas normales: ${usage.questionsUsed || 0}`);
    console.log(`   üîÑ Preguntas falladas: ${usage.failedQuestionsUsed || 0}`);
    console.log(`   üìà Total preguntas: ${totalQuestions}`);
    console.log(`   üéÆ Simulacros: ${usage.simulationsUsed || 0}`);
    
    // === PASO 8: Simular comando /mi_quota ===
    console.log('\nüí¨ PASO 8: Simulando comando /mi_quota...');
    
    const quotaCheck = await prisma.$queryRaw`
      SELECT 
        tu."telegramUserId",
        tu."firstName",
        s."status",
        s."endDate",
        p."name" as "planName",
        p."displayName" as "planDisplayName",
        p."price",
        p."dailyQuestionsLimit",
        p."maxSimulationsPerDay"
      FROM "TelegramUser" tu
      LEFT JOIN "UserSubscription" s ON tu."id" = s."userId" AND s."status" = 'active' AND s."endDate" >= NOW()
      LEFT JOIN "SubscriptionPlan" p ON s."planId" = p."id"
      WHERE tu."telegramUserId" = ${testUserId}
      LIMIT 1
    ` as any[];
    
    const userSub = quotaCheck[0];
    const questionsLimit = userSub.dailyQuestionsLimit || 100;
    const remaining = Math.max(0, questionsLimit - totalQuestions);
    
    console.log('üì± RESPUESTA DEL COMANDO /mi_quota:');
    console.log(`   üë§ Usuario: ${userSub.firstName}`);
    console.log(`   üíé Plan: ${userSub.planDisplayName}`);
    console.log(`   üìö Uso: ${totalQuestions}/${questionsLimit} (${remaining} restantes)`);
    
    // === PASO 9: Verificaci√≥n de √©xito ===
    console.log('\n‚úÖ PASO 9: Verificaci√≥n final...');
    
    if (totalQuestions === questionsToAdd + failedQuestionsToAdd) {
      console.log('üéâ ¬°TRACKING DE CUOTAS FUNCIONANDO CORRECTAMENTE!');
      console.log(`   ‚úÖ Se registraron correctamente ${totalQuestions} preguntas`);
      console.log('   ‚úÖ El comando /mi_quota muestra el uso correcto');
      console.log('   ‚úÖ Los l√≠mites se calculan correctamente');
    } else {
      console.log('‚ùå HAY UN PROBLEMA CON EL TRACKING');
      console.log(`   ‚ùå Esperado: ${questionsToAdd + failedQuestionsToAdd}, Obtenido: ${totalQuestions}`);
    }
    
  } catch (error) {
    console.error('‚ùå Error en test de tracking:', error);
  } finally {
    await prisma.$disconnect();
  }
}

testQuotaTracking(); 