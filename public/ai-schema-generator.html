<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Generador de Esquemas con IA - NeuroOpositor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 40px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            font-weight: 700;
        }

        .header p {
            font-size: 1.2rem;
            opacity: 0.9;
            margin-bottom: 20px;
        }

        .ai-notice {
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
            padding: 15px;
            margin-top: 20px;
        }

        .ai-badge {
            background: linear-gradient(45deg, #ffd700, #ffed4e);
            color: #333;
            padding: 5px 15px;
            border-radius: 20px;
            font-weight: 600;
            font-size: 0.9rem;
            display: inline-block;
            margin-bottom: 10px;
        }

        .content {
            padding: 40px;
        }

        .input-section {
            margin-bottom: 30px;
        }

        .input-section label {
            display: block;
            margin-bottom: 10px;
            font-weight: 600;
            color: #333;
        }

        .input-section textarea {
            width: 100%;
            height: 200px;
            padding: 15px;
            border: 2px solid #e1e5e9;
            border-radius: 10px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            resize: vertical;
            transition: border-color 0.3s ease;
        }

        .input-section textarea:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 30px;
            align-items: center;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .control-group label {
            font-weight: 600;
            color: #333;
            font-size: 14px;
        }

        select, input[type="range"] {
            padding: 8px 12px;
            border: 2px solid #e1e5e9;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s ease;
        }

        select:focus {
            outline: none;
            border-color: #667eea;
        }

        .ai-controls {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
        }

        .ai-controls h3 {
            margin-bottom: 15px;
            color: #333;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }

        .checkbox-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: #667eea;
        }

        .buttons {
            display: flex;
            gap: 15px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 10px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(102, 126, 234, 0.3);
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn-secondary:hover {
            background: #5a6268;
            transform: translateY(-2px);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none !important;
        }

        .canvas-container {
            border: 3px solid #e1e5e9;
            border-radius: 15px;
            background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
            padding: 20px;
            margin-bottom: 20px;
        }

        #schemaCanvas {
            width: 100%;
            max-width: 100%;
            height: auto;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }

        .loading {
            display: none;
            text-align: center;
            padding: 40px;
            color: #667eea;
        }

        .loading.show {
            display: block;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .ai-suggestions {
            background: #e8f4fd;
            border: 1px solid #bee5eb;
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
            display: none;
        }

        .ai-suggestions.show {
            display: block;
        }

        .ai-suggestions h4 {
            color: #0c5460;
            margin-bottom: 10px;
        }

        .ai-suggestions ul {
            list-style: none;
            padding: 0;
        }

        .ai-suggestions li {
            padding: 5px 0;
            color: #0c5460;
        }

        .ai-suggestions li:before {
            content: "üí° ";
            margin-right: 5px;
        }

        @media (max-width: 768px) {
            .header h1 {
                font-size: 2rem;
            }
            
            .content {
                padding: 20px;
            }
            
            .controls {
                flex-direction: column;
                align-items: stretch;
            }
            
            .buttons {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üß† Generador de Esquemas con IA - NeuroOpositor</h1>
            <p>Convierte texto en esquemas visuales inteligentes para optimizar tu estudio</p>
            <div class="ai-notice">
                <span class="ai-badge">‚ú® Potenciado por IA</span>
                <p>Este generador utiliza inteligencia artificial para mejorar autom√°ticamente tus esquemas</p>
            </div>
        </div>

        <div class="content">
            <div class="input-section">
                <label for="inputText">üìù Texto para convertir en esquema:</label>
                <textarea id="inputText" placeholder="Ingresa el texto que quieres convertir en esquema...\n\nSistema de indentaci√≥n por espacios (cada 2 espacios = 1 nivel):\n\nEJ√âRCITO DEL AIRE Y DEL ESPACIO\n  CUARTEL GENERAL\n    JEMA\n      Estado Mayor del EA (EMA)\n        Secretar√≠a General del Estado Mayor\n        Divisi√≥n de Planes (DPL)\n        Divisi√≥n de Operaciones (DOP)\n        Divisi√≥n de Log√≠stica (DLO)\n      Gabinete del Jefe de Estado Mayor del EA\n        Jefatura\n        Secretar√≠a\n    Jefatura de Servicios T√©cnicos\n      Jefatura\n      Oficina T√©cnica"></textarea>
            </div>

            <div class="ai-controls">
                <h3>ü§ñ Configuraci√≥n de IA</h3>
                <div class="checkbox-group">
                    <input type="checkbox" id="enhanceWithAI" checked>
                    <label for="enhanceWithAI">Mejorar contenido con IA</label>
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="autoOptimize">
                    <label for="autoOptimize">Optimizaci√≥n autom√°tica de estructura</label>
                </div>
                <div class="control-group">
                    <label for="aiTemperature">Creatividad IA: <span id="tempValue">0.7</span></label>
                    <input type="range" id="aiTemperature" min="0" max="1" step="0.1" value="0.7">
                </div>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label for="schemaType">üìä Tipo de esquema:</label>
                    <select id="schemaType">
                        <option value="hierarchical">Jer√°rquico</option>
                        <option value="timeline">L√≠nea de tiempo</option>
                        <option value="flowchart">Diagrama de flujo</option>
                        <option value="mindmap">Mapa mental</option>
                    </select>
                </div>

                <div class="control-group">
                    <label for="colorScheme">üé® Esquema de colores:</label>
                    <select id="colorScheme">
                        <option value="blue">Azul profesional</option>
                        <option value="green">Verde natural</option>
                        <option value="purple">P√∫rpura creativo</option>
                        <option value="orange">Naranja energ√©tico</option>
                    </select>
                </div>
            </div>

            <div class="buttons">
                <button class="btn btn-primary" onclick="generateSchema()">
                    <span>üöÄ</span> Generar Esquema con IA
                </button>
                <button class="btn btn-secondary" onclick="downloadSchema()">
                    <span>üíæ</span> Descargar PNG
                </button>
                <button class="btn btn-secondary" onclick="clearCanvas()">
                    <span>üóëÔ∏è</span> Limpiar
                </button>
            </div>

            <div class="loading" id="loading">
                <div class="spinner"></div>
                <p>La IA est√° procesando tu esquema...</p>
            </div>

            <div class="canvas-container">
                <canvas id="schemaCanvas" width="800" height="600"></canvas>
            </div>

            <div class="ai-suggestions" id="aiSuggestions">
                <h4>üí° Sugerencias de la IA:</h4>
                <ul id="suggestionsList"></ul>
            </div>
        </div>
    </div>

    <script>
        // Variables globales
        let canvas, ctx;
        let currentNodes = [];
        let aiEnhanced = false;

        // Inicializaci√≥n
        document.addEventListener('DOMContentLoaded', function() {
            canvas = document.getElementById('schemaCanvas');
            ctx = canvas.getContext('2d');
            
            // Configurar canvas responsivo
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            // Event listeners
            document.getElementById('aiTemperature').addEventListener('input', function(e) {
                document.getElementById('tempValue').textContent = e.target.value;
            });
        });

        function resizeCanvas() {
            const container = canvas.parentElement;
            const containerWidth = container.clientWidth - 40; // padding
            canvas.width = Math.min(containerWidth, 800);
            canvas.height = 600;
        }

        // Funci√≥n principal para generar esquema
        async function generateSchema() {
            const inputText = document.getElementById('inputText').value.trim();
            
            if (!inputText) {
                alert('Por favor, ingresa alg√∫n texto para generar el esquema.');
                return;
            }

            showLoading(true);
            
            try {
                // Parsear texto inicial
                let nodes = parseTextToNodes(inputText);
                
                // Mejorar con IA si est√° habilitado
                if (document.getElementById('enhanceWithAI').checked) {
                    nodes = await enhanceWithAI(nodes);
                }
                
                // Calcular posiciones seg√∫n el tipo de esquema
                const schemaType = document.getElementById('schemaType').value;
                nodes = calculateNodePositions(nodes, schemaType);
                
                currentNodes = nodes;
                
                // Dibujar esquema
                drawSchema(nodes);
                
                showLoading(false);
                
            } catch (error) {
                console.error('Error al generar esquema:', error);
                alert('Error al generar el esquema. Por favor, int√©ntalo de nuevo.');
                showLoading(false);
            }
        }

        function parseTextToNodes(text) {
            const lines = text.split('\n').filter(line => line.trim());
            const nodes = [];
            
            lines.forEach((line, index) => {
                const trimmedLine = line.trim();
                const level = Math.floor((line.length - trimmedLine.length) / 2);
                
                nodes.push({
                    id: `node-${index}`,
                    text: trimmedLine,
                    level: level,
                    x: 0,
                    y: 0
                });
            });
            
            return nodes;
        }

        async function enhanceWithAI(nodes) {
            // Simulaci√≥n de mejora con IA
            // En un entorno real, esto har√≠a una llamada a la API
            
            const enhancedNodes = nodes.map((node, index) => {
                let enhancedText = node.text;
                
                // Mejoras simuladas
                if (node.level === 0) {
                    enhancedText = `üìö ${enhancedText}`;
                } else if (node.level === 1) {
                    enhancedText = `üîπ ${enhancedText}`;
                } else {
                    enhancedText = `‚Ä¢ ${enhancedText}`;
                }
                
                return {
                    ...node,
                    text: enhancedText
                };
            });
            
            // Mostrar sugerencias de IA
            showAISuggestions([
                'Considera a√±adir m√°s detalles a los conceptos principales',
                'Podr√≠as incluir ejemplos pr√°cticos para cada subtema',
                'Ser√≠a √∫til a√±adir conexiones entre los diferentes temas'
            ]);
            
            aiEnhanced = true;
            return enhancedNodes;
        }

        function calculateNodePositions(nodes, type) {
            const width = canvas.width;
            const height = canvas.height;
            
            switch (type) {
                case 'hierarchical':
                    return calculateHierarchicalPositions(nodes, width, height);
                case 'timeline':
                    return calculateTimelinePositions(nodes, width, height);
                case 'flowchart':
                    return calculateFlowchartPositions(nodes, width, height);
                case 'mindmap':
                    return calculateMindmapPositions(nodes, width, height);
                default:
                    return nodes;
            }
        }

        function calculateHierarchicalPositions(nodes, width, height) {
            const levels = new Map();
            
            // Agrupar por nivel
            nodes.forEach(node => {
                if (!levels.has(node.level)) {
                    levels.set(node.level, []);
                }
                levels.get(node.level).push(node);
            });
            
            const maxLevel = Math.max(...Array.from(levels.keys()));
            const levelHeight = height / (maxLevel + 2);
            
            // Posicionar nodos
            levels.forEach((levelNodes, level) => {
                const nodeWidth = width / (levelNodes.length + 1);
                levelNodes.forEach((node, index) => {
                    node.x = nodeWidth * (index + 1);
                    node.y = levelHeight * (level + 1);
                });
            });
            
            return nodes;
        }

        function calculateTimelinePositions(nodes, width, height) {
            const centerY = height / 2;
            const nodeSpacing = width / (nodes.length + 1);
            
            return nodes.map((node, index) => ({
                ...node,
                x: nodeSpacing * (index + 1),
                y: centerY + (index % 2 === 0 ? -50 : 50)
            }));
        }

        function calculateFlowchartPositions(nodes, width, height) {
            const cols = Math.ceil(Math.sqrt(nodes.length));
            const cellWidth = width / cols;
            const cellHeight = height / Math.ceil(nodes.length / cols);
            
            return nodes.map((node, index) => ({
                ...node,
                x: (index % cols) * cellWidth + cellWidth / 2,
                y: Math.floor(index / cols) * cellHeight + cellHeight / 2
            }));
        }

        function calculateMindmapPositions(nodes, width, height) {
            const centerX = width / 2;
            const centerY = height / 2;
            const radius = Math.min(width, height) / 3;
            
            return nodes.map((node, index) => {
                const angle = (2 * Math.PI * index) / nodes.length;
                const nodeRadius = radius * (1 + node.level * 0.3);
                
                return {
                    ...node,
                    x: centerX + Math.cos(angle) * nodeRadius,
                    y: centerY + Math.sin(angle) * nodeRadius
                };
            });
        }

        function drawSchema(nodes) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Configurar estilos
            ctx.font = '14px Inter, sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            // Obtener esquema de colores
            const colors = getColorScheme();
            
            // Dibujar conexiones
            drawConnections(nodes, colors);
            
            // Dibujar nodos
            nodes.forEach(node => {
                drawNode(node, colors);
            });
        }

        function getColorScheme() {
            const scheme = document.getElementById('colorScheme').value;
            const schemes = {
                blue: {
                    primary: '#3b82f6',
                    secondary: '#dbeafe',
                    text: '#1e40af',
                    border: '#60a5fa'
                },
                green: {
                    primary: '#10b981',
                    secondary: '#d1fae5',
                    text: '#047857',
                    border: '#34d399'
                },
                purple: {
                    primary: '#8b5cf6',
                    secondary: '#ede9fe',
                    text: '#6d28d9',
                    border: '#a78bfa'
                },
                orange: {
                    primary: '#f59e0b',
                    secondary: '#fef3c7',
                    text: '#d97706',
                    border: '#fbbf24'
                }
            };
            return schemes[scheme] || schemes.blue;
        }

        function drawConnections(nodes, colors) {
            ctx.strokeStyle = colors.border;
            ctx.lineWidth = 2;
            
            const schemaType = document.getElementById('schemaType').value;
            
            if (schemaType === 'hierarchical') {
                for (let i = 0; i < nodes.length - 1; i++) {
                    const current = nodes[i];
                    const next = nodes[i + 1];
                    
                    if (next.level > current.level) {
                        drawArrow(current.x, current.y, next.x, next.y, colors);
                    }
                }
            } else if (schemaType === 'timeline') {
                for (let i = 0; i < nodes.length - 1; i++) {
                    const current = nodes[i];
                    const next = nodes[i + 1];
                    
                    ctx.beginPath();
                    ctx.moveTo(current.x, current.y);
                    ctx.lineTo(next.x, next.y);
                    ctx.stroke();
                }
            }
        }

        function drawNode(node, colors) {
            const padding = 20;
            const textMetrics = ctx.measureText(node.text);
            const nodeWidth = Math.max(textMetrics.width + padding * 2, 120);
            const nodeHeight = 40;
            
            // Fondo del nodo
            if (aiEnhanced) {
                const gradient = ctx.createLinearGradient(
                    node.x - nodeWidth/2, node.y - nodeHeight/2,
                    node.x + nodeWidth/2, node.y + nodeHeight/2
                );
                gradient.addColorStop(0, colors.primary);
                gradient.addColorStop(1, colors.secondary);
                ctx.fillStyle = gradient;
            } else {
                ctx.fillStyle = colors.secondary;
            }
            
            ctx.fillRect(
                node.x - nodeWidth/2,
                node.y - nodeHeight/2,
                nodeWidth,
                nodeHeight
            );
            
            // Borde del nodo
            ctx.strokeStyle = colors.border;
            ctx.lineWidth = 2;
            ctx.strokeRect(
                node.x - nodeWidth/2,
                node.y - nodeHeight/2,
                nodeWidth,
                nodeHeight
            );
            
            // Texto del nodo
            ctx.fillStyle = colors.text;
            ctx.fillText(node.text, node.x, node.y);
        }

        function drawArrow(fromX, fromY, toX, toY, colors) {
            const headlen = 10;
            const dx = toX - fromX;
            const dy = toY - fromY;
            const angle = Math.atan2(dy, dx);
            
            ctx.strokeStyle = colors.border;
            ctx.beginPath();
            ctx.moveTo(fromX, fromY);
            ctx.lineTo(toX, toY);
            ctx.lineTo(toX - headlen * Math.cos(angle - Math.PI / 6), toY - headlen * Math.sin(angle - Math.PI / 6));
            ctx.moveTo(toX, toY);
            ctx.lineTo(toX - headlen * Math.cos(angle + Math.PI / 6), toY - headlen * Math.sin(angle + Math.PI / 6));
            ctx.stroke();
        }

        function showLoading(show) {
            const loading = document.getElementById('loading');
            if (show) {
                loading.classList.add('show');
            } else {
                loading.classList.remove('show');
            }
        }

        function showAISuggestions(suggestions) {
            const container = document.getElementById('aiSuggestions');
            const list = document.getElementById('suggestionsList');
            
            list.innerHTML = '';
            suggestions.forEach(suggestion => {
                const li = document.createElement('li');
                li.textContent = suggestion;
                list.appendChild(li);
            });
            
            container.classList.add('show');
        }

        function downloadSchema() {
            if (currentNodes.length === 0) {
                alert('Primero genera un esquema antes de descargarlo.');
                return;
            }
            
            const link = document.createElement('a');
            const schemaType = document.getElementById('schemaType').value;
            link.download = `esquema-${schemaType}-${Date.now()}.png`;
            link.href = canvas.toDataURL();
            link.click();
        }

        function clearCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            currentNodes = [];
            aiEnhanced = false;
            document.getElementById('aiSuggestions').classList.remove('show');
        }
    </script>
</body>
</html>