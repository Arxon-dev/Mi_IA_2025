import { prisma } from '@/lib/prisma';
import { GamificationService } from './gamificationService';

// ==========================================
// üéì SERVICIO DE GAMIFICACI√ìN MOODLE
// ==========================================

export interface MoodleVerificationCode {
  code: string;
  telegramUserId: string;
  expiresAt: Date;
  used: boolean;
}

export interface MoodleLinkingResult {
  success: boolean;
  message: string;
  telegramUser?: {
    name: string;
    level: number;
    points: number;
    rank: number;
  };
}

export interface MoodleGamificationUpdate {
  moodleUserId: string;
  questionCorrect: boolean;
  responseTime?: number;
  subject?: string;
  difficulty?: 'easy' | 'medium' | 'hard';
}

export class MoodleGamificationService {

  // ==========================================
  // üîó SISTEMA DE VINCULACI√ìN
  // ==========================================

  /**
   * Generar c√≥digo de verificaci√≥n para vincular cuentas
   */
  static async generateVerificationCode(telegramUserId: string): Promise<{ code: string; expiresAt: Date }> {
    try {
      console.log(`üîó Generando c√≥digo de verificaci√≥n para usuario: ${telegramUserId}`);

      // Verificar que el usuario existe en Telegram
      const telegramUser = await prisma.telegramUser.findUnique({
        where: { telegramUserId }
      });

      if (!telegramUser) {
        throw new Error('Usuario de Telegram no encontrado');
      }

      // Invalidar c√≥digos anteriores del usuario
      await prisma.$executeRaw`
        UPDATE "MoodleVerificationCode" 
        SET "used" = true 
        WHERE "telegramUserId" = ${telegramUserId} AND "used" = false
      `;

      // Generar c√≥digo √∫nico de 6 d√≠gitos
      const code = Math.floor(100000 + Math.random() * 900000).toString();
      const expiresAt = new Date(Date.now() + 15 * 60 * 1000); // 15 minutos
      const id = crypto.randomUUID(); // Generar ID √∫nico

      // Guardar c√≥digo en BD
      await prisma.$executeRaw`
        INSERT INTO "MoodleVerificationCode" ("id", "code", "telegramUserId", "expiresAt", "used")
        VALUES (${id}, ${code}, ${telegramUserId}, ${expiresAt}, false)
      `;

      console.log(`‚úÖ C√≥digo generado: ${code} (expira: ${expiresAt.toISOString()})`);

      return { code, expiresAt };

    } catch (error) {
      console.error('‚ùå Error generando c√≥digo de verificaci√≥n:', error);
      throw error;
    }
  }

  /**
   * Verificar c√≥digo y vincular cuenta Moodle
   */
  static async verifyCodeAndLink(
    verificationCode: string, 
    moodleUserId: string, 
    moodleUserData: {
      username: string;
      email: string;
      fullname: string;
    }
  ): Promise<MoodleLinkingResult> {
    try {
      console.log(`üîç Verificando c√≥digo: ${verificationCode} para Moodle user: ${moodleUserId}`);

      // Buscar c√≥digo v√°lido
      const codeRecord = await prisma.$queryRaw<any[]>`
        SELECT * FROM "MoodleVerificationCode" 
        WHERE "code" = ${verificationCode} 
        AND "used" = false 
        AND "expiresAt" > NOW()
        LIMIT 1
      `;

      if (!codeRecord || codeRecord.length === 0) {
        return {
          success: false,
          message: '‚ùå C√≥digo inv√°lido o expirado'
        };
      }

      const record = codeRecord[0];
      const telegramUserId = record.telegramUserId;

      // Obtener datos del usuario de Telegram
      const telegramUser = await prisma.telegramUser.findUnique({
        where: { telegramUserId }
      });

      if (!telegramUser) {
        return {
          success: false,
          message: '‚ùå Usuario de Telegram no encontrado'
        };
      }

      // Obtener estad√≠sticas actuales de gamificaci√≥n
      const currentStats = await GamificationService.getUserStats(telegramUserId);

      // Verificar si ya existe vinculaci√≥n
      const existingLink = await prisma.$queryRaw<any[]>`
        SELECT * FROM "MoodleUserLink" 
        WHERE "telegramUserId" = ${telegramUserId} OR "moodleUserId" = ${moodleUserId}
        LIMIT 1
      `;

      if (existingLink && existingLink.length > 0) {
        return {
          success: false,
          message: '‚ùå Ya existe una vinculaci√≥n para esta cuenta'
        };
      }

      // Crear vinculaci√≥n
      await prisma.$executeRaw`
        INSERT INTO "MoodleUserLink" (
          "telegramUserId", "moodleUserId", "moodleUsername", 
          "moodleEmail", "moodleFullname", "linkedAt", "isActive"
        )
        VALUES (
          ${telegramUserId}, ${moodleUserId}, ${moodleUserData.username},
          ${moodleUserData.email}, ${moodleUserData.fullname}, NOW(), true
        )
      `;

      // Marcar c√≥digo como usado
      await prisma.$executeRaw`
        UPDATE "MoodleVerificationCode" 
        SET "used" = true 
        WHERE "code" = ${verificationCode}
      `;

      console.log(`‚úÖ Vinculaci√≥n exitosa: Telegram ${telegramUserId} ‚Üî Moodle ${moodleUserId}`);

      return {
        success: true,
        message: `‚úÖ ¬°Cuentas vinculadas exitosamente!`,
        telegramUser: {
          name: telegramUser.firstName || 'Usuario',
          level: currentStats?.level || 1,
          points: currentStats?.totalPoints || 0,
          rank: currentStats?.rank || 999
        }
      };

    } catch (error) {
      console.error('‚ùå Error en verificaci√≥n de c√≥digo:', error);
      return {
        success: false,
        message: '‚ùå Error interno al verificar c√≥digo'
      };
    }
  }

  // ==========================================
  // üéÆ ACTUALIZACI√ìN DE GAMIFICACI√ìN
  // ==========================================

  /**
   * Procesar respuesta de quiz desde Moodle y actualizar gamificaci√≥n
   */
  static async processMoodleQuizResponse(updateData: MoodleGamificationUpdate): Promise<{
    success: boolean;
    message: string;
    gamificationUpdate?: any;
  }> {
    try {
      console.log(`üéì Procesando respuesta de Moodle para usuario: ${updateData.moodleUserId}`);

      // Preparar ambos formatos de b√∫squeda
      const moodleUserIdRaw = updateData.moodleUserId;
      const moodleUserIdPrefixed = moodleUserIdRaw.startsWith('moodle_user_') 
        ? moodleUserIdRaw 
        : `moodle_user_${moodleUserIdRaw}`;

      console.log(`üîç Buscando vinculaci√≥n para: "${moodleUserIdRaw}" o "${moodleUserIdPrefixed}"`);

      // Buscar vinculaci√≥n activa con ambos formatos usando query raw
      const linkRecords = await prisma.$queryRaw<any[]>`
        SELECT * FROM "MoodleUserLink" 
        WHERE ("moodleUserId" = ${moodleUserIdRaw} OR "moodleUserId" = ${moodleUserIdPrefixed})
        AND "isActive" = true
        LIMIT 1
      `;
      
      const linkRecord = linkRecords.length > 0 ? linkRecords[0] : null;

      if (!linkRecord) {
        console.log(`‚ö†Ô∏è No hay vinculaci√≥n activa para Moodle user: ${updateData.moodleUserId}`);
        console.log(`‚ö†Ô∏è Intent√© buscar: "${moodleUserIdRaw}" y "${moodleUserIdPrefixed}"`);
        return {
          success: false,
          message: 'Usuario no vinculado con Telegram'
        };
      }

      console.log(`‚úÖ Vinculaci√≥n encontrada:`, linkRecord);
      const telegramUserId = linkRecord.telegramUserId;

      // Procesar respuesta en el sistema de gamificaci√≥n existente
      const gamificationResult = await GamificationService.processUserResponse({
        telegramUserId,
        username: undefined, // No necesario para Moodle
        firstName: linkRecord.moodleFullname || 'Usuario Moodle',
        lastName: '',
        questionId: `moodle_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`, // ID √∫nico
        telegramMsgId: `moodle_${updateData.moodleUserId}_${Date.now()}`,
        isCorrect: updateData.questionCorrect,
        responseTime: updateData.responseTime || 30 // Default 30 segundos
      });

      // Registrar actividad de Moodle usando query raw
      const activityId = crypto.randomUUID();
      const processedAt = new Date();
      
      await prisma.$executeRaw`
        INSERT INTO "MoodleActivity" (
          "id", "moodleUserId", "telegramUserId", "questionCorrect", 
          "responseTime", "subject", "difficulty", "processedAt"
        ) VALUES (
          ${activityId}, ${updateData.moodleUserId}, ${telegramUserId}, 
          ${updateData.questionCorrect}, ${updateData.responseTime || 30}, 
          ${updateData.subject || 'general'}, ${updateData.difficulty || 'medium'}, 
          ${processedAt}
        )
      `;

      console.log(`‚úÖ Gamificaci√≥n actualizada desde Moodle para usuario: ${telegramUserId}`);
      console.log(`‚úÖ Actividad registrada en MoodleActivity`);

      return {
        success: true,
        message: 'Gamificaci√≥n actualizada desde Moodle',
        gamificationUpdate: gamificationResult
      };

    } catch (error) {
      console.error('‚ùå Error procesando respuesta de Moodle:', error);
      return {
        success: false,
        message: 'Error procesando respuesta de Moodle'
      };
    }
  }

  // ==========================================
  // üìä ESTAD√çSTICAS UNIFICADAS
  // ==========================================

  /**
   * Obtener estad√≠sticas unificadas de Telegram + Moodle
   */
  static async getUnifiedStats(telegramUserId: string): Promise<{
    telegram: any;
    moodle: any;
    unified: any;
  }> {
    try {
      // Estad√≠sticas de Telegram
      const telegramStats = await GamificationService.getUserStats(telegramUserId);

      // Estad√≠sticas de Moodle
      const moodleStats = await prisma.$queryRaw<any[]>`
        SELECT 
          COUNT(*) as "totalQuestions",
          SUM(CASE WHEN "questionCorrect" = true THEN 1 ELSE 0 END) as "correctAnswers",
          AVG("responseTime") as "avgResponseTime",
          COUNT(DISTINCT "subject") as "subjectsStudied"
        FROM "MoodleActivity" 
        WHERE "telegramUserId" = ${telegramUserId}
      `;

      const moodleData = moodleStats[0] || {
        totalQuestions: 0,
        correctAnswers: 0,
        avgResponseTime: 0,
        subjectsStudied: 0
      };

      // Estad√≠sticas unificadas
      const unifiedStats = {
        totalQuestions: (telegramStats?.totalResponses || 0) + Number(moodleData.totalQuestions),
        totalCorrect: (telegramStats?.correctResponses || 0) + Number(moodleData.correctAnswers),
        telegramPoints: telegramStats?.totalPoints || 0,
        level: telegramStats?.level || 1,
        rank: telegramStats?.rank || 999,
        platforms: {
          telegram: {
            questions: telegramStats?.totalResponses || 0,
            correct: telegramStats?.correctResponses || 0,
            accuracy: telegramStats?.accuracy || 0
          },
          moodle: {
            questions: Number(moodleData.totalQuestions),
            correct: Number(moodleData.correctAnswers),
            accuracy: Number(moodleData.totalQuestions) > 0 ? 
              (Number(moodleData.correctAnswers) / Number(moodleData.totalQuestions)) * 100 : 0
          }
        }
      };

      return {
        telegram: telegramStats,
        moodle: moodleData,
        unified: unifiedStats
      };

    } catch (error) {
      console.error('‚ùå Error obteniendo estad√≠sticas unificadas:', error);
      throw error;
    }
  }

  /**
   * Verificar c√≥digo generado en Moodle (flujo inverso)
   */
  static async verifyMoodleCode(
    moodleCode: string, 
    telegramUserId: string, 
    telegramUserData: any
  ): Promise<MoodleLinkingResult> {
    try {
      console.log(`üîç Verificando c√≥digo REAL de Moodle: ${moodleCode} para Telegram user: ${telegramUserId}`);

      // Verificar que el usuario de Telegram existe
      const telegramUser = await prisma.telegramUser.findUnique({
        where: { telegramUserId }
      });

      if (!telegramUser) {
        return {
          success: false,
          message: '‚ùå Usuario de Telegram no encontrado'
        };
      }

      if (moodleCode.length !== 6) {
        return {
          success: false,
          message: '‚ùå C√≥digo debe tener exactamente 6 caracteres'
        };
      }

      // Llamar al endpoint de sincronizaci√≥n REAL con Moodle MySQL
      const baseUrl = process.env.NEXT_PUBLIC_BASE_URL || 'http://localhost:3000';
      const syncResponse = await fetch(`${baseUrl}/api/moodle/sync-verification`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          telegramUserId: telegramUserId,
          code: moodleCode
        })
      });

      const syncResult = await syncResponse.json();

      if (!syncResult.success) {
        console.log(`‚ùå Sincronizaci√≥n fall√≥: ${syncResult.message}`);
        return {
          success: false,
          message: syncResult.message || '‚ùå Error verificando c√≥digo'
        };
      }

      console.log(`‚úÖ Sincronizaci√≥n REAL exitosa:`, syncResult.data);

      // Obtener estad√≠sticas actuales de gamificaci√≥n
      const currentStats = await GamificationService.getUserStats(telegramUserId);

      return {
        success: true,
        message: `‚úÖ ¬°Cuentas vinculadas exitosamente con datos REALES!`,
        telegramUser: {
          name: telegramUser.firstName || 'Usuario',
          level: currentStats?.level || 1,
          points: currentStats?.totalPoints || 0,
          rank: currentStats?.rank || 999
        }
      };

    } catch (error) {
      console.error('‚ùå Error verificando c√≥digo REAL de Moodle:', error);
      return {
        success: false,
        message: '‚ùå Error interno al verificar c√≥digo'
      };
    }
  }

  /**
   * Verificar si un usuario tiene cuenta Moodle vinculada
   */
  static async isUserLinked(telegramUserId: string): Promise<boolean> {
    try {
      const linkRecord = await prisma.$queryRaw<any[]>`
        SELECT 1 FROM "MoodleUserLink" 
        WHERE "telegramUserId" = ${telegramUserId} AND "isActive" = true
        LIMIT 1
      `;

      return linkRecord && linkRecord.length > 0;
    } catch (error) {
      console.error('‚ùå Error verificando vinculaci√≥n:', error);
      return false;
    }
  }

} 