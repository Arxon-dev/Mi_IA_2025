import { NotificationConfig } from '@/config/notifications';
import { prisma } from '@/lib/prisma';
import { NotificationEventType } from '@prisma/client';

interface NotificationResult {
  success: boolean;
  method: 'private' | 'group' | 'failed';
  message?: string;
}

interface User {
  telegramUserId: string;
  username?: string;
  firstName?: string;
}

interface NotificationData {
  userId: string;
  type: NotificationEventType;
  eventData?: any;
  triggerContext?: any;
}

interface TelegramBot {
  sendMessage: (chatId: string, text: string, options?: any) => Promise<any>;
}

export class NotificationService {
  private telegramBot: TelegramBot | null = null;

  /**
   * ğŸ”§ Configurar el bot de Telegram para envÃ­o de notificaciones
   */
  setTelegramBot(bot: TelegramBot) {
    this.telegramBot = bot;
  }

  /**
   * Enviar notificaciÃ³n inteligente (privada primero, fallback despuÃ©s)
   */
  static async sendIntelligentNotification(
    type: 'duel' | 'achievement' | 'goal',
    targetUser: User,
    data: any,
    groupChatId: string
  ): Promise<NotificationResult> {
    
    // 1. Intentar notificaciÃ³n privada primero
    if (NotificationConfig.private[type]) {
      const privateMessage = this.buildPrivateMessage(type, data);
      const privateSuccess = await this.sendPrivateMessage(targetUser.telegramUserId, privateMessage);
      
      if (privateSuccess) {
        console.log(`âœ… NotificaciÃ³n privada enviada a ${targetUser.firstName}`);
        return {
          success: true,
          method: 'private',
          message: 'NotificaciÃ³n enviada privadamente'
        };
      }
    }
    
    // 2. Si falla privada, usar fallback discreto en grupo
    if (NotificationConfig.fallback.enabled && NotificationConfig.groupMode[type]?.fallbackMessage) {
      const fallbackMessage = this.buildFallbackMessage(type, data);
      const groupSuccess = await this.sendGroupMessage(groupChatId, fallbackMessage);
      
      if (groupSuccess) {
        console.log(`ğŸ“¢ Fallback enviado al grupo para ${targetUser.firstName}`);
        return {
          success: true,
          method: 'group',
          message: fallbackMessage
        };
      }
    }
    
    // 3. Si todo falla
    console.log(`âŒ No se pudo notificar a ${targetUser.firstName}`);
    return {
      success: false,
      method: 'failed',
      message: 'No se pudo enviar notificaciÃ³n'
    };
  }
  
  /**
   * Construir mensaje privado detallado
   */
  private static buildPrivateMessage(type: string, data: any): string {
    switch (type) {
      case 'duel':
        const timeLeftMinutes = Math.max(0, Math.ceil((new Date(data.expiresAt).getTime() - Date.now()) / (1000 * 60)));
        
        return `ğŸ—¡ï¸ Â¡TE HAN RETADO A DUELO! âš”ï¸

ğŸ‘¤ <b>${data.challenger.firstName}</b> te ha desafiado
ğŸ“‹ ${data.questionsCount} preguntas | â±ï¸ ${Math.floor(data.timeLimit / 60)} min | ğŸ’° ${data.stake} pts en juego
â° Expira en ${timeLeftMinutes} minutos

âš¡ <b>RESPONDE AHORA:</b>
â€¢ <code>/aceptar ${data.id}</code> - Aceptar desafÃ­o
â€¢ <code>/rechazar ${data.id}</code> - Rechazar duelo

ğŸ¯ <b>MÃS OPCIONES:</b>
â€¢ <code>/duelos</code> - Ver todos tus duelos
â€¢ <code>/mi_stats</code> - Tus estadÃ­sticas
â€¢ <code>/duelo @${data.challenger.firstName}</code> - Retarle despuÃ©s

ğŸ’¡ <b>TIP:</b> Los duelos mejoran tu precisiÃ³n bajo presiÃ³n
âš”ï¸ Â¡La competiciÃ³n directa te hace mejor!

â³ Tienes ${timeLeftMinutes} minutos para decidir`;
        
      case 'achievement':
        return `ğŸ… <b>Â¡LOGRO DESBLOQUEADO!</b> ğŸ…
        
ğŸŠ <b>${data.achievement.name}</b>
ğŸ“ ${data.achievement.description}
ğŸ’ Rareza: ${data.achievement.rarity}
ğŸ Bonus: +${data.achievement.points} puntos

ğŸ”— <code>/logros</code> para ver todos tus logros`;
        
      default:
        return 'NotificaciÃ³n del sistema';
    }
  }
  
  /**
   * Construir mensaje fallback ultra-corto para grupo
   */
  private static buildFallbackMessage(type: string, data: any): string {
    const template = NotificationConfig.fallback.template[type];
    if (!template) return '';
    
    return template
      .replace('{challenger}', data.challenger?.firstName || 'Alguien')
      .replace('{challenged}', data.challenged?.firstName || 'Usuario')
      .replace('{user}', data.user?.firstName || 'Usuario');
  }
  
  /**
   * Enviar mensaje privado
   */
  private static async sendPrivateMessage(telegramUserId: string, message: string): Promise<boolean> {
    try {
      const BOT_TOKEN = process.env.TELEGRAM_BOT_TOKEN || '8039179482:AAG6bugxwgsmWLVHGoWpE5nih_PQpD3KPBs';
      
      const response = await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/sendMessage`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          chat_id: telegramUserId,
          text: message,
          parse_mode: 'HTML'
        })
      });
      
      const result = await response.json() as any;
      return result.ok;
      
    } catch (error) {
      console.error('Error enviando mensaje privado:', error);
      return false;
    }
  }
  
  /**
   * Enviar mensaje a grupo con lÃ­mites anti-spam
   */
  private static async sendGroupMessage(chatId: string, message: string): Promise<boolean> {
    try {
      // TODO: Implementar lÃ­mites anti-spam aquÃ­
      
      const BOT_TOKEN = process.env.TELEGRAM_BOT_TOKEN || '8039179482:AAG6bugxwgsmWLVHGoWpE5nih_PQpD3KPBs';
      
      const response = await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/sendMessage`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          chat_id: chatId,
          text: message,
          parse_mode: 'HTML'
        })
      });
      
      const result = await response.json() as any;
      return result.ok;
      
    } catch (error) {
      console.error('Error enviando mensaje a grupo:', error);
      return false;
    }
  }
  
  /**
   * Verificar si el usuario puede recibir notificaciones privadas
   */
  static async canReceivePrivateMessages(telegramUserId: string): Promise<boolean> {
    try {
      const BOT_TOKEN = process.env.TELEGRAM_BOT_TOKEN || '8039179482:AAG6bugxwgsmWLVHGoWpE5nih_PQpD3KPBs';
      
      // Intentar obtener info del chat privado
      const response = await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/getChat`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          chat_id: telegramUserId
        })
      });
      
      const result = await response.json() as any;
      return result.ok;
      
    } catch (error) {
      return false;
    }
  }

  /**
   * Enviar respuesta inteligente de comando (privada si es necesario)
   */
  static async sendIntelligentCommandResponse(
    originalCommand: string,
    response: string,
    user: { telegramUserId: string; firstName?: string },
    groupChatId: string,
    isGroupChat: boolean
  ): Promise<{ success: boolean; method: string; message: string }> {
    
    const commandBase = originalCommand.toLowerCase().split(' ')[0];
    
    // Verificar si debe ser privado forzoso
    const shouldForcePrivate = NotificationConfig.commands.forcePrivate.includes(commandBase);
    
    // Si no es grupo o no es comando privado forzoso, enviar normalmente
    if (!isGroupChat || !shouldForcePrivate) {
      const success = await this.sendGroupMessage(groupChatId, response);
      return {
        success,
        method: isGroupChat ? 'group' : 'private',
        message: success ? 'Respuesta enviada normalmente' : 'Error enviando respuesta normal'
      };
    }
    
    // Intentar envÃ­o privado para comandos privados forzosos
    try {
      const privateSuccess = await this.sendPrivateMessage(user.telegramUserId, response);
      
      if (privateSuccess) {
        // Enviar confirmaciÃ³n discreta al grupo
        const confirmationMessage = `ğŸ’¬ ${user.firstName || 'Usuario'}, te he enviado la informaciÃ³n por privado`;
        await this.sendGroupMessage(groupChatId, confirmationMessage);
        
        return {
          success: true,
          method: 'private',
          message: 'Respuesta enviada privadamente + confirmaciÃ³n en grupo'
        };
      }
    } catch (error) {
      console.log('âŒ FallÃ³ envÃ­o privado de comando:', error);
    }
    
    // Fallback: Respuesta educativa en grupo
    const educationMessage = `âŒ <b>No pude enviarte "${commandBase}" por privado</b>

ğŸ’¡ <b>SOLUCIÃ“N RÃPIDA:</b>
1. Busca @OpoMelillaBot en Telegram
2. EnvÃ­a <code>/start</code> al bot
3. Vuelve aquÃ­ y usa <code>${commandBase}</code>

ğŸ“¬ AsÃ­ recibirÃ¡s informaciÃ³n detallada sin molestar al grupo`;

    const fallbackSuccess = await this.sendGroupMessage(groupChatId, educationMessage);
    
    return {
      success: fallbackSuccess,
      method: 'education',
      message: fallbackSuccess ? 'Mensaje educativo enviado' : 'Error total'
    };
  }

  /**
   * Enviar respuesta inteligente de quiz (privada + contador en grupo)
   */
  static async sendIntelligentQuizResponse(
    userStats: any,
    isCorrect: boolean,
    questionData: any,
    user: { telegramUserId: string; firstName?: string; username?: string },
    groupChatId: string
  ): Promise<{ success: boolean; method: string; message: string }> {
    
    const config = NotificationConfig.quizResponses;
    const userName = user.firstName || user.username || 'Usuario';
    
    // Preparar datos para los templates
    const templateData = {
      question_result: this.formatQuestionResult(isCorrect, questionData),
      stats: this.formatUserStatsForTemplate(userStats),
      motivation: this.getMotivationalMessage(userStats, isCorrect),
      progress: this.formatProgressForTemplate(userStats),
      name: userName,
      points: this.calculatePointsEarned(userStats, isCorrect)
    };
    
    let privateSuccess = false;
    let groupMessageSent = false;
    
    // Intentar envÃ­o privado si estÃ¡ habilitado
    if (config.privateMode.enabled) {
      try {
        const template = isCorrect ? config.templates.correct.private : config.templates.incorrect.private;
        const privateMessage = this.replaceTemplate(template, templateData);
        
        privateSuccess = await this.sendPrivateMessage(user.telegramUserId, privateMessage);
        console.log(`ğŸ“± Quiz respuesta privada ${userName}:`, privateSuccess ? 'âœ… Ã‰xito' : 'âŒ FallÃ³');
        
      } catch (error) {
        console.log(`âŒ Error enviando quiz privado a ${userName}:`, error);
      }
    }
    
    // Manejar mensaje en grupo
    if (config.groupMode.enabled) {
      // Si estÃ¡ habilitado mostrar respuestas individuales en grupo (no recomendado)
      const template = isCorrect ? config.templates.correct.private : config.templates.incorrect.private;
      const groupMessage = this.replaceTemplate(template, templateData);
      groupMessageSent = await this.sendGroupMessage(groupChatId, groupMessage);
      
    } else if (!privateSuccess && config.groupMode.fallbackMessage) {
      // Fallback: mensaje muy breve en grupo si fallÃ³ privado
      const template = isCorrect ? config.templates.correct.fallback : config.templates.incorrect.fallback;
      const fallbackMessage = this.replaceTemplate(template, templateData);
      
      // Asegurar que no exceda el lÃ­mite de caracteres
      const limitedMessage = fallbackMessage.length > config.groupMode.maxFallbackLength 
        ? fallbackMessage.substring(0, config.groupMode.maxFallbackLength - 3) + '...'
        : fallbackMessage;
        
      groupMessageSent = await this.sendGroupMessage(groupChatId, limitedMessage);
      console.log(`ğŸ“¢ Quiz fallback grupo ${userName}:`, groupMessageSent ? 'âœ… Enviado' : 'âŒ FallÃ³');
      
    } else if (config.groupMode.showAggregate) {
      // Mostrar contador agregado (esto requerirÃ­a lÃ³gica adicional para contar respuestas)
      // Por ahora, no enviamos nada adicional al grupo para mantenerlo limpio
      console.log(`ğŸ“Š Quiz modo agregado: respuesta de ${userName} procesada silenciosamente`);
    }
    
    // Determinar resultado
    if (privateSuccess) {
      return {
        success: true,
        method: 'private',
        message: `Respuesta de quiz enviada privadamente a ${userName}`
      };
    } else if (groupMessageSent) {
      return {
        success: true,
        method: 'group_fallback',
        message: `Respuesta de quiz enviada al grupo como fallback para ${userName}`
      };
    } else {
      return {
        success: false,
        method: 'failed',
        message: `No se pudo enviar respuesta de quiz a ${userName}`
      };
    }
  }

  /**
   * Reemplazar placeholders en templates
   */
  private static replaceTemplate(template: string, data: Record<string, any>): string {
    let result = template;
    
    Object.entries(data).forEach(([key, value]) => {
      const placeholder = `{${key}}`;
      result = result.replace(new RegExp(placeholder, 'g'), String(value || ''));
    });
    
    return result;
  }

  /**
   * Formatear resultado de la pregunta
   */
  private static formatQuestionResult(isCorrect: boolean, questionData: any): string {
    if (isCorrect) {
      return `ğŸ¯ <b>Â¡Respondiste correctamente!</b>\nğŸ’¡ Bien hecho, conoces la respuesta.`;
    } else {
      return `ğŸ¤” <b>Respuesta incorrecta</b>\nğŸ’¡ La respuesta correcta era la opciÃ³n ${questionData.correctAnswerIndex + 1}.`;
    }
  }

  /**
   * Formatear estadÃ­sticas del usuario para template
   */
  private static formatUserStatsForTemplate(stats: any): string {
    const levelEmoji = this.getLevelEmoji(stats.level);
    
    return `ğŸ“Š Puntos: ${stats.totalPoints}
${levelEmoji} Nivel: ${stats.level}
ğŸ”¥ Racha: ${stats.streak} dÃ­as
ğŸ¯ PrecisiÃ³n: ${stats.accuracy}%
ğŸ“ˆ Ranking: #${stats.rank}`;
  }

  /**
   * Formatear progreso hacia siguiente nivel
   */
  private static formatProgressForTemplate(stats: any): string {
    // Esta funciÃ³n requerirÃ­a lÃ³gica del sistema de gamificaciÃ³n
    // Por ahora devuelvo un mensaje genÃ©rico
    return `ğŸ¯ <b>Progreso:</b> Sigue asÃ­ para seguir subiendo de nivel`;
  }

  /**
   * Calcular puntos ganados en esta respuesta
   */
  private static calculatePointsEarned(stats: any, isCorrect: boolean): number {
    // LÃ³gica simplificada - en realidad dependerÃ­a del sistema de puntuaciÃ³n
    return isCorrect ? 15 : 5;
  }

  /**
   * Obtener emoji de nivel
   */
  private static getLevelEmoji(level: number): string {
    if (level <= 2) return 'ğŸ¥‰';
    if (level <= 5) return 'ğŸ¥ˆ';
    if (level <= 10) return 'ğŸ¥‡';
    return 'ğŸ’';
  }

  /**
   * Obtener mensaje motivacional
   */
  private static getMotivationalMessage(stats: any, isCorrect: boolean): string {
    if (isCorrect) {
      const messages = [
        'ğŸ‰ Â¡Excelente trabajo!',
        'ğŸ’ª Â¡Sigue asÃ­!',
        'âš¡ Â¡Imparable!',
        'ğŸŒŸ Â¡Genial!'
      ];
      return messages[Math.floor(Math.random() * messages.length)];
    } else {
      const messages = [
        'ğŸ’ª Â¡No te rindas! La prÃ³xima serÃ¡ mejor',
        'ğŸ“š Â¡Cada error es una oportunidad de aprender!',
        'ğŸ¯ Â¡Sigue intentando!',
        'â­ Â¡La prÃ¡ctica hace al maestro!'
      ];
      return messages[Math.floor(Math.random() * messages.length)];
    }
  }

  // ============================================
  // ğŸ“ DETECTORES DE EVENTOS
  // ============================================

  /**
   * ğŸ“ Detectar primera graduaciÃ³n del dÃ­a
   */
  async checkFirstGraduationToday(userId: string, subject: string): Promise<boolean> {
    try {
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      const tomorrow = new Date(today);
      tomorrow.setDate(tomorrow.getDate() + 1);

      // Verificar si es la primera graduaciÃ³n del dÃ­a
      const todayGraduations = await prisma.notificationEvent.count({
        where: {
          userId,
          type: 'FIRST_GRADUATION_TODAY',
          createdAt: {
            gte: today,
            lt: tomorrow
          }
        }
      });

      if (todayGraduations === 0) {
        await this.createNotificationEvent({
          userId,
          type: 'FIRST_GRADUATION_TODAY',
          eventData: { subject, timestamp: new Date() },
          triggerContext: { graduationSubject: subject }
        });
        return true;
      }

      return false;
    } catch (error) {
      console.error('âŒ Error verificando primera graduaciÃ³n del dÃ­a:', error);
      return false;
    }
  }

  /**
   * ğŸ† Detectar milestone de graduaciones (5, 10, 25, 50, 100)
   */
  async checkGraduationMilestones(userId: string): Promise<NotificationEventType | null> {
    try {
      // Contar graduaciones histÃ³ricas del usuario
      const totalGraduations = await this.getTotalGraduationsCount(userId);
      
      const milestones = [
        { count: 5, type: 'MILESTONE_5_GRADUATIONS' as NotificationEventType },
        { count: 10, type: 'MILESTONE_10_GRADUATIONS' as NotificationEventType },
        { count: 25, type: 'MILESTONE_25_GRADUATIONS' as NotificationEventType },
        { count: 50, type: 'MILESTONE_50_GRADUATIONS' as NotificationEventType },
        { count: 100, type: 'MILESTONE_100_GRADUATIONS' as NotificationEventType }
      ];

      for (const milestone of milestones) {
        if (totalGraduations === milestone.count) {
          // Verificar que no se haya enviado ya este milestone
          const existingNotification = await prisma.notificationEvent.findFirst({
            where: {
              userId,
              type: milestone.type,
              sent: true
            }
          });

          if (!existingNotification) {
            await this.createNotificationEvent({
              userId,
              type: milestone.type,
              eventData: { totalGraduations, milestone: milestone.count },
              triggerContext: { achievementLevel: milestone.count }
            });
            return milestone.type;
          }
        }
      }

      return null;
    } catch (error) {
      console.error('âŒ Error verificando milestones de graduaciÃ³n:', error);
      return null;
    }
  }

  /**
   * â° Verificar usuarios inactivos para recordatorios
   */
  async checkInactiveUsers(): Promise<string[]> {
    try {
      const threeDaysAgo = new Date();
      threeDaysAgo.setDate(threeDaysAgo.getDate() - 3);

      // Buscar usuarios sin actividad en estudio de falladas en los Ãºltimos 3 dÃ­as
      const inactiveUsers = await prisma.telegramUser.findMany({
        where: {
          lastActivity: {
            lt: threeDaysAgo
          },
          // Solo usuarios que tienen preguntas falladas para estudiar
          studyStats: {
            some: {
              incorrectAnswers: {
                gt: 0
              }
            }
          }
        },
        include: {
          notificationSettings: true
        }
      });

      const usersToNotify: string[] = [];

      for (const user of inactiveUsers) {
        // Verificar configuraciones de notificaciones
        if (user.notificationSettings?.reminderNotifications === false) {
          continue;
        }

        // Verificar si ya se enviÃ³ recordatorio reciente
        const lastReminder = user.notificationSettings?.lastReminderNotification;
        if (lastReminder) {
          const daysSinceLastReminder = (Date.now() - lastReminder.getTime()) / (1000 * 60 * 60 * 24);
          if (daysSinceLastReminder < (user.notificationSettings?.reminderDaysThreshold || 3)) {
            continue;
          }
        }

        await this.createNotificationEvent({
          userId: user.id,
          type: 'INACTIVITY_REMINDER',
          eventData: { daysSinceLastActivity: Math.floor((Date.now() - user.lastActivity.getTime()) / (1000 * 60 * 60 * 24)) },
          triggerContext: { lastActivity: user.lastActivity }
        });

        usersToNotify.push(user.id);
      }

      return usersToNotify;
    } catch (error) {
      console.error('âŒ Error verificando usuarios inactivos:', error);
      return [];
    }
  }

  /**
   * ğŸ“Š Generar reportes semanales pendientes
   */
  async checkWeeklyReports(): Promise<string[]> {
    try {
      const oneWeekAgo = new Date();
      oneWeekAgo.setDate(oneWeekAgo.getDate() - 7);

      const users = await prisma.telegramUser.findMany({
        where: {
          // Usuarios activos con estadÃ­sticas
          studyStats: {
            some: {
              totalQuestions: {
                gt: 0
              }
            }
          }
        },
        include: {
          notificationSettings: true
        }
      });

      const usersToNotify: string[] = [];

      for (const user of users) {
        // Verificar configuraciones
        if (user.notificationSettings?.weeklyReportNotifications === false) {
          continue;
        }

        // Verificar si es tiempo de enviar reporte semanal
        const lastReport = user.notificationSettings?.lastWeeklyReport;
        if (lastReport) {
          const daysSinceLastReport = (Date.now() - lastReport.getTime()) / (1000 * 60 * 60 * 24);
          if (daysSinceLastReport < 7) {
            continue;
          }
        }

        await this.createNotificationEvent({
          userId: user.id,
          type: 'WEEKLY_PROGRESS_REPORT',
          eventData: { weekStart: oneWeekAgo, weekEnd: new Date() },
          triggerContext: { reportType: 'weekly' }
        });

        usersToNotify.push(user.id);
      }

      return usersToNotify;
    } catch (error) {
      console.error('âŒ Error generando reportes semanales:', error);
      return [];
    }
  }

  // ============================================
  // ğŸ“§ TEMPLATES DE MENSAJES
  // ============================================

  /**
   * ğŸ“ Generar mensaje de notificaciÃ³n segÃºn el tipo
   */
  private generateNotificationMessage(type: NotificationEventType, eventData: any, userName: string): string {
    switch (type) {
      case 'FIRST_GRADUATION_TODAY':
        return `ğŸ“ <b>Â¡Primera graduaciÃ³n del dÃ­a!</b>

Â¡Felicidades ${userName}! ğŸ‰

Has graduado tu primera pregunta de <b>${eventData.subject}</b> hoy. Â¡Un excelente comienzo!

ğŸ¯ <b>MANTÃ‰N EL IMPULSO:</b>
â€¢ <code>/falladas10</code> - 10 preguntas falladas mÃ¡s
â€¢ <code>/${eventData.subject}10</code> - Estudiar mÃ¡s de ${eventData.subject}
â€¢ <code>/miprogreso</code> - Ver tu evoluciÃ³n

ğŸ† <b>COMPITE Y MEJORA:</b>
â€¢ <code>/duelo</code> - Reto a otro usuario
â€¢ <code>/ranking</code> - Ve tu posiciÃ³n actual

ğŸ”¥ <i>Â¡La primera graduaciÃ³n del dÃ­a es el mejor arranque!</i>`;

      case 'MILESTONE_5_GRADUATIONS':
        return `ğŸ† <b>Â¡5 Graduaciones Alcanzadas!</b>

Â¡IncreÃ­ble ${userName}! ğŸš€

Has graduado <b>5 preguntas</b> con Ã©xito. Tu constancia estÃ¡ dando frutos.

ğŸ“ˆ <b>ACELERA HACIA LAS 10:</b>
â€¢ <code>/falladas20</code> - SesiÃ³n intensiva de 20
â€¢ <code>/estadisticas</code> - Ve tus materias mÃ¡s dÃ©biles
â€¢ <code>/simulacro</code> - Pon a prueba tus conocimientos

ğŸ¯ <b>COMPARTE TU PROGRESO:</b>
â€¢ <code>/logros</code> - Ve todos tus achievements
â€¢ <code>/ranking</code> - Compara tu posiciÃ³n

ğŸ’¡ <i>Â¡Solo necesitas 5 graduaciones mÃ¡s para el siguiente milestone!</i>`;

      case 'MILESTONE_10_GRADUATIONS':
        return `ğŸŒŸ <b>Â¡10 Graduaciones Completadas!</b>

Â¡Excelente trabajo ${userName}! ğŸ’ª

Has alcanzado las <b>10 graduaciones</b>. Tu disciplina es admirable.

ğŸš€ <b>RUMBO A LAS 25:</b>
â€¢ <code>/falladas30</code> - SesiÃ³n premium de 30
â€¢ <code>/torneo</code> - Ãšnete al torneo activo
â€¢ <code>/simulacro_oficial</code> - Examen completo

ğŸ“Š <b>ANALIZA TU PROGRESO:</b>
â€¢ <code>/estadisticas</code> - PrecisiÃ³n por materia
â€¢ <code>/graduadas</code> - Lista de preguntas dominadas
â€¢ <code>/duelo</code> - Demuestra tu nivel

ğŸ”¥ <i>Â¡Vas construyendo una base de conocimiento excepcional!</i>`;

      case 'MILESTONE_25_GRADUATIONS':
        return `ğŸ’ <b>Â¡25 Graduaciones Dominadas!</b>

Â¡Impresionante ${userName}! ğŸ†

Has graduado <b>25 preguntas</b>. Eres un verdadero dedicado al estudio.

â­ <b>Status alcanzado:</b>
â€¢ Estudiante Comprometido ğŸ–ï¸
â€¢ Conocimiento sÃ³lido construido ğŸ“š

ğŸš€ <i>Â¡Siguiente parada: 50 graduaciones!</i>`;

      case 'MILESTONE_50_GRADUATIONS':
        return `ğŸ‘‘ <b>Â¡50 Graduaciones Magistrales!</b>

Â¡Excepcional ${userName}! ğŸŒŸ

Has graduado <b>50 preguntas</b>. Tu nivel de preparaciÃ³n es extraordinario.

ğŸ… <b>Logro desbloqueado:</b>
â€¢ <b>Maestro del Estudio</b> ğŸ“
â€¢ Conocimiento avanzado adquirido ğŸ“–

ğŸ’« <i>Â¡El centenar estÃ¡ al alcance!</i>`;

      case 'MILESTONE_100_GRADUATIONS':
        return `ğŸ† <b>Â¡100 GRADUACIONES Ã‰PICAS!</b>

Â¡LEYENDA ${userName}! ğŸ‘‘â­

Has conquistado <b>100 graduaciones</b>. Eres un ejemplo de dedicaciÃ³n y excelencia.

ğŸŒŸ <b>TÃ­tulo Ã‰pico Otorgado:</b>
â€¢ <b>ğŸ† LEYENDA DEL ESTUDIO ğŸ†</b>
â€¢ Dominio absoluto demostrado ğŸ“šâœ¨

ğŸ‘‘ <b>COMPARTE TU MAESTRÃA:</b>
â€¢ <code>/ranking</code> - Ve tu posiciÃ³n de leyenda
â€¢ <code>/duelo</code> - Demuestra tu dominio
â€¢ <code>/torneo</code> - Lidera la competiciÃ³n
â€¢ <code>/logros</code> - Celebra todos tus achievements

ğŸ‰ <i>Â¡Has alcanzado el pinÃ¡culo del estudio sistemÃ¡tico!</i>`;

      case 'INACTIVITY_REMINDER':
        const days = eventData.daysSinceLastActivity || 3;
        return `â° <b>Â¡Te echamos de menos!</b>

Hola ${userName} ğŸ‘‹

Han pasado <b>${days} dÃ­as</b> desde tu Ãºltima sesiÃ³n de estudio.

ğŸ¯ <b>Tienes preguntas esperÃ¡ndote:</b>
â€¢ Usa <code>/falladas</code> para practicar
â€¢ Revisa tu progreso con <code>/miprogreso</code>

ğŸ’¡ <i>Solo 10 minutos al dÃ­a pueden marcar la diferencia.</i>

ğŸ”¥ <b>Â¡No pierdas el impulso que has construido!</b>`;

      case 'WEEKLY_PROGRESS_REPORT':
        return `ğŸ“Š <b>Reporte Semanal de Progreso</b>

Â¡Hola ${userName}! ğŸ“ˆ

AquÃ­ tienes tu resumen de la semana:

ğŸ¯ <b>Para ver tu reporte detallado:</b>
â€¢ <code>/estadisticas</code> - PrecisiÃ³n por materia
â€¢ <code>/miprogreso</code> - Graduaciones alcanzadas
â€¢ <code>/graduadas</code> - Lista de preguntas dominadas

ğŸ’ª <i>Cada semana es una oportunidad para mejorar.</i>

ğŸš€ <b>Â¡Sigamos construyendo tu Ã©xito!</b>`;

      default:
        return `ğŸ”” <b>NotificaciÃ³n del Sistema</b>

Â¡Hola ${userName}!

Tienes una nueva notificaciÃ³n del sistema de estudio.

ğŸ“š Revisa tu progreso con <code>/miprogreso</code>`;
    }
  }

  // ============================================
  // ğŸš€ GESTIÃ“N DE EVENTOS
  // ============================================

  /**
   * ğŸ“ Crear evento de notificaciÃ³n
   */
  private async createNotificationEvent(data: NotificationData): Promise<string> {
    try {
      const event = await prisma.notificationEvent.create({
        data: {
          userId: data.userId,
          type: data.type,
          eventData: data.eventData || {},
          triggerContext: data.triggerContext || {},
          scheduledFor: new Date() // Enviar inmediatamente
        }
      });

      console.log(`ğŸ“§ Evento de notificaciÃ³n creado: ${data.type} para usuario ${data.userId}`);
      return event.id;
    } catch (error) {
      console.error('âŒ Error creando evento de notificaciÃ³n:', error);
      throw error;
    }
  }

  /**
   * ğŸ“¤ Procesar y enviar notificaciones pendientes
   */
  async processScheduledNotifications(): Promise<number> {
    try {
      // Obtener notificaciones programadas que no se han enviado
      const pendingNotifications = await prisma.notificationEvent.findMany({
        where: {
          sent: false,
          scheduledFor: {
            lte: new Date()
          }
        },
        include: {
          user: {
            include: {
              notificationSettings: true
            }
          }
        },
        orderBy: {
          scheduledFor: 'asc'
        },
        take: 50 // Procesar en lotes
      });

      let sentCount = 0;

      for (const notification of pendingNotifications) {
        try {
          const sent = await this.sendNotificationToUser(notification);
          if (sent) {
            sentCount++;
          }
        } catch (error) {
          console.error(`âŒ Error enviando notificaciÃ³n ${notification.id}:`, error);
          
          // Marcar como fallida y aumentar contador de reintentos
          await prisma.notificationEvent.update({
            where: { id: notification.id },
            data: {
              retryCount: notification.retryCount + 1,
              errorMessage: error instanceof Error ? error.message : 'Error desconocido',
              success: false
            }
          });
        }
      }

      console.log(`ğŸ“§ Procesadas ${pendingNotifications.length} notificaciones, enviadas ${sentCount}`);
      return sentCount;
    } catch (error) {
      console.error('âŒ Error procesando notificaciones:', error);
      return 0;
    }
  }

  /**
   * ğŸ“¤ Enviar notificaciÃ³n individual a un usuario
   */
  private async sendNotificationToUser(notification: any): Promise<boolean> {
    try {
      // Verificar configuraciones del usuario
      const settings = notification.user.notificationSettings;
      if (!this.shouldSendNotification(notification.type, settings)) {
        console.log(`ğŸ”‡ NotificaciÃ³n ${notification.type} omitida por configuraciÃ³n del usuario`);
        await this.markNotificationAsSent(notification.id, false, 'Omitida por configuraciÃ³n');
        return false;
      }

      // Verificar horario permitido
      const currentHour = new Date().getHours();
      const startHour = settings?.notificationStartHour || 8;
      const endHour = settings?.notificationEndHour || 22;
      
      if (currentHour < startHour || currentHour >= endHour) {
        console.log(`â° NotificaciÃ³n ${notification.type} pospuesta (fuera de horario)`);
        // Reprogramar para el prÃ³ximo perÃ­odo vÃ¡lido
        const tomorrow = new Date();
        tomorrow.setDate(tomorrow.getDate() + 1);
        tomorrow.setHours(startHour, 0, 0, 0);
        
        await prisma.notificationEvent.update({
          where: { id: notification.id },
          data: { scheduledFor: tomorrow }
        });
        return false;
      }

      // Generar mensaje
      const userName = notification.user.firstName || notification.user.username || 'Usuario';
      const message = this.generateNotificationMessage(
        notification.type,
        notification.eventData,
        userName
      );

      // Enviar mensaje por Telegram
      let telegramMsgId: string | null = null;
      if (this.telegramBot) {
        const result = await this.telegramBot.sendMessage(
          notification.user.telegramUserId,
          message,
          { parse_mode: 'HTML' }
        );
        telegramMsgId = result.message_id?.toString();
      }

      // Marcar como enviada
      await this.markNotificationAsSent(notification.id, true, null, message, telegramMsgId);
      
      // Actualizar configuraciones de Ãºltimo envÃ­o
      await this.updateLastNotificationTime(notification.user.id, notification.type);

      console.log(`âœ… NotificaciÃ³n ${notification.type} enviada a ${userName}`);
      return true;

    } catch (error) {
      console.error(`âŒ Error enviando notificaciÃ³n individual:`, error);
      return false;
    }
  }

  /**
   * âœ… Marcar notificaciÃ³n como enviada
   */
  private async markNotificationAsSent(
    notificationId: string, 
    success: boolean, 
    errorMessage?: string | null,
    messageContent?: string,
    telegramMsgId?: string | null
  ): Promise<void> {
    await prisma.notificationEvent.update({
      where: { id: notificationId },
      data: {
        sent: true,
        sentAt: new Date(),
        success,
        errorMessage,
        messageContent,
        telegramMsgId
      }
    });
  }

  /**
   * ğŸ” Verificar si se debe enviar la notificaciÃ³n segÃºn configuraciones
   */
  private shouldSendNotification(type: NotificationEventType, settings: any): boolean {
    if (!settings) return true; // Si no hay configuraciones, enviar por defecto

    switch (type) {
      case 'FIRST_GRADUATION_TODAY':
        return settings.graduationNotifications !== false;
      case 'MILESTONE_5_GRADUATIONS':
      case 'MILESTONE_10_GRADUATIONS':
      case 'MILESTONE_25_GRADUATIONS':
      case 'MILESTONE_50_GRADUATIONS':
      case 'MILESTONE_100_GRADUATIONS':
        return settings.milestoneNotifications !== false;
      case 'INACTIVITY_REMINDER':
        return settings.reminderNotifications !== false;
      case 'WEEKLY_PROGRESS_REPORT':
        return settings.weeklyReportNotifications !== false;
      default:
        return true;
    }
  }

  /**
   * ğŸ“… Actualizar tiempo de Ãºltima notificaciÃ³n en configuraciones
   */
  private async updateLastNotificationTime(userId: string, type: NotificationEventType): Promise<void> {
    const updateData: any = {};
    const now = new Date();

    switch (type) {
      case 'FIRST_GRADUATION_TODAY':
        updateData.lastGraduationNotification = now;
        break;
      case 'INACTIVITY_REMINDER':
        updateData.lastReminderNotification = now;
        break;
      case 'WEEKLY_PROGRESS_REPORT':
        updateData.lastWeeklyReport = now;
        break;
    }

    if (Object.keys(updateData).length > 0) {
      await prisma.userNotificationSettings.upsert({
        where: { userId },
        create: {
          userId,
          ...updateData
        },
        update: updateData
      });
    }
  }

  // ============================================
  // ğŸ“Š UTILIDADES
  // ============================================

  /**
   * ğŸ“Š Obtener total de graduaciones de un usuario
   */
  private async getTotalGraduationsCount(userId: string): Promise<number> {
    try {
      // Contar preguntas graduadas (1+ aciertos desde Ãºltimo fallo)
      const result = await prisma.$queryRaw`
        SELECT COUNT(DISTINCT fq."questionId") as count
        FROM (
          SELECT 
            sr."questionId",
            sr.subject,
            COALESCE(
              (SELECT COUNT(*) 
               FROM "StudyResponse" sr2 
               WHERE sr2."userId" = sr."userId" 
                 AND sr2."questionId" = sr."questionId" 
                 AND sr2.subject = sr.subject
                 AND sr2."isCorrect" = true 
                 AND sr2."answeredAt" > COALESCE(
                   (SELECT MAX(sr3."answeredAt") 
                    FROM "StudyResponse" sr3 
                    WHERE sr3."userId" = sr."userId" 
                      AND sr3."questionId" = sr."questionId" 
                      AND sr3.subject = sr.subject
                      AND sr3."isCorrect" = false), 
                   '1970-01-01'::timestamp)
              ), 0) as total_successes_since_last_fail
          FROM "StudyResponse" sr
          WHERE sr."userId" = ${userId}
            AND sr."isCorrect" = false
          GROUP BY sr."questionId", sr.subject, sr."userId"
        ) fq
        WHERE fq.total_successes_since_last_fail >= 1
      `;

      return Number((result as any[])[0]?.count || 0);
    } catch (error) {
      console.error('âŒ Error contando graduaciones totales:', error);
      return 0;
    }
  }

  /**
   * ğŸ”§ Obtener configuraciones de notificaciÃ³n de un usuario
   */
  async getUserNotificationSettings(userId: string) {
    return await prisma.userNotificationSettings.findUnique({
      where: { userId }
    });
  }

  /**
   * âš™ï¸ Actualizar configuraciones de notificaciÃ³n
   */
  async updateUserNotificationSettings(userId: string, settings: any) {
    return await prisma.userNotificationSettings.upsert({
      where: { userId },
      create: {
        userId,
        ...settings
      },
      update: settings
    });
  }

  // ============================================
  // ğŸ¯ MÃ‰TODOS PÃšBLICOS PARA INTEGRACIÃ“N
  // ============================================

  /**
   * ğŸ“ Llamar cuando una pregunta se gradÃºa
   */
  async onQuestionGraduated(userId: string, subject: string): Promise<void> {
    await this.checkFirstGraduationToday(userId, subject);
    await this.checkGraduationMilestones(userId);
  }

  /**
   * â° Ejecutar verificaciones programadas (cron job)
   */
  async runScheduledChecks(): Promise<void> {
    console.log('ğŸ” Ejecutando verificaciones programadas de notificaciones...');
    
    await this.checkInactiveUsers();
    await this.checkWeeklyReports();
    await this.processScheduledNotifications();
    
    console.log('âœ… Verificaciones programadas completadas');
  }
}

export const notificationService = new NotificationService();
export default notificationService; 