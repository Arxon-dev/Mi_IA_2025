import { StorageService, StoredDocument } from './storageService';
import { Section } from '@prisma/client';

/**
 * Tipos de secciones que puede tener un documento
 */
export enum SectionType {
  SECTION = 'Section',
  PARAGRAPH = 'Paragraph',
  GENERIC = 'Generic',
  CHAPTER = 'Chapter',
  ARTICLE = 'Article',
  MAIN_SECTION = 'MainSection'  // Nuevo tipo para secciones principales
}

/**
 * Interfaz para representar una secci√≥n de documento
 */
export interface DocumentSection {
  id: string;
  documentId: string;
  title: string;
  content: string;
  type: SectionType;
  order: number;
  processed: boolean;
  createdAt: Date;
  updatedAt: Date;
}

/**
 * Informaci√≥n sobre el progreso de procesamiento de un documento
 */
export interface DocumentProgress {
  processedSections: string[];
  totalSections: number;
}

/**
 * Modos de procesamiento de secciones disponibles
 */
export enum ProcessingMode {
  NUMBERED = 'NUMBERED',
  HIERARCHICAL = 'HIERARCHICAL',
  PARAGRAPHS = 'paragraphs',    // Por p√°rrafos
  CUSTOM = 'CUSTOM',
  GENERIC = 'GENERIC',
  FULL = 'FULL', // Nuevo modo para mostrar el documento completo
  MILITARY_DOCTRINE = 'MILITARY_DOCTRINE', // Nuevo modo para documentos de doctrina militar
  PDC_01_DOCTRINE = 'PDC_01_DOCTRINE' // Modo espec√≠fico para PDC-01 B Doctrina para el empleo de las FAS
}

/**
 * Configuraci√≥n para el procesamiento de secciones
 */
export interface ProcessingConfig {
  mode: ProcessingMode;
  options: {
    // Opciones comunes
    minSectionLength?: number;
    maxSectionLength?: number;
    
    // Opciones espec√≠ficas por modo
    numbered?: {
      pattern?: string;      // Patr√≥n de n√∫meros personalizado
      includeSubsections?: boolean;
    };
    hierarchical?: {
      levels?: string[];     // Nombres de los niveles jer√°rquicos
      maxDepth?: number;     // Profundidad m√°xima de la jerarqu√≠a
    };
    paragraphs?: {
      maxParagraphsPerSection?: number;
      joinShortParagraphs?: boolean;
    };
    custom?: {
      patterns?: string[];   // Patrones personalizados
      caseSensitive?: boolean;
    };
    generic?: {
      maxParagraphsPerSection?: number;
    };
    militaryDoctrine?: {
      detectChapters?: boolean;        // Detectar CAP√çTULO X
      detectMainSections?: boolean;    // Detectar secciones numeradas (1., 2., 3.)
      detectSubSections?: boolean;     // Detectar subsecciones (3.1., 3.2.)
      groupParagraphs?: boolean;       // Agrupar p√°rrafos numerados
      paragraphsPerGroup?: number;     // P√°rrafos por grupo
    };
    pdc01Doctrine?: {
      useSpecificSections?: boolean;   // Usar apartados espec√≠ficos predefinidos
      includeSubParagraphs?: boolean;  // Incluir p√°rrafos numerados dentro de cada apartado
      minSectionLength?: number;       // Longitud m√≠nima por apartado
    };
  };
}

/**
 * Niveles de logging
 */
enum LogLevel {
  DEBUG = 'DEBUG',
  INFO = 'INFO',
  WARN = 'WARN',
  ERROR = 'ERROR'
}

/**
 * Clase para el servicio de documentos
 */
export class DocumentSectionService {
  private static SECTION_PROGRESS_KEY = 'document_section_progress';
  private static SECTION_QUESTIONS_KEY = 'document_section_questions';
  private static DOCUMENT_SECTIONS_KEY = 'document_sections';
  private static DOCUMENT_PROGRESS_KEY = 'document-progress';
  private static PROCESSING_CONFIG_KEY = 'document_processing_config';

  // Configuraci√≥n por defecto
  private static DEFAULT_CONFIG: ProcessingConfig = {
    mode: ProcessingMode.HIERARCHICAL,
    options: {
      minSectionLength: 100,
      maxSectionLength: 5000,
      hierarchical: {
        levels: ['Art√≠culo', 'ART√çCULO', 'Art.', 'ART.'],
        maxDepth: 1
      }
    }
  };

  // Configuraci√≥n espec√≠fica para documentos militares
  private static MILITARY_DOCTRINE_CONFIG: ProcessingConfig = {
    mode: ProcessingMode.MILITARY_DOCTRINE,
    options: {
      minSectionLength: 200,
      maxSectionLength: 10000,
      militaryDoctrine: {
        detectChapters: true,
        detectMainSections: true,
        detectSubSections: true,
        groupParagraphs: true,
        paragraphsPerGroup: 8
      }
    }
  };

  // Configuraci√≥n espec√≠fica para PDC-01 B Doctrina para el empleo de las FAS
  private static PDC_01_CONFIG: ProcessingConfig = {
    mode: ProcessingMode.PDC_01_DOCTRINE,
    options: {
      minSectionLength: 500,
      maxSectionLength: 15000,
      pdc01Doctrine: {
        useSpecificSections: true,
        includeSubParagraphs: true,
        minSectionLength: 500
      }
    }
  };

  /**
   * Sistema de logging mejorado
   */
  private static log(level: LogLevel, message: string, data?: any) {
    const timestamp = new Date().toISOString();
    const logMessage = `[${timestamp}] [${level}] ${message}`;
    
    switch (level) {
      case LogLevel.DEBUG:
        console.debug(logMessage, data);
        break;
      case LogLevel.INFO:
        console.log(logMessage, data);
        break;
      case LogLevel.WARN:
        console.warn(logMessage, data);
        break;
      case LogLevel.ERROR:
        console.error(logMessage, data);
        break;
    }
  }

  /**
   * Medici√≥n de rendimiento
   */
  private static measurePerformance<T>(operation: string, func: () => T): T;
  private static async measurePerformance<T>(operation: string, func: () => Promise<T>): Promise<T>;
  private static measurePerformance<T>(operation: string, func: () => T | Promise<T>): T | Promise<T> {
    const startTime = performance.now();
    const result = func();
    
    if (result instanceof Promise) {
      return result.then((resolvedResult) => {
        const endTime = performance.now();
        const duration = endTime - startTime;
        this.log(LogLevel.DEBUG, `Rendimiento de ${operation}: ${duration.toFixed(2)}ms`);
        return resolvedResult;
      });
    } else {
      const endTime = performance.now();
      const duration = endTime - startTime;
      this.log(LogLevel.DEBUG, `Rendimiento de ${operation}: ${duration.toFixed(2)}ms`);
      return result;
    }
  }

  /**
   * Actualiza un documento y procesa sus secciones
   */
  static async updateDocument(document: StoredDocument): Promise<StoredDocument> {
    if (!document || !document.id) {
      throw new Error('Documento inv√°lido: falta ID');
    }

    if (!document.content || document.content.trim() === '') {
      throw new Error('Documento inv√°lido: contenido vac√≠o');
    }

    try {
      this.log(LogLevel.INFO, 'Iniciando procesamiento del documento', { id: document.id });
      
      // Asegurar que el documento tiene todos los campos requeridos
      if (!document.type) {
        document.type = 'text/plain'; // Valor por defecto si no est√° definido
        this.log(LogLevel.WARN, 'Campo type no definido, usando valor por defecto', { documentId: document.id });
      }
      if (!document.date) {
        document.date = new Date();
        this.log(LogLevel.WARN, 'Campo date no definido, usando fecha actual', { documentId: document.id });
      }
      
      // Guardar el documento primero
      await this.saveDocument(document);
      
      return await this.measurePerformance('procesamiento_documento', async () => {
        // üîç DEBUGGING: Detectar tipo de documento
        const isPDC01 = this.detectPDC01Document(document.content);
        const isMilitary = this.detectMilitaryDoctrine(document.content);
        const currentConfig = this.getProcessingConfig(document.id);
        
        console.log('üîç [DEBUG] Detecci√≥n autom√°tica:', {
          documentId: document.id,
          title: document.title,
          isPDC01,
          isMilitary,
          currentConfigMode: currentConfig.mode,
          contentPreview: document.content.substring(0, 300) + '...'
        });
        
        // ‚úÖ APLICAR DETECCI√ìN AUTOM√ÅTICA SOLO SI NO HAY CONFIGURACI√ìN PERSONALIZADA GUARDADA
        // Verificar si existe una configuraci√≥n espec√≠fica guardada por el usuario
        const configKey = `${this.PROCESSING_CONFIG_KEY}_${document.id}`;
        const hasUserConfig = localStorage.getItem(configKey) !== null;
        
        if (!hasUserConfig && (isPDC01 || isMilitary)) {
          this.log(LogLevel.INFO, 'Aplicando configuraci√≥n autom√°tica durante la carga del documento (configuraci√≥n por defecto detectada)');
          console.log('üîç [DEBUG] Aplicando configuraci√≥n autom√°tica:', { isPDC01, isMilitary, hasUserConfig });
          
          if (isPDC01) {
            this.setupPDC01Processing(document.id);
          } else if (isMilitary) {
            this.setupMilitaryDoctrineProcessing(document.id);
          }
          
          // Recargar la configuraci√≥n despu√©s de aplicar la detecci√≥n autom√°tica
          const updatedConfig = this.getProcessingConfig(document.id);
          console.log('üîç [DEBUG] Configuraci√≥n actualizada:', { mode: updatedConfig.mode });
        } else {
          console.log('üîç [DEBUG] Respetando configuraci√≥n del usuario:', { 
            mode: currentConfig.mode,
            hierarchicalLevels: currentConfig.options.hierarchical?.levels,
            hasUserConfig,
            isPDC01,
            isMilitary
          });
        }
        
        // Extraer secciones del documento
        const sections = this.extractSections(document);
        this.log(LogLevel.INFO, 'Secciones extra√≠das', { count: sections.length });
        
        // üîç DEBUGGING: Resultado de extracci√≥n
        console.log('üîç [DEBUG] Secciones extra√≠das:', {
          count: sections.length,
          sectionTitles: sections.map(s => s.title).slice(0, 5),
          configUsed: currentConfig.mode,
          sectionTypes: sections.map(s => s.type).slice(0, 5)
        });

        // Guardar secciones en la base de datos (batch) - AHORA ESPERAMOS LA RESPUESTA
        try {
          const response = await fetch('/api/sections', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(sections),
          });
          
          if (!response.ok) {
            throw new Error('Error al guardar secciones en la base de datos');
          }
          
          const data = await response.json();
          this.log(LogLevel.INFO, 'Secciones guardadas en la base de datos', { count: sections.length });
        } catch (error) {
          this.log(LogLevel.ERROR, 'Error al guardar secciones en la base de datos', { error });
          throw error; // Re-lanzar el error para que se maneje arriba
        }

        // (Opcional) Guardar en localStorage como cach√©
        // const cacheKey = `document_cache_${document.id}`;
        // const cacheData = {
        //   ...document,
        //   sections: sections.map(section => ({
        //     ...section,
        //     type: section.type as SectionType
        //   })),
        //   lastProcessed: new Date().toISOString()
        // };
        // try {
        //   localStorage.setItem(cacheKey, JSON.stringify(cacheData));
        // } catch (cacheError) {
        //   this.log(LogLevel.WARN, 'Error al cachear documento', { error: cacheError });
        // }

        this.log(LogLevel.INFO, 'Documento actualizado', { 
          id: document.id, 
          sectionCount: sections.length 
        });
        
        return {
          ...document,
          sections: sections as any, // Incluir las secciones en el documento retornado
          updatedAt: new Date()
        };
      });
    } catch (error: unknown) {
      const errorMessage = error instanceof Error ? error.message : 'Error desconocido';
      this.log(LogLevel.ERROR, 'Error al procesar el documento', { 
        id: document.id, 
        error: errorMessage 
      });
      throw new Error(`Error al procesar el documento: ${errorMessage}`);
    }
  }

  /**
   * Obtiene las secciones de un documento
   */
  static async getSections(documentId: string): Promise<DocumentSection[]> {
    try {
      // Obtener el documento
      const document = await this.getDocument(documentId);
      if (!document) {
        throw new Error('Documento no encontrado');
      }

      // Obtener la configuraci√≥n actual
      const config = this.getProcessingConfig(documentId);
      
      // Extraer las secciones usando la configuraci√≥n actual
      const sections = this.extractSections(document);
      
      this.log(LogLevel.INFO, `Extra√≠das ${sections.length} secciones`, { 
        mode: config.mode,
        documentId 
      });

      return sections;
    } catch (error) {
      this.log(LogLevel.ERROR, 'Error al obtener secciones', { error });
      throw error;
    }
  }

  /**
   * Guarda las preguntas generadas para una secci√≥n
   */
  static saveSectionQuestions(sectionId: string, questions: string): void {
    try {
      const questionsKey = `${this.SECTION_QUESTIONS_KEY}_${sectionId}`;
      localStorage.setItem(questionsKey, questions);
    } catch (error) {
      console.error('Error al guardar las preguntas de la secci√≥n:', error);
    }
  }

  /**
   * Marca una secci√≥n como procesada y guarda sus preguntas
   */
  static markSectionAsProcessed(sectionId: string, questions: string): void {
    const sections = this.getAllSections();
    const section = sections.find(s => s.id === sectionId);
    
    if (!section) return;
    
    // Actualizar la secci√≥n
    section.processed = true;
    this.saveSections(sections);
    
    // Guardar las preguntas de la secci√≥n
    this.saveSectionQuestions(sectionId, questions);
    
    // Actualizar el progreso del documento
    const progress = this.getProgress(section.documentId);
    if (progress) {
      progress.processedSections = [...progress.processedSections, sectionId];
      this.saveProgress(section.documentId, progress);
    }
  }

  /**
   * Obtiene el progreso de generaci√≥n de preguntas para un documento
   */
  static getProgress(documentId: string): DocumentProgress | null {
    try {
      const progressKey = `${this.SECTION_PROGRESS_KEY}_${documentId}`;
      const storedProgress = localStorage.getItem(progressKey);
      return storedProgress ? JSON.parse(storedProgress) : null;
    } catch (error) {
      console.error('Error al obtener el progreso:', error);
      return null;
    }
  }

  /**
   * Guarda el progreso de generaci√≥n de preguntas para un documento
   */
  private static saveProgress(documentId: string, progress: DocumentProgress): void {
    try {
      const progressKey = `${this.SECTION_PROGRESS_KEY}_${documentId}`;
      localStorage.setItem(progressKey, JSON.stringify(progress));
    } catch (error) {
      console.error('Error al guardar el progreso:', error);
    }
  }

  /**
   * Obtiene las preguntas generadas para una secci√≥n
   */
  static getSectionQuestions(sectionId: string): string | null {
    try {
      const questionsKey = `${this.SECTION_QUESTIONS_KEY}_${sectionId}`;
      return localStorage.getItem(questionsKey);
    } catch (error) {
      console.error('Error al obtener las preguntas de la secci√≥n:', error);
      return null;
    }
  }

  /**
   * Obtiene todas las secciones almacenadas
   */
  private static getAllSections(): DocumentSection[] {
    const sectionsJson = localStorage.getItem(this.DOCUMENT_SECTIONS_KEY);
    if (!sectionsJson) return [];
    
    try {
      return JSON.parse(sectionsJson);
    } catch (error) {
      console.error('Error al parsear secciones:', error);
      return [];
    }
  }

  /**
   * Obtiene una secci√≥n espec√≠fica por su ID
   */
  static getSection(sectionId: string): DocumentSection | null {
    const sections = this.getAllSections();
    return sections.find(section => section.id === sectionId) || null;
  }

  /**
   * Guarda una secci√≥n de documento
   */
  static saveSection(section: DocumentSection): void {
    const sections = this.getAllSections();
    const existingIndex = sections.findIndex(s => s.id === section.id);
    
    if (existingIndex >= 0) {
      sections[existingIndex] = section;
    } else {
      sections.push(section);
    }
    
    localStorage.setItem(this.DOCUMENT_SECTIONS_KEY, JSON.stringify(sections));
  }

  /**
   * Guarda m√∫ltiples secciones de documento
   */
  static saveSections(newSections: DocumentSection[]): void {
    const sections = this.getAllSections();
    
    for (const section of newSections) {
      const existingIndex = sections.findIndex(s => s.id === section.id);
      if (existingIndex >= 0) {
        sections[existingIndex] = section;
      } else {
        sections.push(section);
      }
    }
    
    localStorage.setItem(this.DOCUMENT_SECTIONS_KEY, JSON.stringify(sections));
  }

  /**
   * Elimina todas las secciones de un documento
   */
  static deleteSections(documentId: string): void {
    const sections = this.getAllSections();
    const filteredSections = sections.filter(section => section.documentId !== documentId);
    localStorage.setItem(this.DOCUMENT_SECTIONS_KEY, JSON.stringify(filteredSections));
    
    // Tambi√©n eliminar el progreso
    this.deleteProgress(documentId);
  }

  /**
   * Elimina el progreso de un documento
   */
  static deleteProgress(documentId: string): void {
    try {
      const progressKey = `${this.SECTION_PROGRESS_KEY}_${documentId}`;
      localStorage.removeItem(progressKey);
    } catch (error) {
      console.error('Error al eliminar el progreso:', error);
    }
  }

  /**
   * Obtiene secciones para un documento espec√≠fico
   * @param documentId ID del documento
   * @returns Array de secciones del documento
   */
  static getSectionsForDocument(documentId: string): DocumentSection[] {
    return this.getAllSections().filter(section => section.documentId === documentId);
  }

  /**
   * Extrae secciones de un documento basado en su estructura y configuraci√≥n
   * @param document Documento a procesar
   * @returns Array de secciones extra√≠das
   */
  static extractSections(document: StoredDocument): DocumentSection[] {
    try {
      const config = this.getProcessingConfig(document.id);
      this.log(LogLevel.INFO, 'Iniciando extracci√≥n de secciones', { 
        mode: config.mode,
        documentId: document.id 
      });
      
      // üîç DEBUGGING: Informaci√≥n detallada del procesamiento
      console.log('üîç [DEBUG] extractSections - Configuraci√≥n:', {
        documentId: document.id,
        title: document.title,
        mode: config.mode,
        configOptions: config.options,
        contentLength: document.content.length
      });

      switch (config.mode) {
        case ProcessingMode.NUMBERED:
          return this.extractNumberedSections(document, config);
        case ProcessingMode.HIERARCHICAL:
          return this.extractHierarchicalSections(document, config);
        case ProcessingMode.PARAGRAPHS:
          return this.extractParagraphSections(document, config);
        case ProcessingMode.CUSTOM:
          return this.extractCustomSections(document, config);
        case ProcessingMode.GENERIC:
          return this.extractGenericSections(document, config);
        case ProcessingMode.FULL:
          // Devuelve el documento completo como una sola secci√≥n
          return [{
            id: `${document.id}-full-0`,
            documentId: document.id,
            title: document.title || 'Documento completo',
            content: document.content,
            type: SectionType.GENERIC,
            order: 0,
            processed: false,
            createdAt: new Date(),
            updatedAt: new Date()
          }];
        case ProcessingMode.MILITARY_DOCTRINE:
          return this.extractMilitaryDoctrineSections(document, config);
        case ProcessingMode.PDC_01_DOCTRINE:
          return this.extractPDC01Sections(document, config);
        default:
          this.log(LogLevel.WARN, 'Modo de procesamiento no reconocido, usando modo numerado');
          return this.extractNumberedSections(document, config);
      }
    } catch (error) {
      this.log(LogLevel.ERROR, 'Error al extraer secciones', { error });
      return [{
        id: `${document.id}-error-0`,
        documentId: document.id,
        title: 'Error al procesar secciones',
        content: document.content,
        type: SectionType.GENERIC,
        order: 0,
        processed: false,
        createdAt: new Date(),
        updatedAt: new Date()
      }];
    }
  }
  
  /**
   * Extrae secciones numeradas (1., 2., etc.)
   */
  private static extractNumberedSections(document: StoredDocument, config: ProcessingConfig): DocumentSection[] {
    try {
      const sections: DocumentSection[] = [];
      const content = document.content;
      let order = 0;

      // Patr√≥n para detectar secciones principales (Primero., Segundo., etc.)
      const mainPattern = /^(Primero|Segundo|Tercero|Cuarto|Quinto|Sexto|S√©ptimo|Octavo|Noveno|D√©cimo|Und√©cimo|Duod√©cimo|Decimotercero|Decimocuarto|Decimoquinto|Decimosexto|Decimos√©ptimo|Decimoctavo|Decimonoveno|Vig√©simo|Vig√©simo primero|Vig√©simo segundo|Vig√©simo tercero|Vig√©simo cuarto|Vig√©simo quinto|Vig√©simo sexto|Vig√©simo s√©ptimo|Vig√©simo octavo|Vig√©simo noveno|Trig√©simo|Trig√©simo primero|Trig√©simo segundo|Trig√©simo tercero|Trig√©simo cuarto|Trig√©simo quinto|Trig√©simo sexto|Trig√©simo s√©ptimo|Trig√©simo octavo|Trig√©simo noveno|Cuadrag√©simo|Cuadrag√©simo primero|Cuadrag√©simo segundo|Cuadrag√©simo tercero|Cuadrag√©simo cuarto|Cuadrag√©simo quinto|Cuadrag√©simo sexto|Cuadrag√©simo s√©ptimo|Cuadrag√©simo octavo|Cuadrag√©simo noveno|Quincuag√©simo|Quincuag√©simo primero|Quincuag√©simo segundo|Quincuag√©simo tercero|Quincuag√©simo cuarto|Quincuag√©simo quinto|Quincuag√©simo sexto|Quincuag√©simo s√©ptimo|Quincuag√©simo octavo|Quincuag√©simo noveno|Sexag√©simo|Sexag√©simo primero|Sexag√©simo segundo|Sexag√©simo tercero|Sexag√©simo cuarto|Sexag√©simo quinto|Sexag√©simo sexto|Sexag√©simo s√©ptimo|Sexag√©simo octavo|Sexag√©simo noveno|Septuag√©simo|Septuag√©simo primero|Septuag√©simo segundo|Septuag√©simo tercero|Septuag√©simo cuarto|Septuag√©simo quinto|Septuag√©simo sexto|Septuag√©simo s√©ptimo|Septuag√©simo octavo|Septuag√©simo noveno|Octog√©simo|Octog√©simo primero|Octog√©simo segundo|Octog√©simo tercero|Octog√©simo cuarto|Octog√©simo quinto|Octog√©simo sexto|Octog√©simo s√©ptimo|Octog√©simo octavo|Octog√©simo noveno|Nonag√©simo)\./gm;
      
      // Encontrar todas las secciones principales
      const mainSections: { index: number, title: string }[] = [];
      let mainMatch;
      
      while ((mainMatch = mainPattern.exec(content)) !== null) {
        mainSections.push({
          index: mainMatch.index,
          title: mainMatch[0]
        });
      }

      // Si no hay secciones principales, usar el m√©todo original
      if (mainSections.length === 0) {
        const pattern = new RegExp(
          config.options.numbered?.pattern || '^\\d+\\.\\s',
          'gm'
        );

        const sectionStarts: number[] = [];
        let match;

        while ((match = pattern.exec(content)) !== null) {
          sectionStarts.push(match.index);
        }

        for (let i = 0; i < sectionStarts.length; i++) {
          const startIndex = sectionStarts[i];
          const endIndex = i < sectionStarts.length - 1 ? sectionStarts[i + 1] : content.length;

          try {
            const sectionContent = content.slice(startIndex, endIndex);
            const titleMatch = sectionContent.match(pattern);

            if (titleMatch) {
              sections.push({
                id: `${document.id}-section-${order}`,
                documentId: document.id,
                title: titleMatch[0].trim(),
                content: sectionContent.trim(),
                type: SectionType.SECTION,
                order: order++,
                processed: false,
                createdAt: new Date(),
                updatedAt: new Date()
              });
            }
          } catch (sectionError) {
            this.log(LogLevel.ERROR, 'Error al procesar secci√≥n individual', { 
              sectionIndex: i, 
              error: sectionError 
            });
            continue;
          }
        }
      } else {
        // Procesar secciones principales y sus subsecciones como una √∫nica secci√≥n
        for (let i = 0; i < mainSections.length; i++) {
          const startIndex = mainSections[i].index;
          const endIndex = i < mainSections.length - 1 ? mainSections[i + 1].index : content.length;

          try {
            const sectionContent = content.slice(startIndex, endIndex);
            
            sections.push({
              id: `${document.id}-main-section-${order}`,
              documentId: document.id,
              title: mainSections[i].title.trim(),
              content: sectionContent.trim(),
              type: SectionType.SECTION,
              order: order++,
              processed: false,
              createdAt: new Date(),
              updatedAt: new Date()
            });
          } catch (sectionError) {
            this.log(LogLevel.ERROR, 'Error al procesar secci√≥n principal', { 
              sectionIndex: i, 
              error: sectionError 
            });
            continue;
          }
        }
      }

      // Si no se encontraron secciones, crear una secci√≥n gen√©rica
      if (sections.length === 0) {
        this.log(LogLevel.WARN, 'No se encontraron secciones numeradas, creando secci√≥n gen√©rica');
        sections.push(this.createGenericSection(document, content));
      }

      return sections;
    } catch (error) {
      this.log(LogLevel.ERROR, 'Error al extraer secciones numeradas', { error });
      return [this.createGenericSection(document, document.content)];
    }
  }
  
  /**
   * Extrae secciones jer√°rquicas (Cap√≠tulos, Disposiciones, etc.)
   */
  private static extractHierarchicalSections(document: StoredDocument, config: ProcessingConfig): DocumentSection[] {
    const content = document.content;
    
    try {
      const sections: DocumentSection[] = [];
      let order = 0;

      // Obtener solo los niveles seleccionados
      const selectedLevels = config.options.hierarchical?.levels || [];
      
      // Si no hay niveles seleccionados, usar todos por defecto
      const levels = selectedLevels.length > 0 ? selectedLevels : [
        'CAP√çTULO',
        'SECCI√ìN',
        'ART√çCULO',
        'Art√≠culo',
        'Art.',
        'ART.',
        'DISPOSICI√ìN'
      ];

      this.log(LogLevel.INFO, 'Procesando niveles jer√°rquicos', { levels });
      
      // Debug: Buscar una muestra del contenido para verificar formato
      const contentSample = content.substring(0, 2000);
      const articleMatches = contentSample.match(/Art√≠culo\s*\d+/gi);
      this.log(LogLevel.DEBUG, 'Muestra de art√≠culos en el contenido', { 
        muestra: contentSample.substring(0, 500),
        articulosEnMuestra: articleMatches 
      });

      // Crear patr√≥n para detectar niveles (m√°s flexible para art√≠culos)
      // Detecta: Art√≠culo 66, ART√çCULO 67, etc.
      const articlePattern = /(?:Art√≠culo|ART[I√ç]CULO)\s*\d+[.:]?/gmi;
      // Crear patr√≥n para otros niveles
      const otherLevels = levels.filter(lvl => !['Art√≠culo', 'ART√çCULO', 'Art.', 'ART.'].includes(lvl));
      const otherPattern = otherLevels.length > 0
        ? new RegExp(`(?:${otherLevels.join('|')})\\s*\\d+[.:]?`, 'gmi')
        : null;

      // Encontrar todos los √≠ndices de inicio de secci√≥n
      interface SectionStart {
        index: number;
        level: string;
        title: string;
      }
      const sectionStarts: SectionStart[] = [];
      let match;

      // Buscar art√≠culos
      while ((match = articlePattern.exec(content)) !== null) {
        sectionStarts.push({
          index: match.index,
          level: 'ARTICULO',
          title: match[0].replace(/\*/g, '').trim()
        });
      }
      // Buscar otros niveles
      if (otherPattern) {
        while ((match = otherPattern.exec(content)) !== null) {
          sectionStarts.push({
            index: match.index,
            level: match[0].split(/\s/)[0].toUpperCase(),
            title: match[0].replace(/\*/g, '')
          });
        }
      }
      // Ordenar por √≠ndice de aparici√≥n
      sectionStarts.sort((a, b) => a.index - b.index);

      // Logging detallado por tipo
      const articleSections = sectionStarts.filter(s => s.level === 'ARTICULO');
      const otherSections = sectionStarts.filter(s => s.level !== 'ARTICULO');
      
      this.log(LogLevel.INFO, `An√°lisis jer√°rquico completado`, {
        totalSections: sectionStarts.length,
        articulos: articleSections.length,
        otrosTipos: otherSections.length,
        articulosEncontrados: articleSections.map(s => s.title),
        otrosTiposEncontrados: otherSections.map(s => ({ level: s.level, title: s.title }))
      });

      // Procesar secciones una por una
      for (let i = 0; i < sectionStarts.length; i++) {
        try {
          const currentLevel = sectionStarts[i].level;
          const startIndex = sectionStarts[i].index;
          const endIndex = i < sectionStarts.length - 1 ? sectionStarts[i + 1].index : content.length;
          const sectionContent = content.slice(startIndex, endIndex).trim();
          if (sectionContent) {
            sections.push({
              id: `${document.id}-hierarchical-${order}`,
              documentId: document.id,
              title: sectionStarts[i].title.trim(),
              content: sectionContent,
              type: this.determineHierarchicalType(currentLevel),
              order: order++,
              processed: false,
              createdAt: new Date(),
              updatedAt: new Date()
            });
          }
        } catch (sectionError) {
          this.log(LogLevel.ERROR, 'Error al procesar secci√≥n jer√°rquica individual', { 
            sectionIndex: i, 
            level: sectionStarts[i].level,
            error: sectionError 
          });
          continue;
        }
      }

      // Si no se encontraron secciones v√°lidas, crear una secci√≥n gen√©rica
      if (sections.length === 0) {
        this.log(LogLevel.WARN, 'No se encontraron secciones jer√°rquicas v√°lidas, creando secci√≥n gen√©rica');
        sections.push(this.createGenericSection(document, content));
      }

      return sections;
    } catch (error) {
      this.log(LogLevel.ERROR, 'Error general al extraer secciones jer√°rquicas', { error });
      return [this.createGenericSection(document, content)];
    }
  }

  /**
   * Extrae secciones por p√°rrafos
   */
  private static extractParagraphSections(document: StoredDocument, config: ProcessingConfig): DocumentSection[] {
    const sections: DocumentSection[] = [];
    const content = document.content;
    
    // Dividir por p√°rrafos
    const paragraphs = content.split(/\n\s*\n/);
    
    const maxParagraphsPerSection = config.options.paragraphs?.maxParagraphsPerSection || 10;
    let currentSection: string[] = [];
    let currentLength = 0;
    let order = 0;
    
    for (let i = 0; i < paragraphs.length; i++) {
      const paragraph = paragraphs[i].trim();
      if (!paragraph) continue;
      
      currentSection.push(paragraph);
      currentLength += paragraph.length;
      
      // Crear nueva secci√≥n si alcanzamos el l√≠mite
      if (currentSection.length >= maxParagraphsPerSection || 
          currentLength >= (config.options.maxSectionLength || 5000) || 
          i === paragraphs.length - 1) {
        
        const sectionContent = currentSection.join('\n\n');
        
        if (sectionContent.length >= (config.options.minSectionLength || 100)) {
        sections.push({
          id: `${document.id}-paragraph-${order}`,
          documentId: document.id,
            title: this.generateSectionTitle(sectionContent, order),
          content: sectionContent,
          type: SectionType.PARAGRAPH,
            order: order++,
          processed: false,
          createdAt: new Date(),
          updatedAt: new Date()
        });
        }
        
        currentSection = [];
        currentLength = 0;
      }
    }
    
    // Si no se encontraron secciones v√°lidas, crear una secci√≥n gen√©rica
    if (sections.length === 0) {
      this.log(LogLevel.WARN, 'No se encontraron p√°rrafos v√°lidos, creando secci√≥n gen√©rica');
      sections.push(this.createGenericSection(document, content));
    }
    
    return sections;
  }

  /**
   * Extrae secciones usando patrones personalizados
   */
  private static extractCustomSections(document: StoredDocument, config: ProcessingConfig): DocumentSection[] {
    const content = document.content;
    
    try {
      const sections: DocumentSection[] = [];
      let order = 0;

      // Usar patrones personalizados o patr√≥n por defecto
      const patterns = config.options.custom?.patterns || ['^[\\w\\d]+\\.\\s'];
      const flags = config.options.custom?.caseSensitive ? 'gm' : 'gmi';

      // Procesar cada patr√≥n
      for (const patternStr of patterns) {
        try {
          const pattern = new RegExp(patternStr, flags);
          
          // Encontrar todos los √≠ndices de inicio de secci√≥n
          const sectionStarts: number[] = [];
          let match;

          while ((match = pattern.exec(content)) !== null) {
            sectionStarts.push(match.index);
          }

          // Procesar secciones una por una
          for (let i = 0; i < sectionStarts.length; i++) {
            try {
              const startIndex = sectionStarts[i];
              const endIndex = i < sectionStarts.length - 1 ? sectionStarts[i + 1] : content.length;
              
              // Extraer contenido de la secci√≥n
              const sectionContent = content.slice(startIndex, endIndex);
              const titleMatch = sectionContent.match(pattern);

              if (titleMatch) {
      sections.push({
                  id: `${document.id}-custom-${order}`,
                  documentId: document.id,
                  title: titleMatch[0].trim(),
                  content: sectionContent.trim(),
                  type: SectionType.GENERIC,
                  order: order++,
                  processed: false,
                  createdAt: new Date(),
                  updatedAt: new Date()
                });
              }
            } catch (sectionError) {
              this.log(LogLevel.ERROR, 'Error al procesar secci√≥n individual personalizada', { 
                sectionIndex: i, 
                pattern: patternStr,
                error: sectionError 
              });
              // Continuar con la siguiente secci√≥n en caso de error
              continue;
            }
          }
        } catch (patternError) {
          this.log(LogLevel.ERROR, 'Error al procesar patr√≥n personalizado', { 
            pattern: patternStr,
            error: patternError 
          });
          // Continuar con el siguiente patr√≥n en caso de error
          continue;
        }
      }

      // Si no se encontraron secciones v√°lidas, crear una secci√≥n gen√©rica
      if (sections.length === 0) {
        this.log(LogLevel.WARN, 'No se encontraron secciones personalizadas v√°lidas, creando secci√≥n gen√©rica');
        sections.push(this.createGenericSection(document, content));
      }

      return sections;
    } catch (error) {
      this.log(LogLevel.ERROR, 'Error general al extraer secciones personalizadas', { error });
      return [this.createGenericSection(document, content)];
    }
  }

  /**
   * Extrae secciones gen√©ricas del documento
   */
  private static extractGenericSections(document: StoredDocument, config: ProcessingConfig): DocumentSection[] {
    try {
      const sections: DocumentSection[] = [];
      const content = document.content;
      let order = 0;

      // Patr√≥n para detectar secciones principales (Primero., Segundo., etc.)
      const mainPattern = /^(Primero|Segundo|Tercero|Cuarto|Quinto|Sexto|S√©ptimo|Octavo|Noveno|D√©cimo|Und√©cimo|Duod√©cimo|Decimotercero|Decimocuarto|Decimoquinto|Decimosexto|Decimos√©ptimo|Decimoctavo|Decimonoveno|Vig√©simo|Vig√©simo primero|Vig√©simo segundo|Vig√©simo tercero|Vig√©simo cuarto|Vig√©simo quinto|Vig√©simo sexto|Vig√©simo s√©ptimo|Vig√©simo octavo|Vig√©simo noveno|Trig√©simo|Trig√©simo primero|Trig√©simo segundo|Trig√©simo tercero|Trig√©simo cuarto|Trig√©simo quinto|Trig√©simo sexto|Trig√©simo s√©ptimo|Trig√©simo octavo|Trig√©simo noveno|Cuadrag√©simo|Cuadrag√©simo primero|Cuadrag√©simo segundo|Cuadrag√©simo tercero|Cuadrag√©simo cuarto|Cuadrag√©simo quinto|Cuadrag√©simo sexto|Cuadrag√©simo s√©ptimo|Cuadrag√©simo octavo|Cuadrag√©simo noveno|Quincuag√©simo|Quincuag√©simo primero|Quincuag√©simo segundo|Quincuag√©simo tercero|Quincuag√©simo cuarto|Quincuag√©simo quinto|Quincuag√©simo sexto|Quincuag√©simo s√©ptimo|Quincuag√©simo octavo|Quincuag√©simo noveno|Sexag√©simo|Sexag√©simo primero|Sexag√©simo segundo|Sexag√©simo tercero|Sexag√©simo cuarto|Sexag√©simo quinto|Sexag√©simo sexto|Sexag√©simo s√©ptimo|Sexag√©simo octavo|Sexag√©simo noveno|Septuag√©simo|Septuag√©simo primero|Septuag√©simo segundo|Septuag√©simo tercero|Septuag√©simo cuarto|Septuag√©simo quinto|Septuag√©simo sexto|Septuag√©simo s√©ptimo|Septuag√©simo octavo|Septuag√©simo noveno|Octog√©simo|Octog√©simo primero|Octog√©simo segundo|Octog√©simo tercero|Octog√©simo cuarto|Octog√©simo quinto|Octog√©simo sexto|Octog√©simo s√©ptimo|Octog√©simo octavo|Octog√©simo noveno|Nonag√©simo)\./gm;
      
      // Encontrar todas las secciones principales
      const mainSections: { index: number, title: string }[] = [];
      let mainMatch;
      
      while ((mainMatch = mainPattern.exec(content)) !== null) {
        mainSections.push({
          index: mainMatch.index,
          title: mainMatch[0]
        });
      }

      // Si hay secciones principales, procesarlas como unidades completas
      if (mainSections.length > 0) {
        for (let i = 0; i < mainSections.length; i++) {
          const startIndex = mainSections[i].index;
          const endIndex = i < mainSections.length - 1 ? mainSections[i + 1].index : content.length;

          try {
            const sectionContent = content.slice(startIndex, endIndex);
            
            sections.push({
              id: `${document.id}-main-section-${order}`,
              documentId: document.id,
              title: mainSections[i].title.trim(),
              content: sectionContent.trim(),
              type: SectionType.MAIN_SECTION,  // Usar el nuevo tipo
              order: order++,
              processed: false,
              createdAt: new Date(),
              updatedAt: new Date()
            });
          } catch (sectionError) {
            this.log(LogLevel.ERROR, 'Error al procesar secci√≥n principal', { 
              sectionIndex: i, 
              error: sectionError 
            });
            continue;
          }
        }
      } else {
        // Si no hay secciones principales, procesar por p√°rrafos
        const paragraphs = content.split(/\n\s*\n/);
        let currentSection: string[] = [];
        let paragraphCount = 0;
        const maxParagraphsPerSection = config.options.generic?.maxParagraphsPerSection || 10;

        for (const paragraph of paragraphs) {
          const trimmedParagraph = paragraph.trim();
          if (!trimmedParagraph) continue;

          currentSection.push(trimmedParagraph);
          paragraphCount++;

          if (paragraphCount >= maxParagraphsPerSection) {
            if (currentSection.length > 0) {
              const sectionContent = currentSection.join('\n\n');
              sections.push({
                id: `${document.id}-section-${order}`,
                documentId: document.id,
                title: `Secci√≥n ${order + 1}`,
                content: sectionContent,
                type: SectionType.SECTION,
                order: order++,
                processed: false,
                createdAt: new Date(),
                updatedAt: new Date()
              });
            }
            currentSection = [];
            paragraphCount = 0;
          }
        }

        // Agregar la √∫ltima secci√≥n si quedaron p√°rrafos
        if (currentSection.length > 0) {
          const sectionContent = currentSection.join('\n\n');
          sections.push({
            id: `${document.id}-section-${order}`,
            documentId: document.id,
            title: `Secci√≥n ${order + 1}`,
            content: sectionContent,
            type: SectionType.SECTION,
            order: order++,
            processed: false,
            createdAt: new Date(),
            updatedAt: new Date()
          });
        }
      }

      // Si no se encontraron secciones, crear una secci√≥n gen√©rica
      if (sections.length === 0) {
        this.log(LogLevel.WARN, 'No se encontraron secciones, creando secci√≥n gen√©rica');
        sections.push(this.createGenericSection(document, content));
      }

      return sections;
    } catch (error) {
      this.log(LogLevel.ERROR, 'Error al extraer secciones gen√©ricas', { error });
      return [this.createGenericSection(document, document.content)];
    }
  }

  /**
   * Determina el tipo de secci√≥n basado en el nivel jer√°rquico
   */
  private static determineHierarchicalType(level: string): SectionType {
    switch (level.toUpperCase()) {
      case 'CAP√çTULO':
        return SectionType.CHAPTER;
      case 'SECCI√ìN':
        return SectionType.SECTION;
      case 'ART√çCULO':
        return SectionType.ARTICLE;
      default:
        return SectionType.GENERIC;
    }
  }

  /**
   * Crea una secci√≥n gen√©rica para todo el contenido
   */
  private static createGenericSection(document: StoredDocument, content: string): DocumentSection {
    return {
        id: `${document.id}-generic-0`,
        documentId: document.id,
        title: document.title || 'Documento completo',
        content: content,
        type: SectionType.GENERIC,
        order: 0,
        processed: false,
        createdAt: new Date(),
        updatedAt: new Date()
    };
  }
  
  /**
   * Genera un t√≠tulo para una secci√≥n basado en su contenido
   */
  private static generateSectionTitle(content: string, sectionNumber: number): string {
    // Intentar extraer la primera l√≠nea o frase como t√≠tulo
    const firstLine = content.split('\n')[0].trim();
    
    if (firstLine.length <= 100) {
      return firstLine;
    }
    
    // Si la primera l√≠nea es muy larga, extraer la primera frase
    const firstSentenceMatch = content.match(/^[^.!?]+[.!?]/);
    if (firstSentenceMatch && firstSentenceMatch[0].length <= 100) {
      return firstSentenceMatch[0].trim();
    }
    
    // Si todo falla, usar un t√≠tulo gen√©rico
    return `Secci√≥n ${sectionNumber + 1}`;
  }

  /**
   * Obtiene la configuraci√≥n de procesamiento para un documento
   */
  static getProcessingConfig(documentId: string): ProcessingConfig {
    try {
      const configJson = localStorage.getItem(`${this.PROCESSING_CONFIG_KEY}_${documentId}`);
      if (!configJson) return this.DEFAULT_CONFIG;
      return JSON.parse(configJson);
    } catch (error) {
      this.log(LogLevel.WARN, 'Error al obtener configuraci√≥n, usando valores por defecto', { error });
      return this.DEFAULT_CONFIG;
    }
  }

  /**
   * Guarda la configuraci√≥n de procesamiento para un documento
   */
  static saveProcessingConfig(documentId: string, config: ProcessingConfig): void {
    try {
      localStorage.setItem(
        `${this.PROCESSING_CONFIG_KEY}_${documentId}`,
        JSON.stringify(config)
      );
      this.log(LogLevel.INFO, 'Configuraci√≥n guardada', { documentId });
    } catch (error) {
      this.log(LogLevel.ERROR, 'Error al guardar configuraci√≥n', { error });
      throw new Error('No se pudo guardar la configuraci√≥n');
    }
  }

  /**
   * Elimina la configuraci√≥n de procesamiento de un documento
   */
  static deleteProcessingConfig(documentId: string): void {
    localStorage.removeItem(`${this.PROCESSING_CONFIG_KEY}_${documentId}`);
    this.log(LogLevel.INFO, 'Configuraci√≥n eliminada', { documentId });
  }

  /**
   * Obtiene un documento almacenado por su ID
   */
  private static async getDocument(documentId: string): Promise<StoredDocument | null> {
    try {
      // Delegar la obtenci√≥n del documento a StorageService
      const document = await StorageService.getDocumentById(documentId);
      // Ensure the returned document matches the StoredDocument structure or null
      return document ? { 
        id: document.id,
        title: document.title,
        content: document.content,
        createdAt: new Date(document.createdAt),
        updatedAt: new Date(document.updatedAt),
        type: document.type, // Assuming type is part of StoredDocument as used elsewhere
        tokens: document.tokens, // Assuming tokens is part of StoredDocument
        processingTime: document.processingTime // Assuming processingTime is part of StoredDocument
      } as StoredDocument : null; // Cast to StoredDocument for type consistency
    } catch (error) {
      this.log(LogLevel.ERROR, 'Error al obtener documento de StorageService', { error, documentId });
      return null;
    }
  }

  /**
   * Guarda un documento en el almacenamiento
   */
  private static async saveDocument(document: StoredDocument): Promise<void> {
    try {
      // Delegar el guardado del documento a StorageService
      await StorageService.saveDocument(document);
      this.log(LogLevel.INFO, 'Documento guardado correctamente', { id: document.id });
    } catch (error) {
      this.log(LogLevel.ERROR, 'Error al guardar documento', { error });
      throw new Error('Error al guardar documento en StorageService');
    }
  }

  /**
   * Extrae secciones de documentos militares con estructura espec√≠fica
   * Maneja: CAP√çTULO X, secciones numeradas (1., 2., 3.), subsecciones (3.1.), p√°rrafos numerados
   */
  private static extractMilitaryDoctrineSections(document: StoredDocument, config: ProcessingConfig): DocumentSection[] {
    try {
      const sections: DocumentSection[] = [];
      const content = document.content;
      let order = 0;

      this.log(LogLevel.INFO, 'Procesando documento de doctrina militar');

      // Patrones espec√≠ficos para documentos militares
      const chapterPattern = /^CAP√çTULO\s+([IVX]+|\d+)\s+[A-Z√Å√ë√ú\s]+$/gm;
      const mainSectionPattern = /^\d+\.\s+[A-Z√Å√ë√ú\s]+$/gm;
      const subSectionPattern = /^\d+\.\d+\.\s+[A-Za-z√°√±√º√Å√ë√ú\s]+$/gm;
      
      // ‚úÖ ACTUALIZADO: Patr√≥n completo para art√≠culos ordinales espa√±oles (Primero hasta Nonag√©simo)
      const ordinalArticlePattern = /^(Primero|Segundo|Tercero|Cuarto|Quinto|Sexto|S√©ptimo|Octavo|Noveno|D√©cimo|Und√©cimo|Duod√©cimo|Decimotercero|Decimocuarto|Decimoquinto|Decimosexto|Decimos√©ptimo|Decimoctavo|Decimonoveno|Vig√©simo|Vig√©simo primero|Vig√©simo segundo|Vig√©simo tercero|Vig√©simo cuarto|Vig√©simo quinto|Vig√©simo sexto|Vig√©simo s√©ptimo|Vig√©simo octavo|Vig√©simo noveno|Trig√©simo|Trig√©simo primero|Trig√©simo segundo|Trig√©simo tercero|Trig√©simo cuarto|Trig√©simo quinto|Trig√©simo sexto|Trig√©simo s√©ptimo|Trig√©simo octavo|Trig√©simo noveno|Cuadrag√©simo|Cuadrag√©simo primero|Cuadrag√©simo segundo|Cuadrag√©simo tercero|Cuadrag√©simo cuarto|Cuadrag√©simo quinto|Cuadrag√©simo sexto|Cuadrag√©simo s√©ptimo|Cuadrag√©simo octavo|Cuadrag√©simo noveno|Quincuag√©simo|Quincuag√©simo primero|Quincuag√©simo segundo|Quincuag√©simo tercero|Quincuag√©simo cuarto|Quincuag√©simo quinto|Quincuag√©simo sexto|Quincuag√©simo s√©ptimo|Quincuag√©simo octavo|Quincuag√©simo noveno|Sexag√©simo|Sexag√©simo primero|Sexag√©simo segundo|Sexag√©simo tercero|Sexag√©simo cuarto|Sexag√©simo quinto|Sexag√©simo sexto|Sexag√©simo s√©ptimo|Sexag√©simo octavo|Sexag√©simo noveno|Septuag√©simo|Septuag√©simo primero|Septuag√©simo segundo|Septuag√©simo tercero|Septuag√©simo cuarto|Septuag√©simo quinto|Septuag√©simo sexto|Septuag√©simo s√©ptimo|Septuag√©simo octavo|Septuag√©simo noveno|Octog√©simo|Octog√©simo primero|Octog√©simo segundo|Octog√©simo tercero|Octog√©simo cuarto|Octog√©simo quinto|Octog√©simo sexto|Octog√©simo s√©ptimo|Octog√©simo octavo|Octog√©simo noveno|Nonag√©simo)\.\s+(.+?)$/gm;
      
      // Encontrar todas las divisiones principales
      const allMatches: { index: number, title: string, type: SectionType, level: number }[] = [];
      
      // Buscar cap√≠tulos
      let match;
      while ((match = chapterPattern.exec(content)) !== null) {
        allMatches.push({
          index: match.index,
          title: match[0].trim(),
          type: SectionType.CHAPTER,
          level: 1
        });
      }
      
      // Buscar secciones principales (1., 2., 3.)
      chapterPattern.lastIndex = 0; // Reset regex
      while ((match = mainSectionPattern.exec(content)) !== null) {
        allMatches.push({
          index: match.index,
          title: match[0].trim(),
          type: SectionType.MAIN_SECTION,
          level: 2
        });
      }
      
      // Buscar subsecciones (3.1., 3.2., etc.)
      mainSectionPattern.lastIndex = 0; // Reset regex
      while ((match = subSectionPattern.exec(content)) !== null) {
        allMatches.push({
          index: match.index,
          title: match[0].trim(),
          type: SectionType.SECTION,
          level: 3
        });
      }
      
      // ‚úÖ NUEVO: Buscar art√≠culos ordinales (Primero., Segundo., etc.)
      subSectionPattern.lastIndex = 0; // Reset regex
      while ((match = ordinalArticlePattern.exec(content)) !== null) {
        allMatches.push({
          index: match.index,
          title: match[0].trim(),
          type: SectionType.ARTICLE,
          level: 2
        });
      }
      
      // Ordenar por √≠ndice de aparici√≥n
      allMatches.sort((a, b) => a.index - b.index);
      
      this.log(LogLevel.INFO, `Encontrados ${allMatches.length} divisiones principales`, { 
        chapters: allMatches.filter(m => m.type === SectionType.CHAPTER).length,
        mainSections: allMatches.filter(m => m.type === SectionType.MAIN_SECTION).length,
        subSections: allMatches.filter(m => m.type === SectionType.SECTION).length,
        articles: allMatches.filter(m => m.type === SectionType.ARTICLE).length
      });

      // Crear secciones basadas en las divisiones encontradas
      for (let i = 0; i < allMatches.length; i++) {
        const currentMatch = allMatches[i];
        const nextMatch = i < allMatches.length - 1 ? allMatches[i + 1] : null;
        
        const startIndex = currentMatch.index;
        const endIndex = nextMatch ? nextMatch.index : content.length;
        
        try {
          const sectionContent = content.slice(startIndex, endIndex).trim();
          
          // Validar que la secci√≥n tenga contenido suficiente
          if (sectionContent.length < (config.options.minSectionLength || 50)) {
            this.log(LogLevel.WARN, `Secci√≥n muy corta omitida: ${currentMatch.title}`);
            continue;
          }
          
          sections.push({
            id: `${document.id}-military-${order}`,
            documentId: document.id,
            title: currentMatch.title,
            content: sectionContent,
            type: currentMatch.type,
            order: order++,
            processed: false,
            createdAt: new Date(),
            updatedAt: new Date()
          });
          
          this.log(LogLevel.DEBUG, `Secci√≥n creada: ${currentMatch.title}`, {
            type: currentMatch.type,
            length: sectionContent.length
          });
          
        } catch (sectionError) {
          this.log(LogLevel.ERROR, `Error al procesar divisi√≥n: ${currentMatch.title}`, { error: sectionError });
          continue;
        }
      }

      // Si no se encontraron divisiones principales, procesar por p√°rrafos numerados secuenciales
      if (sections.length === 0) {
        this.log(LogLevel.WARN, 'No se encontraron divisiones principales, procesando por p√°rrafos numerados');
        return this.extractNumberedParagraphs(document, config);
      }

      this.log(LogLevel.INFO, `Extracci√≥n de doctrina militar completada: ${sections.length} secciones`);
      return sections;
      
    } catch (error) {
      this.log(LogLevel.ERROR, 'Error al extraer secciones de doctrina militar', { error });
      return [this.createGenericSection(document, document.content)];
    }
  }

  /**
   * Extrae secciones bas√°ndose en p√°rrafos numerados secuencialmente
   * Para casos donde el documento usa numeraci√≥n continua (1, 2, 3, ..., 147, 148, etc.)
   */
  private static extractNumberedParagraphs(document: StoredDocument, config: ProcessingConfig): DocumentSection[] {
    try {
      const sections: DocumentSection[] = [];
      const content = document.content;
      let order = 0;

      // Patr√≥n para detectar p√°rrafos numerados al inicio de l√≠nea
      const paragraphPattern = /^\s*(\d+)\s+/gm;
      const paragraphs: { number: number, index: number }[] = [];
      
      let match;
      while ((match = paragraphPattern.exec(content)) !== null) {
        const paragraphNumber = parseInt(match[1]);
        paragraphs.push({
          number: paragraphNumber,
          index: match.index
        });
      }
      
      // Agrupar p√°rrafos en secciones l√≥gicas
      const sectionSize = config.options.paragraphs?.maxParagraphsPerSection || 10;
      
      for (let i = 0; i < paragraphs.length; i += sectionSize) {
        const startParagraph = paragraphs[i];
        const endParagraph = paragraphs[Math.min(i + sectionSize - 1, paragraphs.length - 1)];
        const nextSection = paragraphs[Math.min(i + sectionSize, paragraphs.length - 1)];
        
        const startIndex = startParagraph.index;
        const endIndex = i + sectionSize < paragraphs.length ? nextSection.index : content.length;
        
        const sectionContent = content.slice(startIndex, endIndex).trim();
        
        if (sectionContent.length >= (config.options.minSectionLength || 100)) {
          sections.push({
            id: `${document.id}-paragraphs-${order}`,
            documentId: document.id,
            title: `P√°rrafos ${startParagraph.number}-${endParagraph.number}`,
            content: sectionContent,
            type: SectionType.PARAGRAPH,
            order: order++,
            processed: false,
            createdAt: new Date(),
            updatedAt: new Date()
          });
        }
      }
      
      return sections;
      
    } catch (error) {
      this.log(LogLevel.ERROR, 'Error al extraer p√°rrafos numerados', { error });
      return [this.createGenericSection(document, document.content)];
    }
  }

  /**
   * Detecta si un documento es de doctrina militar bas√°ndose en su contenido
   */
  static detectMilitaryDoctrine(content: string): boolean {
    // Indicadores de documentos de doctrina militar
    const militaryIndicators = [
      /FUERZAS\s+ARMADAS/gi,
      /CAP√çTULO\s+\d+/gi,
      /DOCTRINA/gi,
      /DEFENSA/gi,
      /MILITAR/gi,
      /ORGANIZACI√ìN\s+DE\s+LAS\s+FAS/gi,
      /PLANEAMIENTO\s+DE\s+LA\s+DEFENSA/gi,
      /CAPACIDADES\s+MILITARES/gi,
      /TRANSFORMACI√ìN\s+MILITAR/gi,
      // ‚úÖ NUEVOS INDICADORES PARA DOCUMENTOS DE ORGANIZACI√ìN MILITAR
      /ORGANIZACI√ìN\s+DEL\s+EAYE/gi,
      /ESTADO\s+MAYOR/gi,
      /EJ√âRCITO/gi,
      /ARMADA/gi,
      /AIRE/gi,
      /MANDO/gi,
      /JEFE\s+DE\s+ESTADO\s+MAYOR/gi,
      /MINISTERIO\s+DE\s+DEFENSA/gi,
      /ESTRUCTURA\s+ORG√ÅNICA/gi,
      /ORGANIGRAMA/gi,
      /DEPENDENCIA\s+ORG√ÅNICA/gi,
      /UNIDADES\s+MILITARES/gi,
      // ‚úÖ NUEVOS INDICADORES PARA INSTRUCCIONES MILITARES
      /INSTRUCCI√ìN.*\d+-\d+/gi,
      /JEFE\s+DE\s+ESTADO\s+MAYOR.*EJ√âRCITO\s+DEL\s+AIRE/gi,
      /EJ√âRCITO\s+DEL\s+AIRE\s+Y\s+DEL\s+ESPACIO/gi,
      /(Primero|Segundo|Tercero|Cuarto|Quinto)\.\s+[A-Z√Å√ë√ú]/gi,
      // üî• INDICADORES ESPEC√çFICOS PARA ORGANIZACI√ìN MILITAR ESPA√ëOLA
      /ORDEN\s+DEF.*\d+\/\d+/gi,
      /ORGANIZACI√ìN.*EJ√âRCITO\s+DE\s+TIERRA/gi,
      /EJ√âRCITO\s+DE\s+TIERRA/gi,
      /(Vig√©simo|Trig√©simo|Cuadrag√©simo|Quincuag√©simo|Sexag√©simo|Septuag√©simo|Octog√©simo|Nonag√©simo)/gi,
      /CUARTEL\s+GENERAL/gi,
      /DIVISI√ìN.*CASTILLEJOS/gi,
      /DIVISI√ìN.*SAN\s+MARCIAL/gi,
      /BRIGADA.*PARACAIDISTAS/gi,
      /MANDO\s+DE\s+OPERACIONES\s+ESPECIALES/gi
    ];

    let indicatorCount = 0;
    const foundIndicators: string[] = [];
    
    for (const indicator of militaryIndicators) {
      if (indicator.test(content)) {
        indicatorCount++;
        foundIndicators.push(indicator.source);
      }
    }

    // ‚úÖ MEJORADO: Detecci√≥n espec√≠fica para documentos de organizaci√≥n militar espa√±ola
    const hasEAYE = /EAYE|ESTADO\s+MAYOR\s+DEL\s+AIRE\s+Y\s+DEL\s+ESPACIO/gi.test(content);
    const hasOrganization = /ORGANIZACI√ìN/gi.test(content);
    const hasMilitary = /MILITAR|EJ√âRCITO|ARMADA|AIRE|DEFENSA/gi.test(content);
    const hasInstruction = /INSTRUCCI√ìN.*\d+-\d+/gi.test(content) && /JEFE\s+DE\s+ESTADO\s+MAYOR.*EJ√âRCITO\s+DEL\s+AIRE/gi.test(content);
    const hasOrdinalArticles = /(Primero|Segundo|Tercero|Cuarto|Quinto)\.\s+[A-Z√Å√ë√ú]/gi.test(content);
    
    // üî• NUEVA DETECCI√ìN ESPEC√çFICA PARA ORGANIZACI√ìN ET
    const hasOrdenDEF = /ORDEN\s+DEF.*\d+\/\d+/gi.test(content);
    const hasEjercitoDeTierra = /EJ√âRCITO\s+DE\s+TIERRA/gi.test(content);
    const hasOrdinalSpanish = /(Vig√©simo|Trig√©simo|Cuadrag√©simo|Quincuag√©simo|Sexag√©simo|Septuag√©simo|Octog√©simo|Nonag√©simo)/gi.test(content);
    const hasMilitaryUnits = /CUARTEL\s+GENERAL|DIVISI√ìN|BRIGADA|MANDO\s+DE/gi.test(content);
    
    // Si es documento de organizaci√≥n ET, instrucci√≥n militar, o tiene indicadores de organizaci√≥n militar, detectar como militar
    const isDetected = hasEAYE || hasInstruction || (hasOrganization && hasMilitary) || (hasOrdinalArticles && hasMilitary) || 
                      (hasOrdenDEF && hasEjercitoDeTierra) || (hasOrdinalSpanish && hasMilitaryUnits) || indicatorCount >= 2;
    
    this.log(LogLevel.INFO, `Detecci√≥n militar mejorada:`, {
      indicadores: indicatorCount,
      tieneEAYE: hasEAYE,
      tieneOrganizacion: hasOrganization,
      tieneMilitar: hasMilitary,
      tieneInstruccion: hasInstruction,
      tieneArticulosOrdinales: hasOrdinalArticles,
      // üî• NUEVOS INDICADORES
      tieneOrdenDEF: hasOrdenDEF,
      tieneEjercitoDeTierra: hasEjercitoDeTierra,
      tieneOrdinalEspanol: hasOrdinalSpanish,
      tieneUnidadesMilitares: hasMilitaryUnits,
      resultado: isDetected ? 'DETECTADO' : 'NO DETECTADO',
      indicadoresEncontrados: foundIndicators.slice(0, 5) // Mostrar solo los primeros 5
    });

    return isDetected;
  }

  /**
   * Configura autom√°ticamente el procesamiento para un documento de doctrina militar
   */
  static setupMilitaryDoctrineProcessing(documentId: string): void {
    this.log(LogLevel.INFO, `Configurando procesamiento de doctrina militar para documento: ${documentId}`);
    this.saveProcessingConfig(documentId, this.MILITARY_DOCTRINE_CONFIG);
  }

  /**
   * Procesa un documento detectando autom√°ticamente si es PDC-01, militar general, o est√°ndar
   */
  static async smartProcessDocument(document: StoredDocument): Promise<StoredDocument> {
    this.log(LogLevel.INFO, 'Iniciando procesamiento inteligente del documento', { id: document.id });
    
    // ‚úÖ DETECTAR Y GUARDAR CONFIGURACI√ìN AUTOM√ÅTICAMENTE
    let configApplied = false;
    
    // Detectar primero si es PDC-01 espec√≠fico
    if (this.detectPDC01Document(document.content)) {
      this.log(LogLevel.INFO, 'Documento PDC-01 B detectado autom√°ticamente - Aplicando configuraci√≥n');
      this.setupPDC01Processing(document.id);
      configApplied = true;
    }
    // Si no es PDC-01, verificar si es militar general
    else if (this.detectMilitaryDoctrine(document.content)) {
      this.log(LogLevel.INFO, 'Documento de doctrina militar detectado autom√°ticamente - Aplicando configuraci√≥n');
      this.setupMilitaryDoctrineProcessing(document.id);
      configApplied = true;
    }
    
    if (!configApplied) {
      this.log(LogLevel.INFO, 'Documento est√°ndar detectado - Manteniendo configuraci√≥n por defecto');
    }
    
    // Procesar con la configuraci√≥n detectada o por defecto
    return await this.updateDocument(document);
  }

  /**
   * Lista de apartados espec√≠ficos de PDC-01 B Doctrina para el empleo de las FAS
   * Organizados por cap√≠tulos con numeraci√≥n jer√°rquica
   */
  private static PDC_01_APARTADOS_JERARQUICOS = {
    // CAP√çTULO 1 - ENTORNO ESTRAT√âGICO
    'CAPITULO_1': [
      'ENTORNO GLOBAL DE SEGURIDAD',
      'CONTEXTO DE COMPETICI√ìN', 
      'EL CONFLICTO',
      'INSTRUMENTOS DE PODER',
      'INTERESES NACIONALES',
      'LA SEGURIDAD NACIONAL',
      'LA DEFENSA NACIONAL',
      'CONTRIBUCIONES DE LAS FAS A LA SEGURIDAD',
      'LA CULTURA DE DEFENSA'
    ],
    
    // CAP√çTULO 2 - FUERZAS ARMADAS  
    'CAPITULO_2': [
      'EMPLEO Y MISIONES DE LAS FUERZAS ARMADAS',
      'PLANEAMIENTO DE LA DEFENSA',
      'CAPACIDADES MILITARES DE LAS FUERZAS ARMADAS',
      'TRANSFORMACI√ìN MILITAR',
      'ORGANIZACI√ìN DE LAS FAS',
      'FUERZA CONJUNTA'
    ],
    
    // CAP√çTULO 3 - OPERACIONES
    'CAPITULO_3': [
      'OPERACIONES',
      'EL ESPACIO DE LAS OPERACIONES', 
      'EL ENTORNO OPERATIVO',
      'LOS ADVERSARIOS',
      'EL ESPECTRO DE LOS CONFLICTOS',
      'EMPLEO DE LA FUERZA EN OPERACIONES',
      'OPERACIONES MULTIDOMINIO'
    ],
    
    // CAP√çTULO 6 - T√ÅCTICAS
    'CAPITULO_6': [
      'INTRODUCCI√ìN',
      'ACCIONES MILITARES T√ÅCTICAS',
      'EL PLANEAMIENTO T√ÅCTICO DE LAS OPERACIONES',
      'LA EJECUCI√ìN T√ÅCTICA DE LAS OPERACIONES'
    ],
    
    // CAP√çTULO 7 - MANDO Y CONTROL
    'CAPITULO_7': [
      'INTRODUCCI√ìN',
      'FUNDAMENTOS DEL MANDO Y CONTROL EN OPERACIONES', 
      'ESTRUCTURAS DE MANDO Y CONTROL',
      'MANDO Y CONTROL EN MDO',
      'MANDO Y CONTROL EN OPERACIONES MULTINACIONALES'
    ]
  };

  /**
   * Extrae secciones espec√≠ficas para documentos PDC-01 B con numeraci√≥n jer√°rquica
   */
  static extractPDC01Sections(document: StoredDocument, config: ProcessingConfig): DocumentSection[] {
    this.log(LogLevel.INFO, 'Procesando documento PDC-01 B con apartados espec√≠ficos y numeraci√≥n jer√°rquica');
    
    const content = document.content;
    const apartados: DocumentSection[] = [];
    let globalOrder = 1;
    
    // Procesar cada cap√≠tulo
    for (const [capituloKey, apartadosCapitulo] of Object.entries(this.PDC_01_APARTADOS_JERARQUICOS)) {
      let numeroSeccion = 1;
      
      this.log(LogLevel.DEBUG, `Procesando ${capituloKey} con ${apartadosCapitulo.length} apartados`);
      
      for (const apartadoTitle of apartadosCapitulo) {
        // Buscar el apartado con m√∫ltiples patrones
        const patterns = [
          // Patr√≥n con n√∫mero al inicio: "1. ENTORNO GLOBAL DE SEGURIDAD"
          new RegExp(`^\\s*${numeroSeccion}\\.?\\s*${apartadoTitle.replace(/\s+/g, '\\s+')}`, 'gmi'),
          // Patr√≥n sin n√∫mero: "ENTORNO GLOBAL DE SEGURIDAD"
          new RegExp(`^\\s*${apartadoTitle.replace(/\s+/g, '\\s+')}\\s*$`, 'gmi'),
          // Patr√≥n m√°s flexible
          new RegExp(`${apartadoTitle.replace(/\s+/g, '\\s*').replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}`, 'gi'),
          // Patr√≥n en may√∫sculas
          new RegExp(apartadoTitle.toUpperCase().replace(/\s+/g, '\\s+'), 'gi')
        ];
        
        let found = false;
        let apartadoContent = '';
        
        for (let i = 0; i < patterns.length && !found; i++) {
          const pattern = patterns[i];
          // Reset regex state
          pattern.lastIndex = 0;
          const match = pattern.exec(content);
          
          if (match) {
            this.log(LogLevel.DEBUG, `‚úÖ Apartado encontrado: "${apartadoTitle}" con patr√≥n ${i + 1}`);
            
            // Determinar d√≥nde empieza y termina la secci√≥n
            const startPos = match.index;
            let endPos = content.length;
            
            // Buscar el siguiente apartado del mismo cap√≠tulo
            const nextApartadoIndex = apartadosCapitulo.indexOf(apartadoTitle) + 1;
            if (nextApartadoIndex < apartadosCapitulo.length) {
              const nextApartado = apartadosCapitulo[nextApartadoIndex];
              const nextPattern = new RegExp(`\\d*\\.?\\s*${nextApartado.replace(/\s+/g, '\\s+')}`, 'gi');
              const nextMatch = nextPattern.exec(content.substring(startPos + match[0].length));
              if (nextMatch) {
                endPos = startPos + match[0].length + nextMatch.index;
              }
            } else {
              // Si es el √∫ltimo apartado del cap√≠tulo, buscar el siguiente cap√≠tulo
              const nextCapituloPatterns = [
                /CAP√çTULO\s+\d+/gi,
                /^[IV]+\./gmi, // N√∫meros romanos
                /^\d+\.\s*[A-Z√Å√ë√ú]/gmi // Siguiente apartado numerado
              ];
              
              for (const nextCapPattern of nextCapituloPatterns) {
                nextCapPattern.lastIndex = 0;
                const nextCapMatch = nextCapPattern.exec(content.substring(startPos + match[0].length));
                if (nextCapMatch) {
                  endPos = Math.min(endPos, startPos + match[0].length + nextCapMatch.index);
                }
              }
            }
            
            apartadoContent = content.substring(startPos, endPos).trim();
            found = true;
          }
        }
        
        if (found && apartadoContent.length >= (config.options?.pdc01Doctrine?.minSectionLength || 200)) {
          // Crear t√≠tulo con numeraci√≥n jer√°rquica
          const tituloConNumero = `${numeroSeccion}. ${apartadoTitle}`;
          
          apartados.push({
            id: `${document.id}-pdc01-${globalOrder}`,
            documentId: document.id,
            title: tituloConNumero,
            content: apartadoContent,
            type: SectionType.MAIN_SECTION,
            order: globalOrder,
            processed: false,
            createdAt: new Date(),
            updatedAt: new Date()
          });
          
          this.log(LogLevel.DEBUG, `Apartado agregado: "${tituloConNumero}" con ${apartadoContent.length} caracteres`);
          globalOrder++;
        } else if (found) {
          this.log(LogLevel.DEBUG, `Apartado "${apartadoTitle}" muy corto: ${apartadoContent.length} caracteres`);
        } else {
          this.log(LogLevel.DEBUG, `‚ùå Apartado NO encontrado: "${apartadoTitle}"`);
        }
        
        numeroSeccion++;
      }
      
      // Reset numeraci√≥n para el siguiente cap√≠tulo
      numeroSeccion = 1;
    }
    
    this.log(LogLevel.INFO, `Encontrados ${apartados.length} apartados espec√≠ficos PDC-01 con numeraci√≥n jer√°rquica`);
    
    // Si no encuentra apartados espec√≠ficos, intentar m√©todo militar general
    if (apartados.length === 0) {
      this.log(LogLevel.WARN, 'No se encontraron apartados espec√≠ficos de PDC-01, usando m√©todo militar general');
      return this.extractMilitaryDoctrineSections(document, config);
    }
    
    return apartados;
  }

  /**
   * Detecta si un documento es espec√≠ficamente PDC-01 B Doctrina para el empleo de las FAS
   * MEJORADO: M√°s flexible y preciso
   */
  static detectPDC01Document(content: string): boolean {
    // Indicadores espec√≠ficos de PDC-01 (m√°s flexibles y espec√≠ficos)
    const pdc01Indicators = [
      /PDC[.\-\s]*01/gi,
      /Doctrina\s+para\s+el\s+empleo\s+de\s+las\s+FAS/gi,
      /ENTORNO\s+GLOBAL\s+DE\s+SEGURIDAD/gi,
      /CONTEXTO\s+DE\s+COMPETICI√ìN/gi,
      /EMPLEO\s+Y\s+MISIONES\s+DE\s+LAS\s+FUERZAS\s+ARMADAS/gi,
      /CAPACIDADES\s+MILITARES\s+DE\s+LAS\s+FUERZAS\s+ARMADAS/gi,
      /OPERACIONES\s+MULTIDOMINIO/gi,
      /MULTI[.\-\s]*DOMAIN\s+OPERATIONS/gi,
      /INSTRUMENTOS\s+DE\s+PODER/gi,
      /LA\s+SEGURIDAD\s+NACIONAL/gi,
      /LA\s+DEFENSA\s+NACIONAL/gi,
      /CONTRIBUCIONES\s+DE\s+LAS\s+FAS/gi,
      /FUNDAMENTOS\s+DEL\s+MANDO\s+Y\s+CONTROL/gi,
      /ESTRUCTURAS\s+DE\s+MANDO\s+Y\s+CONTROL/gi
    ];

    let indicatorCount = 0;
    const foundIndicators: string[] = [];
    
    for (const indicator of pdc01Indicators) {
      if (indicator.test(content)) {
        indicatorCount++;
        foundIndicators.push(indicator.source);
        this.log(LogLevel.DEBUG, `PDC-01 indicador encontrado: ${indicator.source}`);
      }
    }

    // ‚úÖ MEJORADO: Reducir a√∫n m√°s el umbral y agregar verificaci√≥n espec√≠fica
    const hasSpecificTitle = /PDC[.\-\s]*01.*Doctrina/gi.test(content);
    const hasKeyApartados = foundIndicators.length >= 3;
    
    const isDetected = hasSpecificTitle || indicatorCount >= 2;
    
    this.log(LogLevel.INFO, `PDC-01 detecci√≥n mejorada:`, {
      indicadores: indicatorCount,
      tituloEspecifico: hasSpecificTitle,
      apartadosClave: hasKeyApartados,
      resultado: isDetected ? 'DETECTADO' : 'NO DETECTADO',
      indicadoresEncontrados: foundIndicators
    });
    
    return isDetected;
  }

  /**
   * Configura autom√°ticamente el procesamiento para un documento PDC-01
   */
  static setupPDC01Processing(documentId: string): void {
    this.log(LogLevel.INFO, `Configurando procesamiento PDC-01 para documento: ${documentId}`);
    this.saveProcessingConfig(documentId, this.PDC_01_CONFIG);
  }
}
