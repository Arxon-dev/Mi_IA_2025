import { PrismaClient, Prisma } from '@prisma/client';
import type { 
  document, 
  section, 
  question, 
  config, 
  statistics, 
  bloomlevel, 
  prompt as PrismaPrompt,
  questionconfig,
  aiconfig as PrismaAIConfig
} from '@prisma/client';
import { prisma } from '@/lib/prisma';
import { AIConfig, AIConfigCreate, AIConfigUpdate, TextProcessingConfig, FormatConfig, FeedbackConfig, DistributionConfig, QuestionTypePercentages, DifficultyPercentages } from '../types/ai';
import { randomUUID } from 'crypto';

// Parser para SectionQuestion
interface ParsedSectionQuestion {
  question: string;
  options: string[];
  correctAnswerIndex: number;
  success: boolean;
  error?: string;
}

function parseSectionQuestionContent(content: string): ParsedSectionQuestion {
  try {
    // 1. Limpiar el contenido inicial
    let cleanContent = content;
    
    // Remover comentarios iniciales (// Pregunta X...)
    cleanContent = cleanContent.replace(/^\/\/[^\n]*\n/, '');
    
    // Remover HTML tags pero mantener el texto
    cleanContent = cleanContent.replace(/<[^>]*>/g, ' ');
    
    // Normalizar espacios
    cleanContent = cleanContent.replace(/\s+/g, ' ').trim();
    
    // 2. Extraer la pregunta principal
    let questionText = '';
    
    // Buscar donde empiezan las opciones (a), b), c), d) o A), B), C), D))
    const optionsPattern = /\s*[a-d]\)\s*/i;
    const optionsMatch = cleanContent.search(optionsPattern);
    
    if (optionsMatch > 0) {
      questionText = cleanContent.substring(0, optionsMatch).trim();
    } else {
      // Si no encuentra opciones con formato a), buscar otros patrones
      const alternativePattern = /\s*{\s*=/;
      const altMatch = cleanContent.search(alternativePattern);
      if (altMatch > 0) {
        questionText = cleanContent.substring(0, altMatch).trim();
      } else {
        // Como último recurso, tomar los primeros 200 caracteres
        questionText = cleanContent.substring(0, 200).trim();
      }
    }
    
    // 3. Extraer opciones
    const options: string[] = [];
    
    // Buscar patrones de opciones a), b), c), d)
    const optionMatches = cleanContent.match(/[a-d]\)\s*([^a-d\)]*?)(?=[a-d]\)|$)/gi);
    
    if (optionMatches && optionMatches.length > 0) {
      optionMatches.forEach(match => {
        // Limpiar la opción
        const option = match.replace(/^[a-d]\)\s*/i, '').trim();
        if (option.length > 0 && option.length < 200) { // Filtrar opciones muy largas
          options.push(option);
        }
      });
    }
    
    // Si no encontró opciones con el patrón a), crear opciones genéricas
    if (options.length === 0) {
      options.push('Verdadero', 'Falso');
    }
    
    // 4. Determinar respuesta correcta
    let correctAnswerIndex = 0;
    
    // Buscar indicadores de respuesta correcta {=...}
    const correctAnswerPattern = /{\s*=([^}]*?)}/;
    const correctMatch = cleanContent.match(correctAnswerPattern);
    
    if (correctMatch && options.length > 2) {
      const correctText = correctMatch[1].toLowerCase().trim();
      // Buscar en las opciones cual coincide mejor
      for (let i = 0; i < options.length; i++) {
        if (options[i].toLowerCase().includes(correctText.substring(0, 20))) {
          correctAnswerIndex = i;
          break;
        }
      }
    }
    
    // 5. Validar resultado
    if (questionText.length === 0) {
      return {
        question: '',
        options: [],
        correctAnswerIndex: 0,
        success: false,
        error: 'No se pudo extraer la pregunta'
      };
    }
    
    // Verificar longitud para Telegram (con prefijo)
    const telegramFormat = `🧪 PRUEBA SECTIONQUESTION\n\n${questionText}`;
    if (telegramFormat.length > 300) {
      // Truncar la pregunta para que quepa
      const maxQuestionLength = 300 - 35; // 35 chars para el prefijo
      questionText = questionText.substring(0, maxQuestionLength - 3) + '...';
    }
    
    return {
      question: questionText,
      options: options.length > 0 ? options : ['Verdadero', 'Falso'],
      correctAnswerIndex,
      success: true
    };
    
  } catch (error) {
    return {
      question: '',
      options: [],
      correctAnswerIndex: 0,
      success: false,
      error: `Error al parsear: ${error}`
    };
  }
}

interface AIFeatures {
  id: string;
  conceptTrap: boolean;
  precisionDistractors: boolean;
  createdAt: Date;
  updatedAt: Date;
}

interface DocumentProgress {
  id: string;
  documentId: string;
  totalSections: number;
  processedSections: number;
  status: string;
  createdAt: Date;
  updatedAt: Date;
}

interface Prompt {
  id: string;
  name: string;
  content: string;
  file: string;
  createdAt: Date;
  updatedAt: Date;
}

// Interfaz para preguntas programables del Telegram
interface SchedulableQuestion {
  id: string;
  content: string;
  type: string;
  difficulty: string;
  bloomLevel: string | null;
  sourceModel: 'document' | 'section' | 'validQuestion' | 'examenOficial2018' | 'examenOficial2024' | 'sectionQuestion';
  lastScheduledSendAt: Date | null;
  sendCount: number;
  lastSuccessfulSendAt: Date | null;
}

// Tipo personalizado para los resultados de Prisma con providerKeys incluidos
type PrismaAIConfigResult = {
  id: string;
  createdat: Date;
  updatedat: Date;
  provider: string;
  model: string;
  apikey?: string | null;  // Cambio: hago apiKey opcional
  temperature: number | null;
  maxtokens: number | null;
  questionsperchunk: number | null;
  systemprompt: string | null;
  textprocessing: string | null;
  format: string | null;
  feedback: string | null;
  distribution: string | null;
  questiontypes: string | null;
  difficultylevels: string | null;
  telegramschedulerenabled: boolean | null;
  telegramschedulerfrequency: string | null;
  telegramschedulerquantity: number | null;
  telegramschedulerlastrun: Date | null;
  telegramschedulerstarthour: number | null;
  telegramschedulerendhour: number | null;
  telegramschedulerstartminute: number | null;
  telegramschedulerendminute: number | null;
  telegram_chat_id: string | null;
  providerKeys?: {
    id: string;
    createdat: Date;
    updatedat: Date;
    provider: string;
    apiKey: string;
    aiconfigid: string;
  }[];
};

// Tipo para los datos de entrada de Prisma
type PrismaAIConfigInput = {
  provider?: string;
  model?: string;
  apiKey?: string | null;
  temperature?: number | null;
  maxTokens?: number | null;
  systemPrompt?: string | null;
  textProcessing?: string | null;
  format?: string | null;
  feedback?: string | null;
  distribution?: string | null;
  questionTypes?: string | null;
  difficultyLevels?: string | null;
};

export class PrismaService {

  private static async handlePrismaError<T>(error: any, operation: string): Promise<T> {
    console.error(`Error en operación ${operation}:`, {
      error: error instanceof Error ? error.message : String(error),
      code: error?.code,
      meta: error?.meta,
      details: error?.details,
      hint: error?.hint
    });

    // Errores específicos de Supabase/PostgreSQL
    if (error?.code) {
      switch (error.code) {
        case 'P2002': // Unique constraint violation
          throw new Error(`Error de restricción única en ${error?.meta?.target}`);
        case 'P2025': // Record not found
          throw new Error('Registro no encontrado');
        case 'P2021': // Table does not exist
          throw new Error('La tabla no existe');
        case '42P01': // Undefined table
          throw new Error('Tabla no definida en la base de datos');
        case '23505': // Unique violation
          throw new Error('Violación de restricción única');
        case '23503': // Foreign key violation
          throw new Error('Violación de clave foránea');
        default:
          if (error.code.startsWith('P')) { // Errores de Prisma
            throw new Error(`Error de Prisma: ${error.message}`);
          } else { // Errores de PostgreSQL
            throw new Error(`Error de base de datos: ${error.message}`);
          }
      }
    }

    // Para errores de conexión
    if (error?.errorCode) {
      console.error('Error de conexión a Supabase:', {
        errorCode: error.errorCode,
        message: error.message,
        database_url: process.env.DATABASE_URL?.replace(/:[^:@]+@/, ':****@')
      });
      throw new Error('Error de conexión a la base de datos');
    }

    // Error genérico
    throw new Error(`Error en la operación ${operation}: ${error instanceof Error ? error.message : String(error)}`);
  }

  // Documents
  static async getDocuments(): Promise<document[]> {
    try {
      console.log('Obteniendo todos los documentos');
      const documents = await prisma.document.findMany({
        // Elimino include ya que no está disponible en MySQL
      });
      console.log(`Encontrados ${documents.length} documentos`);
      return documents;
    } catch (error) {
      throw this.handlePrismaError<document[]>(error, 'getDocuments');
    }
  }

  static async getDocumentById(id: string): Promise<document | null> {
    try {
      console.log('Buscando documento con ID:', id);
      const document = await prisma.document.findUnique({
        where: { id },
        // Elimino include ya que no está disponible en MySQL
      });
      
      if (!document) {
        console.log('No se encontró el documento:', id);
        return null;
      }
      
      console.log('Documento encontrado:', document.id);
      return document;
    } catch (error) {
      return this.handlePrismaError<document | null>(error, 'getDocumentById');
    }
  }

  static async saveDocument(document: Omit<document, 'createdat' | 'updatedat'> & { sections?: section[], questions?: question[] }): Promise<document> {
    try {
      console.log('Iniciando guardado de documento:', {
        id: document.id,
        title: document.title,
        contentLength: document.content.length
      });

      // Usar una transacción para asegurar la consistencia
      return await prisma.$transaction(async (tx) => {
        // Guardar o actualizar el documento principal
        const savedDoc = await tx.document.upsert({
          where: { id: document.id },
          update: {
            title: document.title,
            content: document.content,
            date: document.date,
            type: document.type,
            questioncount: document.questioncount || 0,
            updatedat: new Date()
          },
          create: {
            id: document.id,
            title: document.title,
            content: document.content,
            date: document.date,
            type: document.type,
            questioncount: document.questioncount || 0
          }
        });

        console.log('Documento base guardado:', {
          id: savedDoc.id,
          title: savedDoc.title
        });

        // Si hay secciones, actualizarlas de forma segura
        if (document.sections?.length) {
          console.log(`Procesando ${document.sections.length} secciones...`);
          
          // Obtener secciones actuales para comparar
          const currentSections = await tx.section.findMany({
            where: { documentid: savedDoc.id },
            select: { id: true, title: true, order: true }
          });
          
          // Verificar si las secciones han cambiado realmente
          const newSectionIds = new Set(document.sections.map(s => s.id));
          const currentSectionIds = new Set(currentSections.map(s => s.id));
          
          const sectionsChanged = currentSections.length !== document.sections.length ||
            !currentSections.every(s => newSectionIds.has(s.id));
          
          if (sectionsChanged) {
            console.log('🔄 Secciones han cambiado, actualizando...');
            // Eliminar secciones existentes solo si han cambiado
            await tx.section.deleteMany({
              where: { documentid: savedDoc.id }
            });

            // Crear nuevas secciones en lotes
            for (let i = 0; i < document.sections.length; i += 100) {
              const batch = document.sections.slice(i, i + 100);
              await tx.section.createMany({
                data: batch.map(section => ({
                  id: section.id,
                  documentid: savedDoc.id,
                  title: section.title,
                  content: section.content,
                  type: section.type,
                  order: section.order,
                  processed: section.processed || false
                }))
              });
            }
          } else {
            console.log('✅ Secciones sin cambios, conservando preguntas de sección...');
            // No eliminar secciones si no han cambiado, preservando las SectionQuestion
          }
        }

        // Si hay preguntas, actualizarlas
        if (document.questions?.length) {
          console.log(`Procesando ${document.questions.length} preguntas...`);
          
          // Eliminar preguntas existentes
          await tx.question.deleteMany({
            where: { documentid: savedDoc.id }
          });

          // Crear nuevas preguntas en lotes
          for (let i = 0; i < document.questions.length; i += 100) {
            const batch = document.questions.slice(i, i + 100);
            await tx.question.createMany({
              data: batch.map(question => ({
                id: question.id,
                documentid: savedDoc.id,
                content: question.content,
                type: question.type,
                difficulty: question.difficulty,
                bloomlevel: question.bloomlevel
              }))
            });
          }
        }

        // Obtener el documento actualizado
        const finalDoc = await tx.document.findUnique({
          where: { id: savedDoc.id }
        });

        if (!finalDoc) {
          throw new Error(`No se pudo encontrar el documento después de guardarlo: ${savedDoc.id}`);
        }

        console.log('Documento guardado exitosamente con todas sus relaciones');
        return finalDoc;
      }, {
        timeout: 60000
      });
    } catch (error: any) {
      return this.handlePrismaError<document>(error, 'saveDocument');
    }
  }

  static async deleteDocument(id: string): Promise<void> {
    await prisma.document.delete({
      where: { id },
    });
  }

  // Sections
  static async getSections(documentId: string): Promise<section[]> {
    return prisma.section.findMany({
      where: { documentid: documentId },
      orderBy: { order: 'asc' },
    });
  }

  static async saveSection(section: Omit<section, 'createdat' | 'updatedat'>): Promise<section> {
    return prisma.section.upsert({
      where: { id: section.id },
      update: section,
      create: section,
    });
  }

  // Questions
  static async getQuestions(documentId: string): Promise<question[]> {
    return prisma.question.findMany({
      where: { documentid: documentId },
    });
  }

  static async getRecentQuestions(quantity: number): Promise<question[]> {
    try {
      console.log(`🔍 PrismaService: Obteniendo ${quantity} preguntas recientes`);
      const questions = await prisma.question.findMany({
        take: quantity,
        orderBy: {
          createdat: 'desc', // Asume que tienes un campo createdAt en tu modelo Question
        },
      });
      console.log(`✅ PrismaService: ${questions.length} preguntas recientes encontradas`);
      return questions as question[];
    } catch (error) {
      console.error('❌ PrismaService: Error al obtener preguntas recientes:', error);
      return this.handlePrismaError<question[]>(error, 'getRecentQuestions');
    }
  }

  static async saveQuestion(question: Omit<question, 'createdat'>): Promise<question> {
    return prisma.question.create({
      data: question,
    });
  }

  // Config
  static async getConfig(key: string): Promise<string | null> {
    const config = await prisma.config.findUnique({
      where: { key },
    });
    return config?.value ?? null;
  }

  static async saveConfig(key: string, value: string): Promise<void> {
    await prisma.config.upsert({
      where: { key },
      update: { value, updatedat: new Date() },
      create: { 
        id: randomUUID(),
        key, 
        value,
        createdat: new Date(),
        updatedat: new Date()
      },
    });
  }

  // Statistics
  static async getStats(): Promise<statistics | null> {
    return prisma.statistics.findFirst();
  }

  static async updateStats(stats: Partial<statistics>): Promise<void> {
    const currentStats = await this.getStats();
    if (currentStats) {
      await prisma.statistics.update({
        where: { id: currentStats.id },
        data: { ...stats, updatedat: new Date() },
      });
    } else {
      await prisma.statistics.create({
        data: {
          id: randomUUID(),
          processeddocs: stats.processeddocs ?? 0,
          generatedquestions: stats.generatedquestions ?? 0,
          bloomaverage: stats.bloomaverage ?? 0,
          savedtime: stats.savedtime ?? 0,
          createdat: new Date(),
          updatedat: new Date(),
        },
      });
    }
  }

  // Bloom Levels
  static async getBloomLevels(): Promise<bloomlevel[]> {
    return prisma.bloomlevel.findMany({
      orderBy: { createdat: 'asc' },
    });
  }

  static async saveBloomLevel(level: Omit<bloomlevel, 'id' | 'createdat' | 'updatedat'>): Promise<bloomlevel> {
    return prisma.bloomlevel.create({
      data: {
        id: randomUUID(),
        ...level,
        createdat: new Date(),
        updatedat: new Date()
      },
    });
  }

  // Obtener la API key de un proveedor para una configuración
  static async getProviderApiKey(aiConfigId: string, provider: string): Promise<string | null> {
    try {
      const key = await prisma.aiproviderkey.findFirst({
        where: { aiconfigid: aiConfigId, provider },
      });
      return key?.apikey || null;
    } catch (error) {
      throw this.handlePrismaError<string | null>(error, 'getProviderApiKey');
    }
  }

  /**
   * Guarda una API key para un proveedor específico en la base de datos
   * @param aiConfigId ID de la configuración de IA
   * @param provider Proveedor (openai, google, anthropic, etc.)
   * @param apiKey API key a guardar
   * @returns Promise<boolean> Indica si la operación fue exitosa
   */
  static async setProviderApiKey(
    aiConfigId: string,
    provider: string,
    apiKey: string
  ): Promise<boolean> {
    try {
      console.log(`💾 PrismaService.setProviderApiKey: Guardando API key para ${provider}`);
      
      // Verificar si ya existe una entrada para este proveedor
      const existingKey = await prisma.aiproviderkey.findFirst({
        where: {
          aiconfigid: aiConfigId,
          provider
        }
      });
      
      if (existingKey) {
        // Actualizar la API key existente
        console.log(`🔄 Actualizando API key existente para ${provider}`);
        await prisma.aiproviderkey.update({
          where: {
            id: existingKey.id
          },
          data: {
            apikey: apiKey,
            updatedat: new Date()
          }
        });
      } else {
        // Crear una nueva entrada para esta API key
        console.log(`➕ Creando nueva API key para ${provider}`);
        await prisma.aiproviderkey.create({
          data: {
            id: aiConfigId + '_' + provider + '_' + Date.now(),
            aiconfigid: aiConfigId,
            provider,
            apikey: apiKey,
            createdat: new Date(),
            updatedat: new Date()
          }
        });
      }
      
      console.log(`✅ API key para ${provider} guardada exitosamente`);
      return true;
    } catch (error) {
      console.error(`❌ Error guardando API key para ${provider}:`, error);
      throw this.handlePrismaError<boolean>(error, 'setProviderApiKey');
    }
  }

  // Obtener la configuración de IA actual
  static async getAIConfig(): Promise<AIConfig | null> {
    try {
      const configFromDb = await prisma.aiconfig.findFirst();
      if (!configFromDb) {
        // Si no existe configuración, crear una por defecto
        return this.createAIConfig({
          provider: 'openai',
          model: 'gpt-3.5-turbo',
          temperature: 0.7,
          maxTokens: 2000,
          systemPrompt: 'Eres un asistente experto en generar preguntas.',
          textProcessing: {} as TextProcessingConfig,
          format: {} as FormatConfig,
          feedback: {} as FeedbackConfig,
          distribution: {} as DistributionConfig,
          questionTypes: {} as QuestionTypePercentages,
          difficultyLevels: {} as DifficultyPercentages
        });
      }
      // Transformar primero, luego añadir/determinar la apiKey activa
      const transformedConfig = this.transformPrismaConfig(configFromDb as unknown as PrismaAIConfigResult);
      // Lógica para determinar la apiKey activa (puede permanecer o ajustarse)
      // Buscar provider key por separado
      const providerKey = await prisma.aiproviderkey.findFirst({
        where: { 
          provider: configFromDb.provider 
        }
      });
      let activeApiKey = providerKey?.apikey || null;
      if (!activeApiKey) {
        const envKeys: Record<string, string | undefined> = {
          openai: process.env.NEXT_PUBLIC_GPT_API_KEY,
          google: process.env.NEXT_PUBLIC_GEMINI_API_KEY,
          anthropic: process.env.NEXT_PUBLIC_ANTHROPIC_API_KEY,
          deepseek: process.env.NEXT_PUBLIC_DEEPSEEK_API_KEY,
          xai: process.env.NEXT_PUBLIC_GROK_API_KEY || process.env.NEXT_PUBLIC_XAI_API_KEY,
          alibaba: process.env.NEXT_PUBLIC_QWEN_API_KEY
        };
        activeApiKey = envKeys[configFromDb.provider] || null;
      }
      return {
        ...transformedConfig,
        apiKey: activeApiKey,
        telegramSchedulerStartHour: configFromDb.telegramschedulerstarthour,
        telegramSchedulerStartMinute: configFromDb.telegramschedulerstartminute,
        telegramSchedulerEndHour: configFromDb.telegramschedulerendhour,
        telegramSchedulerEndMinute: configFromDb.telegramschedulerendminute,
        telegramChatId: configFromDb.telegram_chat_id,
      };
    } catch (error) {
      throw this.handlePrismaError<AIConfig | null>(error, 'getAIConfig');
    }
  }

  static async createAIConfig(data: AIConfigCreate): Promise<AIConfig> {
    try {
      const createDataPrisma: any = {
        provider: data.provider,
        model: data.model,
        temperature: data.temperature ?? null,
        maxtokens: data.maxTokens ?? null,
        questionsperchunk: data.questionsPerChunk ?? null,
        systemprompt: data.systemPrompt ?? null,
        textprocessing: data.textProcessing ? JSON.stringify(data.textProcessing) : null,
        format: data.format ? JSON.stringify(data.format) : null,
        feedback: data.feedback ? JSON.stringify(data.feedback) : null,
        distribution: data.distribution ? JSON.stringify(data.distribution) : null,
        questiontypes: data.questionTypes ? JSON.stringify(data.questionTypes) : null,
        difficultylevels: data.difficultyLevels ? JSON.stringify(data.difficultyLevels) : null,
        telegramschedulerenabled: data.telegramSchedulerEnabled ?? false,
        telegramschedulerfrequency: data.telegramSchedulerFrequency ?? "DAILY_MIDNIGHT_UTC",
        telegramschedulerquantity: data.telegramSchedulerQuantity ?? 1,
        telegramschedulerstarthour: data.telegramSchedulerStartHour,
        telegramschedulerstartminute: data.telegramSchedulerStartMinute,
        telegramschedulerendhour: data.telegramSchedulerEndHour,
        telegramschedulerendminute: data.telegramSchedulerEndMinute,
        telegram_chat_id: data.telegramChatId ?? null,
      };
      const resultFromDb = await prisma.aiconfig.create({
        data: createDataPrisma
      });
      return this.transformPrismaConfig(resultFromDb as unknown as PrismaAIConfigResult);
    } catch (error) {
      return this.handlePrismaError<AIConfig>(error, 'createAIConfig');
    }
  }

  static async updateAIConfig(id: string, data: AIConfigUpdate): Promise<AIConfig> {
    try {
      const updateDataPrisma: any = {
        provider: data.provider,
        model: data.model,
        temperature: data.temperature,
        maxtokens: data.maxTokens,
        questionsperchunk: data.questionsPerChunk,
        systemprompt: data.systemPrompt,
        textprocessing: data.textProcessing ? JSON.stringify(data.textProcessing) : undefined,
        format: data.format ? JSON.stringify(data.format) : undefined,
        feedback: data.feedback ? JSON.stringify(data.feedback) : undefined,
        distribution: data.distribution ? JSON.stringify(data.distribution) : undefined,
        questiontypes: data.questionTypes ? JSON.stringify(data.questionTypes) : undefined,
        difficultylevels: data.difficultyLevels ? JSON.stringify(data.difficultyLevels) : undefined,
        telegramschedulerenabled: data.telegramSchedulerEnabled,
        telegramschedulerfrequency: data.telegramSchedulerFrequency,
        telegramschedulerquantity: data.telegramSchedulerQuantity,
        telegramschedulerstarthour: data.telegramSchedulerStartHour,
        telegramschedulerstartminute: data.telegramSchedulerStartMinute,
        telegramschedulerendhour: data.telegramSchedulerEndHour,
        telegramschedulerendminute: data.telegramSchedulerEndMinute,
        telegram_chat_id: data.telegramChatId,
      };
      Object.keys(updateDataPrisma).forEach(key => {
        const k = key as keyof Prisma.aiconfigUpdateInput;
        if (updateDataPrisma[k] === undefined) delete updateDataPrisma[k];
      });
      const resultFromDb = await prisma.aiconfig.update({
        where: { id },
        data: updateDataPrisma
      });
      return this.transformPrismaConfig(resultFromDb as unknown as PrismaAIConfigResult);
    } catch (error) {
      return this.handlePrismaError<AIConfig>(error, 'updateAIConfig');
    }
  }

  static async saveAIConfig(data: Partial<AIConfig>): Promise<AIConfig> {
    console.log('💾 PrismaService.saveAIConfig: Configuración recibida:', {
      id: data.id,
      provider: data.provider,
      model: data.model,
      temperature: data.temperature,
      maxTokens: data.maxTokens,
      apiKey: data.apiKey ? '[REDACTED]' : null
    });

    // Añadir log específico para telegramSchedulerQuantity
    if ('telegramSchedulerQuantity' in data) {
      console.log('🔢 PrismaService.saveAIConfig: Valor de telegramSchedulerQuantity:', {
        value: data.telegramSchedulerQuantity,
        type: typeof data.telegramSchedulerQuantity,
        isNumber: !isNaN(Number(data.telegramSchedulerQuantity))
      });
    }

    console.log('💾 PrismaService.saveAIConfig: Datos importantes para Prisma:', {
      provider: data.provider,
      model: data.model,
      temperature: data.temperature,
      maxTokens: data.maxTokens
    });

    // Función para asegurar que los campos JSON se serialicen correctamente (una sola vez)
    const safeJsonStringify = (value: any): string | null => {
      if (value === null || value === undefined) {
        return null;
      }
      
      // Si ya es un string, verificar si parece ser JSON
      if (typeof value === 'string') {
        try {
          // Intenta parsear para ver si es JSON válido
          JSON.parse(value);
          // Si se pudo parsear, es un string que ya contiene JSON, devolverlo tal cual
          return value;
        } catch (e) {
          // No es JSON, así que serializarlo
          return JSON.stringify(value);
        }
      }
      
      // Si es un objeto, serializarlo
      return JSON.stringify(value);
    };

    // Preparar datos para guardar, asegurando que los campos JSON no se serialicen múltiples veces
    const jsonFields = {
      questionTypes: data.questionTypes ? safeJsonStringify(data.questionTypes) : undefined,
      difficultyLevels: data.difficultyLevels ? safeJsonStringify(data.difficultyLevels) : undefined,
      textProcessing: data.textProcessing ? safeJsonStringify(data.textProcessing) : undefined,
      format: data.format ? safeJsonStringify(data.format) : undefined,
      feedback: data.feedback ? safeJsonStringify(data.feedback) : undefined,
      distribution: data.distribution ? safeJsonStringify(data.distribution) : undefined,
    };

    // Remover campos que no se deben pasar a Prisma directamente
    const { apiKey, providerKeys, ...otherFields } = data;
    
    // Asegurar que los campos numéricos se mantengan como números
    const numericFields = {
      telegramSchedulerQuantity: data.telegramSchedulerQuantity !== undefined 
        ? Number(data.telegramSchedulerQuantity) 
        : undefined,
      maxTokens: data.maxTokens !== undefined 
        ? Number(data.maxTokens) 
        : undefined,
      temperature: data.temperature !== undefined 
        ? Number(data.temperature) 
        : undefined,
    };
    
    // Combinar campos normales con campos JSON procesados y campos numéricos
    const dataToSave = {
      ...otherFields,
      ...jsonFields,
      ...numericFields
    };

    console.log('📊 PrismaService.saveAIConfig: Datos finales a guardar:', {
      telegramSchedulerQuantity: dataToSave.telegramSchedulerQuantity,
      telegramSchedulerQuantityType: typeof dataToSave.telegramSchedulerQuantity
    });

    try {
      const prisma = new PrismaClient();
      
      // Verificar si la configuración ya existe
      const existingConfig = await prisma.aiconfig.findFirst();
      
      if (existingConfig) {
        // Si existe, actualizar
        console.log(`💾 PrismaService.saveAIConfig: Actualizando config ID: ${existingConfig.id}`);
        
        // Si se proporciona una API key, manejarla por separado
        if (apiKey) {
          console.log(`🔑 PrismaService.saveAIConfig: Guardando API key para proveedor ${data.provider}`);
          await this.setProviderApiKey(existingConfig.id, data.provider || existingConfig.provider, apiKey);
        }
        
        // Actualizar configuración
        console.log('🔄 PrismaService.saveAIConfig: Datos finales para actualización:', {
          provider: dataToSave.provider,
          model: dataToSave.model,
          temperature: dataToSave.temperature,
          maxTokens: dataToSave.maxTokens
        });
        
        const updatedConfig = await prisma.aiconfig.update({
          where: { id: existingConfig.id },
          data: {
            ...dataToSave,
            updatedat: new Date()
          }
        });
        
        await prisma.$disconnect();
        
        console.log(`✅ PrismaService.saveAIConfig: Actualización completada: { provider: '${updatedConfig.provider}', model: '${updatedConfig.model}' }`);

        // Transformar los datos para el cliente
        const transformedConfig = this.transformPrismaConfig(updatedConfig);
        console.log('🔄 PrismaService.saveAIConfig: Configuración transformada y retornada:', {
          provider: transformedConfig.provider,
          model: transformedConfig.model,
          maxTokens: transformedConfig.maxTokens,
          temperature: transformedConfig.temperature
        });

        return transformedConfig;
      } else {
        // Crear una nueva configuración si no existe
        console.log('➕ PrismaService.saveAIConfig: Creando nueva configuración');

        // Preparar los datos para la creación - asegurar que provider no sea undefined
        const createData = {
          id: randomUUID(),
          ...dataToSave,
          provider: dataToSave.provider || 'openai', // Valor por defecto si es undefined
          model: dataToSave.model || 'gpt-3.5-turbo', // Valor por defecto si es undefined
          createdat: new Date(),
          updatedat: new Date()
        };

        // Crear la configuración
        const newConfig = await prisma.aiconfig.create({
          data: createData,
        });

        // Si se proporciona una API key, guardarla
        if (apiKey && data.provider) {
          await this.setProviderApiKey(newConfig.id, data.provider, apiKey);
        }

        await prisma.$disconnect();

        console.log(`✅ PrismaService.saveAIConfig: Creación completada: { provider: '${newConfig.provider}', model: '${newConfig.model}' }`);

        // Transformar los datos para el cliente
        return this.transformPrismaConfig({
          ...newConfig,
          providerKeys: [] // No tiene claves aún excepto la que se acaba de agregar posiblemente
        });
      }
    } catch (error) {
      console.error('❌ PrismaService.saveAIConfig: Error al guardar la configuración:', error);
      throw this.handlePrismaError<AIConfig>(error, 'saveAIConfig');
    }
  }

  private static transformPrismaConfig(configFromDb: PrismaAIConfigResult): AIConfig {
    // Función auxiliar para parsear JSON de manera segura
    const safeJsonParse = (jsonString: string | null | undefined, fieldName: string = 'unknown'): any => {
      if (!jsonString) return undefined;
      
      try {
        // Log para depuración
        console.log(`🔍 Parsing ${fieldName}:`, {
          length: jsonString.length,
          preview: jsonString.substring(0, 50),
          startsWithBrace: jsonString.trim().startsWith('{'),
          endsWithBrace: jsonString.trim().endsWith('}')
        });
        
        // Verificar que la cadena parezca JSON válido
        const trimmed = jsonString.trim();
        if (!trimmed.startsWith('{') || !trimmed.endsWith('}')) {
          console.warn(`⚠️ Campo ${fieldName} no es JSON válido, ignorando: ${trimmed.substring(0, 100)}...`);
          return undefined;
        }
        
        // Verificar específicamente el texto problemático "comprehensive"
        if (trimmed.includes('comprehensive') && !trimmed.startsWith('{"')) {
          console.warn(`⚠️ Campo ${fieldName} contiene texto plano "comprehensive", ignorando`);
          return undefined;
        }
        
        const parsed = JSON.parse(trimmed);
        console.log(`✅ Campo ${fieldName} parseado correctamente`);
        return parsed;
      } catch (error) {
        console.error(`❌ Error parsing JSON field ${fieldName}: ${jsonString.substring(0, 100)}...`, error);
        return undefined;
      }
    };

    console.log(`🔄 Transforming PrismaConfig for ID: ${configFromDb.id}`);

    const transformed = {
      id: configFromDb.id,
      createdAt: configFromDb.createdat,
      updatedAt: configFromDb.updatedat,
      provider: configFromDb.provider,
      model: configFromDb.model,
      apiKey: configFromDb.apikey,
      temperature: configFromDb.temperature,
      maxTokens: configFromDb.maxtokens,
      questionsPerChunk: configFromDb.questionsperchunk,
      systemPrompt: configFromDb.systemprompt,
      textProcessing: safeJsonParse(configFromDb.textprocessing, 'textProcessing'),
      format: safeJsonParse(configFromDb.format, 'format'),
      feedback: safeJsonParse(configFromDb.feedback, 'feedback'),
      distribution: safeJsonParse(configFromDb.distribution, 'distribution'),
      questionTypes: safeJsonParse(configFromDb.questiontypes, 'questionTypes'),
      difficultyLevels: safeJsonParse(configFromDb.difficultylevels, 'difficultyLevels'),
      telegramSchedulerEnabled: configFromDb.telegramschedulerenabled,
      telegramChatId: configFromDb.telegram_chat_id,
      telegramSchedulerFrequency: configFromDb.telegramschedulerfrequency,
      telegramSchedulerQuantity: configFromDb.telegramschedulerquantity,
      telegramSchedulerLastRun: configFromDb.telegramschedulerlastrun,
      telegramSchedulerStartHour: configFromDb.telegramschedulerstarthour,
      telegramSchedulerStartMinute: configFromDb.telegramschedulerstartminute,
      telegramSchedulerEndHour: configFromDb.telegramschedulerendhour,
      telegramSchedulerEndMinute: configFromDb.telegramschedulerendminute,
      providerKeys: configFromDb.providerKeys?.map(pk => ({
        id: pk.id,
        provider: pk.provider,
        apiKey: pk.apiKey,
      })),
    } as AIConfig;
    
    console.log(`✅ Transformación completada para config ID: ${configFromDb.id}`);
    return transformed;
  }

  // Migrar API keys del .env a la base de datos
  static async migrateEnvApiKeysToProviderKeys(): Promise<void> {
    try {
      const config = await prisma.aiconfig.findFirst();
      if (!config) return;

      // Lista de proveedores y sus variables de entorno correspondientes
      const providers = [
        { name: 'openai', envVar: 'OPENAI_API_KEY' },
        { name: 'google', envVar: 'GOOGLE_API_KEY' },
        { name: 'anthropic', envVar: 'ANTHROPIC_API_KEY' },
        { name: 'perplexity', envVar: 'PERPLEXITY_API_KEY' },
        { name: 'mistral', envVar: 'MISTRAL_API_KEY' },
        { name: 'azure', envVar: 'AZURE_OPENAI_API_KEY' },
        { name: 'openrouter', envVar: 'OPENROUTER_API_KEY' },
        { name: 'xai', envVar: 'XAI_API_KEY' },
        { name: 'ollama', envVar: 'OLLAMA_API_KEY' },
      ];

      for (const provider of providers) {
        const apiKey = process.env[provider.envVar];
        if (apiKey) {
          const existing = await prisma.aiproviderkey.findFirst({
            where: { aiconfigid: config.id, provider: provider.name },
          });

          if (!existing) {
            await prisma.aiproviderkey.create({
              data: {
                id: randomUUID(),
                aiconfigid: config.id,
                provider: provider.name,
                apikey: apiKey,
                createdat: new Date(),
                updatedat: new Date(),
              },
            });
          }
        }
      }
    } catch (error) {
      console.error('Error migrando API keys:', error);
    }
  }

  // Obtener características de IA
  static async getAIFeatures(): Promise<AIFeatures | null> {
    try {
      let features = await prisma.aifeatures.findFirst();
      if (!features) {
        // Crear características por defecto si no existen
        features = await prisma.aifeatures.create({
          data: {
            id: randomUUID(),
            concepttrap: false,
            precisiondistractors: false,
            createdat: new Date(),
            updatedat: new Date(),
          },
        });
      }
      return {
        id: features.id,
        conceptTrap: features.concepttrap,
        precisionDistractors: features.precisiondistractors,
        createdAt: features.createdat,
        updatedAt: features.updatedat,
      };
    } catch (error) {
      throw this.handlePrismaError<AIFeatures | null>(error, 'getAIFeatures');
    }
  }

  // Guardar características de IA
  static async saveAIFeatures(data: { conceptTrap: boolean; precisionDistractors: boolean }): Promise<AIFeatures> {
    try {
      const existingFeatures = await prisma.aifeatures.findFirst();
      if (existingFeatures) {
        return prisma.aifeatures.update({
          where: { id: existingFeatures.id },
          data: {
            concepttrap: data.conceptTrap,
            precisiondistractors: data.precisionDistractors,
            updatedat: new Date(),
          },
        }).then(result => ({
          id: result.id,
          conceptTrap: result.concepttrap,
          precisionDistractors: result.precisiondistractors,
          createdAt: result.createdat,
          updatedAt: result.updatedat,
        }));
      } else {
        return prisma.aifeatures.create({
          data: {
            id: randomUUID(),
            concepttrap: data.conceptTrap,
            precisiondistractors: data.precisionDistractors,
            createdat: new Date(),
            updatedat: new Date(),
          },
        }).then(result => ({
          id: result.id,
          conceptTrap: result.concepttrap,
          precisionDistractors: result.precisiondistractors,
          createdAt: result.createdat,
          updatedAt: result.updatedat,
        }));
      }
    } catch (error) {
      throw this.handlePrismaError<AIFeatures>(error, 'saveAIFeatures');
    }
  }

  // Prompts
  static async getAllPrompts(): Promise<PrismaPrompt[]> {
    try {
      console.log('🔍 PrismaService: Obteniendo todos los prompts');
      const prompts = await prisma.prompt.findMany();
      console.log(`✅ PrismaService: ${prompts.length} prompts encontrados`);
      return prompts;
    } catch (error) {
      console.error('❌ PrismaService: Error al obtener los prompts:', error);
      return this.handlePrismaError<PrismaPrompt[]>(error, 'getAllPrompts');
    }
  }

  static async getPrompt(fileName: string): Promise<PrismaPrompt | null> {
    try {
      console.log(`Buscando prompt en BD con file: ${fileName}`);
      const prompt = await prisma.prompt.findUnique({
        where: { file: fileName },
      });
      
      if (!prompt) {
        console.log(`No se encontró el prompt en BD con file: ${fileName}`);
        return null;
      }
      
      console.log(`Prompt encontrado en BD: ${prompt.name} (file: ${prompt.file})`);
      return prompt;
    } catch (error) {
      console.error(`Error en PrismaService.getPrompt para file ${fileName}:`, error);
      // Devolvemos null para ser consistentes con otros métodos get...ById que pueden no encontrar un registro.
      // Opcionalmente, podrías usar this.handlePrismaError si tienes una forma estandarizada de manejar "no encontrado" vs otros errores.
      return null; 
    }
  }

  static async updatePrompt(file: string, data: { name: string; content: string; file: string }): Promise<PrismaPrompt> {
    try {
      console.log('💾 PrismaService: Intentando actualizar/crear prompt:', {
        file: data.file,
        name: data.name,
      });

      const prompt = await prisma.prompt.upsert({
        where: {
          file: file,
        },
        update: {
          name: data.name,
          content: data.content,
          updatedat: new Date(),
        },
        create: {
          id: randomUUID(),
          name: data.name,
          content: data.content,
          file: data.file,
          createdat: new Date(),
          updatedat: new Date(),
        },
      });
      
      console.log('✅ PrismaService: Prompt guardado exitosamente:', {
        id: prompt.id,
        file: prompt.file,
        name: prompt.name
      });
      return prompt;
    } catch (error) {
      console.error('❌ PrismaService: Error detallado al guardar prompt:', {
        error,
        file,
      });
      return this.handlePrismaError<PrismaPrompt>(error, 'updatePrompt');
    }
  }

  static async getQuestionsForTelegramScheduler(quantity: number, skip: number = 0, minimumIntervalDays: number = 30): Promise<SchedulableQuestion[]> {
    try {
      console.log(`[Scheduler] 🔄 Buscando ${quantity} preguntas para Telegram (ValidQuestion + ExamenOficial2018 + ExamenOficial2024 + SectionQuestion), saltando ${skip}. Intervalo: ${minimumIntervalDays} días.`);
      
      // Calcular la fecha límite para reenvíos (ahora - intervalo mínimo)
      const minReSendDate = new Date();
      minReSendDate.setDate(minReSendDate.getDate() - minimumIntervalDays);
      
      console.log(`[Scheduler] Fecha mínima para reenvíos: ${minReSendDate.toISOString()}`);

      // 🎯 ESTRATEGIA DE MEZCLA: 40% ValidQuestion + 20% ExamenOficial2018 + 20% ExamenOficial2024 + 20% SectionQuestion
      const validQuestionRatio = 0.4;    // 40% de preguntas regulares
      const examen2018Ratio = 0.2;       // 20% del examen oficial 2018
      const examen2024Ratio = 0.2;       // 20% del examen oficial 2024
      const sectionQuestionRatio = 0.2;  // 20% de preguntas por sección
      
      const validQuantity = Math.ceil(quantity * validQuestionRatio);
      const exam2018Quantity = Math.ceil(quantity * examen2018Ratio);
      const exam2024Quantity = Math.ceil(quantity * examen2024Ratio);
      const sectionQuantity = quantity - validQuantity - exam2018Quantity - exam2024Quantity; // El resto para sección
      
      console.log(`[Scheduler] 📊 DISTRIBUCIÓN: ${validQuantity} ValidQuestion + ${exam2018Quantity} ExamenOficial2018 + ${exam2024Quantity} ExamenOficial2024 + ${sectionQuantity} SectionQuestion`);
      
      // 1. Obtener IDs de preguntas enviadas recientemente (último día) para excluirlas
      const recentlyUsedIds = await prisma.telegramsendlog.findMany({
        where: {
          sendtime: {
            gte: new Date(Date.now() - 24 * 60 * 60 * 1000) // Último día
          },
          success: true,
          sourcemodel: { in: ['validQuestion', 'examenOficial2018', 'examenOficial2024', 'sectionQuestion'] }
        },
        select: {
          questionid: true,
          sourcemodel: true
        }
      });

      const recentValidQuestionIds = recentlyUsedIds
        .filter(log => log.sourcemodel === 'validQuestion')
        .map(log => log.questionid);
        
      const recent2018QuestionIds = recentlyUsedIds
        .filter(log => log.sourcemodel === 'examenOficial2018')
        .map(log => log.questionid);
        
      const recent2024QuestionIds = recentlyUsedIds
        .filter(log => log.sourcemodel === 'examenOficial2024')
        .map(log => log.questionid);

      const recentSectionQuestionIds = recentlyUsedIds
        .filter(log => log.sourcemodel === 'sectionQuestion')
        .map(log => log.questionid);

      console.log(`[Scheduler] Excluyendo ${recentValidQuestionIds.length} ValidQuestion + ${recent2018QuestionIds.length} ExamenOficial2018 + ${recent2024QuestionIds.length} ExamenOficial2024 + ${recentSectionQuestionIds.length} SectionQuestion enviadas recientemente.`);

      // 2. Buscar preguntas ValidQuestion (lógica existente)
      const validQuestions = await prisma.validquestion.findMany({
        where: {
          isactive: true,
          id: {
            notIn: recentValidQuestionIds
          }
        },
        orderBy: [
          { sendcount: 'asc' },
          { lastsuccessfulsendat: { sort: 'asc', nulls: 'first' } }
        ],
        take: validQuantity,
        skip: skip,
      });

      // 3. Buscar preguntas del ExamenOficial2018 con rotación similar
      const exam2018Questions = await prisma.examenoficial2018.findMany({
        where: {
          isactive: true,
          id: {
            notIn: recent2018QuestionIds
          }
        },
        orderBy: [
          { sendcount: 'asc' },                                    // Menos enviadas primero
          { lastsuccessfulsendat: { sort: 'asc', nulls: 'first' } } // Más antiguas primero (nunca enviadas = null van primero)
        ],
        take: exam2018Quantity,
        skip: 0, // No aplicar skip a examen oficial para mantener rotación independiente
      });

      // 4. Buscar preguntas del ExamenOficial2024 con rotación similar
      const exam2024Questions = await (prisma as any).examenoficial2024.findMany({
        where: {
          isactive: true,
          id: {
            notIn: recent2024QuestionIds
          }
        },
        orderBy: [
          { sendcount: 'asc' },                                    // Menos enviadas primero
          { lastsuccessfulsendat: { sort: 'asc', nulls: 'first' } } // Más antiguas primero (nunca enviadas = null van primero)
        ],
        take: exam2024Quantity,
        skip: 0, // No aplicar skip a examen oficial para mantener rotación independiente
      });

      // 5. 🆕 Buscar preguntas de SectionQuestion con rotación similar
      const sectionQuestions = await prisma.sectionquestion.findMany({
        where: {
          id: {
            notIn: recentSectionQuestionIds
          }
        },
        orderBy: [
          { sendcount: 'asc' },                                    // Menos enviadas primero
          { lastsuccessfulsendat: { sort: 'asc', nulls: 'first' } } // Más antiguas primero (nunca enviadas = null van primero)
        ],
        take: sectionQuantity,
        skip: 0, // No aplicar skip para mantener rotación independiente
      });

      console.log(`[Scheduler] ✅ Obtenidas ${validQuestions.length} ValidQuestion + ${exam2018Questions.length} ExamenOficial2018 + ${exam2024Questions.length} ExamenOficial2024 + ${sectionQuestions.length} SectionQuestion`);

      // 6. Mapear ValidQuestion a SchedulableQuestion (lógica existente)
      const schedulableValidQuestions: SchedulableQuestion[] = validQuestions.map(vq => ({
        id: vq.id,
        content: JSON.stringify({
          question: vq.parsedquestion,
          options: vq.parsedoptions,
          correctAnswerIndex: vq.correctanswerindex,
          explanation: vq.parsedexplanation
        }),
        type: vq.type,
        difficulty: vq.difficulty,
        bloomLevel: vq.bloomlevel,
        sourceModel: 'validQuestion' as const,
        lastScheduledSendAt: vq.lastsuccessfulsendat,
        sendCount: vq.sendcount,
        lastSuccessfulSendAt: vq.lastsuccessfulsendat
      }));

      // 7. Mapear ExamenOficial2018 a SchedulableQuestion
      const schedulableExam2018Questions: SchedulableQuestion[] = exam2018Questions.map(eq => ({
        id: eq.id,
        content: JSON.stringify({
          question: eq.question,
          options: eq.options,
          correctAnswerIndex: eq.correctanswerindex,
          explanation: 'Respuesta correcta según examen oficial de permanencia 2018.'
        }),
        type: 'multiple_choice', // Tipo estándar para examen oficial
        difficulty: eq.difficulty || 'OFICIAL',
        bloomLevel: null, // ExamenOficial2018 no tiene bloomLevel
        sourceModel: 'examenOficial2018' as const,
        lastScheduledSendAt: eq.lastsuccessfulsendat,
        sendCount: eq.sendcount,
        lastSuccessfulSendAt: eq.lastsuccessfulsendat
      }));

      // 8. Mapear ExamenOficial2024 a SchedulableQuestion
      const schedulableExam2024Questions: SchedulableQuestion[] = exam2024Questions.map((eq: any) => ({
        id: eq.id,
        content: JSON.stringify({
          question: eq.question,
          options: eq.options,
          correctAnswerIndex: eq.correctanswerindex,
          explanation: 'Respuesta correcta según examen oficial de permanencia 2024.'
        }),
        type: 'multiple_choice', // Tipo estándar para examen oficial
        difficulty: eq.difficulty || 'OFICIAL',
        bloomLevel: null, // ExamenOficial2024 no tiene bloomLevel
        sourceModel: 'examenOficial2024' as const,
        lastScheduledSendAt: eq.lastsuccessfulsendat,
        sendCount: eq.sendcount,
        lastSuccessfulSendAt: eq.lastsuccessfulsendat
      }));

      // 9. 🆕 Mapear SectionQuestion a SchedulableQuestion
      const schedulableSectionQuestions: SchedulableQuestion[] = sectionQuestions.map(sq => {
        // 🧪 Usar el parser inteligente para extraer pregunta, opciones y respuesta correcta
        const parsed = parseSectionQuestionContent(sq.content);
        
        let questionData;
        if (parsed.success) {
          questionData = {
            question: parsed.question,
            options: parsed.options,
            correctAnswerIndex: parsed.correctAnswerIndex,
            explanation: 'Pregunta de sección extraída automáticamente'
          };
        } else {
          // Fallback en caso de fallo del parser
          console.warn(`⚠️ Parser falló para SectionQuestion ${sq.id}: ${parsed.error}`);
          try {
            questionData = JSON.parse(sq.content);
          } catch {
            questionData = {
              question: sq.content.substring(0, 200) + '...',
              options: ['Verdadero', 'Falso'],
              correctAnswerIndex: 0,
              explanation: 'Pregunta de sección (formato no reconocido)'
            };
          }
        }

        return {
          id: sq.id,
          content: JSON.stringify(questionData),
          type: sq.type,
          difficulty: sq.difficulty,
          bloomLevel: sq.bloomlevel,
          sourceModel: 'sectionQuestion' as const,
          lastScheduledSendAt: sq.lastsuccessfulsendat,
          sendCount: sq.sendcount,
          lastSuccessfulSendAt: sq.lastsuccessfulsendat
        };
      });

      // 10. 🎯 Combinar y mezclar preguntas para variedad
      const allSchedulableQuestions = [...schedulableValidQuestions, ...schedulableExam2018Questions, ...schedulableExam2024Questions, ...schedulableSectionQuestions];
      
      // Mezclar aleatoriamente para evitar patrones predecibles
      for (let i = allSchedulableQuestions.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [allSchedulableQuestions[i], allSchedulableQuestions[j]] = [allSchedulableQuestions[j], allSchedulableQuestions[i]];
      }

      // 11. 📊 Análisis de rotación para las cuatro fuentes
      const validNeverSent = validQuestions.filter(q => q.sendcount === 0).length;
      const exam2018NeverSent = exam2018Questions.filter(q => q.sendcount === 0).length;
      const exam2024NeverSent = exam2024Questions.filter((q: any) => q.sendcount === 0).length;
      const sectionNeverSent = sectionQuestions.filter(q => q.sendcount === 0).length;
      
      const totalValid = await prisma.validquestion.count({ where: { isactive: true } });
      const totalExam2018 = await prisma.examenoficial2018.count({ where: { isactive: true } });
      const totalExam2024 = await (prisma as any).examenoficial2024.count({ where: { isactive: true } });
      const totalSection = await prisma.sectionquestion.count();
      
      const validMinSendCount = validQuestions.length > 0 ? Math.min(...validQuestions.map(q => q.sendcount)) : 0;
      const exam2018MinSendCount = exam2018Questions.length > 0 ? Math.min(...exam2018Questions.map(q => q.sendcount)) : 0;
      const exam2024MinSendCount = exam2024Questions.length > 0 ? Math.min(...exam2024Questions.map((q: any) => q.sendcount)) : 0;
      const sectionMinSendCount = sectionQuestions.length > 0 ? Math.min(...sectionQuestions.map(q => q.sendcount)) : 0;
      
      console.log('\n📊 ESTADO DE ROTACIÓN CUÁDRUPLE:');
      console.log('   📄 VALIDQUESTION:');
      console.log(`      Total activas: ${totalValid}`);
      console.log(`      Nunca enviadas: ${validNeverSent}`);
      console.log(`      Próximas tendrán sendCount: ${validMinSendCount}`);
      console.log('   🎯 EXAMEN OFICIAL 2018:');
      console.log(`      Total activas: ${totalExam2018}`);
      console.log(`      Nunca enviadas: ${exam2018NeverSent}`);
      console.log(`      Próximas tendrán sendCount: ${exam2018MinSendCount}`);
      console.log('   🎯 EXAMEN OFICIAL 2024:');
      console.log(`      Total activas: ${totalExam2024}`);
      console.log(`      Nunca enviadas: ${exam2024NeverSent}`);
      console.log(`      Próximas tendrán sendCount: ${exam2024MinSendCount}`);
      console.log('   📚 SECTION QUESTION:');
      console.log(`      Total activas: ${totalSection}`);
      console.log(`      Nunca enviadas: ${sectionNeverSent}`);
      console.log(`      Próximas tendrán sendCount: ${sectionMinSendCount}`);
      console.log(`   🎲 MEZCLA FINAL: ${allSchedulableQuestions.length} preguntas combinadas y aleatorizadas`);
      
      if (validNeverSent > 0 || exam2018NeverSent > 0 || exam2024NeverSent > 0 || sectionNeverSent > 0) {
        console.log('   ✅ Incluyendo preguntas NUNCA enviadas (rotación perfecta)');
      } else {
        console.log('   🔄 Iniciando nuevo ciclo en las cuatro fuentes');
      }
      
      console.log(`[Scheduler] ✅ Preparadas ${allSchedulableQuestions.length} preguntas mezcladas (ValidQuestion + ExamenOficial2018 + ExamenOficial2024 + SectionQuestion).`);
      
      return allSchedulableQuestions;

    } catch (error) {
      console.error('[Scheduler] Error obteniendo preguntas para Telegram:', error);
      return this.handlePrismaError<SchedulableQuestion[]>(error, 'getQuestionsForTelegramScheduler');
    }
  }

  static async updateLastScheduledSendAt(questionId: string, sourceModel: 'document' | 'section' | 'validQuestion' | 'examenOficial2018' | 'examenOficial2024' | 'sectionQuestion', success: boolean = true, telegramMsgId?: string, errorMessage?: string): Promise<void> {
    const now = new Date();
    
    try {
      await prisma.$transaction(async (tx) => {
        if (sourceModel === 'validQuestion') {
          // Actualizar ValidQuestion
          await tx.validquestion.update({
            where: { id: questionId },
            data: { 
              sendcount: { increment: 1 },
              ...(success ? { lastsuccessfulsendat: now } : {}),
              updatedat: now
            },
          });
        } else if (sourceModel === 'examenOficial2018') {
          // 🆕 Actualizar ExamenOficial2018
          await tx.examenoficial2018.update({
            where: { id: questionId },
            data: { 
              sendcount: { increment: 1 },
              ...(success ? { lastsuccessfulsendat: now } : {})
            },
          });
        } else if (sourceModel === 'examenOficial2024') {
          // 🆕 Actualizar ExamenOficial2024
          await (tx as any).examenoficial2024.update({
            where: { id: questionId },
            data: { 
              sendcount: { increment: 1 },
              ...(success ? { lastsuccessfulsendat: now } : {})
            },
          });
        } else if (sourceModel === 'sectionQuestion') {
          // 🆕 Actualizar SectionQuestion
          await tx.sectionquestion.update({
            where: { id: questionId },
            data: { 
              sendcount: { increment: 1 },
              ...(success ? { lastsuccessfulsendat: now } : {}),
              updatedat: now
            },
          });
        } else if (sourceModel === 'document') {
          // ⚠️ LEGACY: Mantener compatibilidad con tablas originales
          await tx.question.update({
            where: { id: questionId },
            data: { 
              lastscheduledsendat: now,
              sendcount: { increment: 1 },
              ...(success ? { lastsuccessfulsendat: now } : {})
            },
          });
        } else if (sourceModel === 'section') {
          // ⚠️ LEGACY: Mantener compatibilidad con tablas originales
          await tx.sectionquestion.update({
            where: { id: questionId },
            data: { 
              lastscheduledsendat: now,
              sendcount: { increment: 1 },
              ...(success ? { lastsuccessfulsendat: now } : {})
            },
          });
        }

        // 2. Crear registro en el log de envíos
        await tx.telegramsendlog.create({
          data: {
            id: randomUUID(),
            questionid: questionId,
            sourcemodel: sourceModel,
            sendtime: now,
            success,
            errormessage: errorMessage,
            telegrammsgid: telegramMsgId
          }
        });
      });
      
      console.log(`[Scheduler] ✅ Actualizado sendCount/lastSuccessfulSendAt para ${sourceModel} ID: ${questionId} | Éxito: ${success}`);
    } catch (error) {
      console.error(`[Scheduler] ❌ Error actualizando sendCount/lastSuccessfulSendAt para ${sourceModel} ID: ${questionId}:`, error);
      // Lanzar el error para que el código que llama pueda manejarlo
      throw this.handlePrismaError<void>(error, 'updateLastScheduledSendAt');
    }
  }

  // QuestionConfig: leer la configuración de preguntas
  static async getQuestionConfig(): Promise<questionconfig | null> {
    try {
      const config = await prisma.questionconfig.findFirst();
      return config;
    } catch (error) {
      return this.handlePrismaError<questionconfig | null>(error, 'getQuestionConfig');
    }
  }

  // QuestionConfig: guardar la configuración de preguntas (upsert)
  static async saveQuestionConfig(data: Partial<Prisma.questionconfigCreateInput & Prisma.questionconfigUpdateInput>): Promise<questionconfig> {
    try {
      // Si existe, actualiza; si no, crea
      const existing = await prisma.questionconfig.findFirst();
      if (existing) {
        return await prisma.questionconfig.update({
          where: { id: existing.id },
          data: {
            ...data,
            updatedat: new Date(),
          },
        });
      } else {
        // Filtrar campos undefined para create
        const createData: any = {
          id: data.id || randomUUID(),
          createdat: new Date(),
          updatedat: new Date(),
        };
        
        // Solo agregar campos definidos
        if (data.types !== undefined) createData.types = data.types;
        if (data.difficulties !== undefined) createData.difficulties = data.difficulties;
        if (data.bloomlevels !== undefined) createData.bloomlevels = data.bloomlevels;
        if (data.optionlength !== undefined) createData.optionlength = data.optionlength;
        
        return await prisma.questionconfig.create({
          data: createData,
        });
      }
    } catch (error) {
      return this.handlePrismaError<questionconfig>(error, 'saveQuestionConfig');
    }
  }

  async syncQuestionConfigWithAIConfig(): Promise<boolean> {
    try {
      console.log('🔄 PrismaService.syncQuestionConfigWithAIConfig: Iniciando sincronización...');
      
      // 1. Obtener configuración de IA usando la instancia global
      const aiConfig = await prisma.aiconfig.findFirst();
      if (!aiConfig) {
        console.log('⚠️ No se encontró configuración de IA para sincronizar');
        return false;
      }
      
      // 2. Obtener o crear configuración de preguntas
      let questionConfig = await prisma.questionconfig.findFirst();
      if (!questionConfig) {
        console.log('⚠️ No se encontró configuración de preguntas, creando una nueva');
        questionConfig = await prisma.questionconfig.create({
          data: {
            id: randomUUID(),
            types: "{}",
            difficulties: "{}",
            createdat: new Date(),
            updatedat: new Date()
          }
        });
      }
      
      // 3. Parsear y sincronizar questionTypes
      let questionTypes = null;
      try {
        questionTypes = aiConfig.questiontypes ? JSON.parse(aiConfig.questiontypes) : null;
      } catch (e) {
        console.error('❌ Error al parsear questionTypes:', e);
      }
      
      // 4. Parsear y sincronizar difficultyLevels
      let difficultyLevels = null;
      try {
        difficultyLevels = aiConfig.difficultylevels ? JSON.parse(aiConfig.difficultylevels) : null;
      } catch (e) {
        console.error('❌ Error al parsear difficultyLevels:', e);
      }
      
      // 5. Preparar actualización de configuración de preguntas
      const updateData: any = {
        updatedat: new Date()
      };
      
      if (questionTypes) {
        // Ordenar las propiedades para garantizar consistencia
        const sortedQuestionTypes: Record<string, any> = {};
        Object.keys(questionTypes).sort().forEach(key => {
          (sortedQuestionTypes as any)[key] = (questionTypes as any)[key];
        });
        updateData.types = sortedQuestionTypes;
      }
      
      if (difficultyLevels) {
        // Ordenar las propiedades para garantizar consistencia
        const sortedDifficultyLevels: Record<string, any> = {};
        Object.keys(difficultyLevels).sort().forEach(key => {
          (sortedDifficultyLevels as any)[key] = (difficultyLevels as any)[key];
        });
        updateData.difficulties = sortedDifficultyLevels;
      }
      
      // 6. Actualizar configuración de preguntas
      if (Object.keys(updateData).length > 1) { // > 1 porque siempre tiene updatedAt
        await prisma.questionconfig.update({
          where: {
            id: questionConfig.id
          },
          data: updateData
        });
      }
      
      return true;
    } catch (error) {
      console.error('❌ Error en syncQuestionConfigWithAIConfig:', error);
      return false;
    }
  }

  // También actualizar el método syncAIConfigWithQuestionConfig para mantener consistencia
  async syncAIConfigWithQuestionConfig(): Promise<boolean> {
    try {
      // 1. Obtener configuración de preguntas
      const questionConfig = await prisma.questionconfig.findFirst();
      if (!questionConfig) {
        console.log('⚠️ No se encontró configuración de preguntas para sincronizar');
        return false;
      }
      
      // 2. Obtener o crear configuración de IA
      let aiConfig = await prisma.aiconfig.findFirst();
      if (!aiConfig) {
        console.log('⚠️ No se encontró configuración de IA, creando una nueva');
        aiConfig = await prisma.aiconfig.create({
          data: {
            id: randomUUID(),
            provider: 'openai',
            model: 'gpt-3.5-turbo',
            temperature: 0.3,
            maxtokens: 30720,
            createdat: new Date(),
            updatedat: new Date()
          }
        });
      }
      
      // 3. Preparar datos para actualizar
      const updateData: Prisma.aiconfigUpdateInput = {
        updatedat: new Date()
      };
      
      // Ordenar las propiedades para garantizar consistencia
      if (questionConfig.types && questionConfig.types !== null) {
        const sortedTypes: Record<string, any> = {};
        Object.keys(questionConfig.types).sort().forEach(key => {
          (sortedTypes as any)[key] = (questionConfig.types as any)![key];
        });
        updateData.questiontypes = JSON.stringify(sortedTypes);
      }
      
      if (questionConfig.difficulties && questionConfig.difficulties !== null) {
        const sortedDifficulties: Record<string, any> = {};
        Object.keys(questionConfig.difficulties).sort().forEach(key => {
          (sortedDifficulties as any)[key] = (questionConfig.difficulties as any)![key];
        });
        updateData.difficultylevels = JSON.stringify(sortedDifficulties);
      }
      
      // 4. Actualizar configuración de IA
      if (Object.keys(updateData).length > 1) { // > 1 porque siempre tiene updatedAt
        await prisma.aiconfig.update({
          where: {
            id: aiConfig.id
          },
          data: updateData
        });
      }
      
      return true;
    } catch (error) {
      console.error('❌ Error en syncAIConfigWithQuestionConfig:', error);
      return false;
    }
  }
}