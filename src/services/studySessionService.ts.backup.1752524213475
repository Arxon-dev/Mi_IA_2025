import { PrismaClient } from '@prisma/client';
import { TelegramService } from './telegramService';
import { GamificationService, UserResponse } from './gamificationService';

const prisma = new PrismaClient();

// Declarar tipos globales para notificaciones
declare global {
  var graduationNotifications: Array<{
    userId: string;
    subject: string;
    questionId: string;
    timestamp: Date;
  }> | undefined;
}

// Instancia del servicio de Telegram (requerirÃ¡ token del entorno)
const telegramService = new TelegramService(process.env.TELEGRAM_BOT_TOKEN || '');

// Importar scheduler de forma lazy para evitar dependencias circulares
let studyTimeoutScheduler: any = null;
const getScheduler = async () => {
  if (!studyTimeoutScheduler) {
    const { studyTimeoutScheduler: scheduler } = await import('./studyTimeoutScheduler');
    studyTimeoutScheduler = scheduler;
  }
  return studyTimeoutScheduler;
};

// ==============================================
// ğŸ¯ SERVICIO DE SESIONES DE ESTUDIO PRIVADAS
// ==============================================

// Mapeo de comandos de estudio a tablas de base de datos (CORREGIDO)
export const STUDY_COMMANDS = {
  '/constitucion': 'Constitucion',
  '/defensanacional': 'DefensaNacional',
  '/rjsp': 'Rio',
  '/rio': 'Rio',
  '/minsdef': 'Minsdef',
  '/organizacionfas': 'OrganizacionFas',
  '/emad': 'Emad',
  '/et': 'Et',
  '/armada': 'Armada',
  '/aire': 'Aire',
  '/carrera': 'Carrera',
  '/tropa': 'TropaMarineria',
  '/rroo': 'Rroo',
  '/derechosydeberes': 'DerechosYDeberes',
  '/regimendisciplinario': 'RegimenDisciplinario',
  '/iniciativasyquejas': 'IniciativasQuejas',
  '/igualdad': 'Igualdad',
  '/omi': 'Omi',
  '/pac': 'Pac',
  '/seguridadnacional': 'SeguridadNacional',
  '/pdc': 'Pdc',
  '/onu': 'Onu',
  '/otan': 'Otan',
  '/osce': 'Osce',
  '/ue': 'Ue',
  '/proteccioncivil': 'ProteccionCivil',
  '/misionesinternacionales': 'MisionesInternacionales'
} as const;

interface StudyQuestion {
  id: string;
  questionNumber: number;
  question: string;
  options: string[];
  correctAnswerIndex: number;
  category?: string;
  difficulty?: string;
  originalSubject?: string; // Para preguntas de falladas, mantener el subject original
}

export class StudySessionService {

  // ==========================================
  // ğŸ“‹ MAPEO DE COMANDOS A NOMBRES DE TABLAS
  // ==========================================
  
  private static TABLE_MAPPING: Record<string, string> = {
    // âœ… Tablas con preguntas confirmadas
    'constitucion': 'Constitucion',        // 280 preguntas
    'defensanacional': 'DefensaNacional',  // 121 preguntas
    'aire': 'Aire',                        // 602 preguntas
    
    // ğŸ”§ FIX: Mapeos que faltaban y causaban errores
    'rjsp': 'Rio',                         // âš–ï¸ RJSP â†’ Rio
    'rio': 'Rio',                          // ğŸŒŠ Rio â†’ Rio 
    'tropa': 'TropaMarineria',            // ğŸ‘¥ Tropa y MarinerÃ­a
    'rroo': 'Rroo',                       // ğŸ“‹ RR.OO.
    'seguridadnacional': 'SeguridadNacional', // ğŸ”’ Seguridad Nacional
    'ue': 'Ue',                           // ğŸ‡ªğŸ‡º UE
    'proteccioncivil': 'ProteccionCivil',  // ğŸš¨ ProtecciÃ³n Civil
    
    // ğŸ”„ Tablas que existen pero pueden estar vacÃ­as
    'armada': 'Armada',
    'carrera': 'Carrera', 
    'derechosydeberes': 'DerechosYDeberes',
    'regimendisciplinario': 'RegimenDisciplinario',
    'igualdad': 'Igualdad',
    
    // ğŸ“‹ Otras tablas disponibles
    'minsdef': 'Minsdef',
    'organizacionfas': 'OrganizacionFas',
    'emad': 'Emad',
    'et': 'Et',
    'iniciativasyquejas': 'IniciativasQuejas',
    'omi': 'Omi',
    'pac': 'Pac',
    'pdc': 'Pdc',
    'onu': 'Onu',
    'otan': 'Otan',
    'osce': 'Osce',
    'misiones': 'MisionesInternacionales'
  };

  private static TABLE_DISPLAY_NAMES: Record<string, string> = {
    'constitucion': 'ğŸ“œ ConstituciÃ³n',
    'defensanacional': 'ğŸ›¡ï¸ Defensa Nacional',
    'rjsp': 'âš–ï¸ RJSP',
    'rio': 'ğŸŒŠ RIO',
    'minsdef': 'ğŸ›ï¸ MINSDEF',
    'organizacionfas': 'ğŸ–ï¸ OrganizaciÃ³n FAS',
    'emad': 'â­ EMAD',
    'et': 'ğŸª– EjÃ©rcito de Tierra',
    'armada': 'âš“ Armada',
    'aire': 'âœˆï¸ EjÃ©rcito del Aire',
    'carrera': 'ğŸ“ˆ Carrera Militar',
    'tropa': 'ğŸ‘¥ Tropa y MarinerÃ­a',
    'rroo': 'ğŸ“‹ RR.OO.',
    'derechosydeberes': 'âš–ï¸ Derechos y Deberes',
    'regimendisciplinario': 'ğŸš« RÃ©gimen Disciplinario',
    'iniciativasyquejas': 'ğŸ“ Iniciativas y Quejas',
    'igualdad': 'ğŸ³ï¸â€ğŸŒˆ Igualdad',
    'omi': 'ğŸŒ OMI',
    'pac': 'ğŸ•Šï¸ PAC',
    'seguridadnacional': 'ğŸ”’ Seguridad Nacional',
    'pdc': 'ğŸ“Š PDC',
    'onu': 'ğŸŒ ONU',
    'otan': 'ğŸ›¡ï¸ OTAN',
    'osce': 'ğŸ¤ OSCE',
    'ue': 'ğŸ‡ªğŸ‡º UE',
    'proteccioncivil': 'ğŸš¨ ProtecciÃ³n Civil',
    'misiones': 'ğŸŒ Misiones Internacionales'
  };

  // ==========================================
  // ğŸ¯ PARSEAR COMANDO DE ESTUDIO
  // ==========================================
  
  static parseStudyCommand(command: string): { subject: string; quantity: number; type?: 'normal' | 'failed' } | null {
    // ğŸ” COMANDOS DE PREGUNTAS FALLADAS
    // Formato: /falladas15, /constitucionfalladas5, etc.
    const failedMatch = command.match(/^\/(?:([a-zA-Z]+)falladas|falladas)(\d*)$/);
    
    if (failedMatch) {
      const [, subjectRaw, quantityStr] = failedMatch;
      const quantity = quantityStr ? parseInt(quantityStr, 10) : 5; // Default 5 preguntas
      
      // Validar cantidad (1-50)
      if (quantity < 1 || quantity > 50) return null;
      
      if (subjectRaw) {
        // Comando especÃ­fico de materia (/constitucionfalladas5)
        const commandKey = `/${subjectRaw.toLowerCase()}`;
        if (!STUDY_COMMANDS[commandKey as keyof typeof STUDY_COMMANDS]) return null;
        return { subject: subjectRaw.toLowerCase(), quantity, type: 'failed' };
      } else {
        // Comando general (/falladas15)
        return { subject: 'all', quantity, type: 'failed' };
      }
    }
    
    // ğŸ” COMANDOS NORMALES EXISTENTES
    // Formato: /constitucion10, /defensanacional5, etc.
    const normalMatch = command.match(/^\/([a-zA-Z]+)(\d+)$/);
    
    if (!normalMatch) return null;
    
    const [, subjectRaw, quantityStr] = normalMatch;
    const commandKey = `/${subjectRaw.toLowerCase()}`;
    const quantity = parseInt(quantityStr, 10);
    
    // Validar que la materia existe en STUDY_COMMANDS
    if (!STUDY_COMMANDS[commandKey as keyof typeof STUDY_COMMANDS]) return null;
    
    // Validar cantidad (1-50)
    if (quantity < 1 || quantity > 50) return null;
    
    return { subject: subjectRaw.toLowerCase(), quantity, type: 'normal' };
  }

  // ==========================================
  // ğŸ“ SISTEMA DE PREGUNTAS FALLADAS
  // ==========================================
  
  /**
   * Verificar si el usuario ha estudiado alguna vez
   */
  private async hasUserEverStudied(userId: string, subject?: string): Promise<boolean> {
    try {
      const subjectFilter = subject && subject !== 'all' ? `AND subject = '${subject}'` : '';
      
      const query = `
        SELECT COUNT(*) as count 
        FROM "StudyResponse" 
        WHERE "userId" = $1 
          AND "answeredAt" IS NOT NULL
          ${subjectFilter}
        LIMIT 1
      `;
      
      const result = await prisma.$queryRawUnsafe(query, userId) as any[];
      const count = parseInt(result[0]?.count || '0');
      
      console.log(`ğŸ” [hasUserEverStudied] Usuario ${userId}, materia: ${subject || 'todas'}, respuestas: ${count}`);
      return count > 0;
      
    } catch (error) {
      console.error('âŒ Error verificando si el usuario ha estudiado:', error);
      return false; // En caso de error, asumir que no ha estudiado
    }
  }

  /**
   * Obtener preguntas falladas del usuario (que aÃºn no han "graduado")
   */
  private async getFailedQuestions(userId: string, subject?: string, limit: number = 10): Promise<StudyQuestion[]> {
    try {
      console.log(`ğŸ” [FailedQuestions] Buscando preguntas falladas para usuario ${userId}, materia: ${subject || 'todas'}, lÃ­mite: ${limit}`);
      
      // Construir filtro por materia
      const subjectFilter = subject && subject !== 'all' ? `AND sr.subject = '${subject}'` : '';
      
      // Query para obtener preguntas falladas que no han "graduado" (menos de 3 aciertos totales desde el Ãºltimo fallo)
      const query = `
        WITH failed_questions AS (
          -- Obtener todas las preguntas que el usuario ha fallado alguna vez
          SELECT DISTINCT 
            sr."questionId",
            sr.subject,
            MAX(sr."answeredAt") as last_failed_at  -- ğŸ”§ FIX: Ãšltimo fallo, no el primero
          FROM "StudyResponse" sr 
          WHERE sr."userId" = $1 
            AND sr."isCorrect" = false 
            AND sr."answeredAt" IS NOT NULL
            ${subjectFilter}
          GROUP BY sr."questionId", sr.subject
        ),
        total_successes AS (
          -- ğŸ”§ FIX: Contar aciertos TOTALES desde el Ãºltimo fallo (no necesariamente consecutivos)
          SELECT 
            fq."questionId",
            fq.subject,
            fq.last_failed_at,
            COUNT(sr2.id) as total_successes_since_last_fail
          FROM failed_questions fq
          LEFT JOIN "StudyResponse" sr2 ON sr2."questionId" = fq."questionId" 
            AND sr2."userId" = $1 
            AND sr2."isCorrect" = true 
            AND sr2."answeredAt" > fq.last_failed_at
            AND sr2.subject = fq.subject  -- ğŸ”§ FIX CRÃTICO: Solo aciertos de la misma materia
          GROUP BY fq."questionId", fq.subject, fq.last_failed_at
        )
        SELECT 
          ts."questionId",
          ts.subject,
          ts.total_successes_since_last_fail,
          ts.last_failed_at
        FROM total_successes ts
        WHERE ts.total_successes_since_last_fail < 1  -- Solo preguntas que NO han graduado
        ORDER BY ts.last_failed_at ASC  -- Las mÃ¡s antiguas primero
        LIMIT $2
      `;
      
      const failedQuestionIds = await prisma.$queryRawUnsafe(query, userId, limit) as any[];
      
      console.log(`ğŸ“Š [FailedQuestions] Encontradas ${failedQuestionIds.length} preguntas falladas sin graduar`);
      
      if (failedQuestionIds.length === 0) {
        return [];
      }
      
      // Obtener los detalles completos de las preguntas de todas las materias
      const questions: StudyQuestion[] = [];
      
      for (const row of failedQuestionIds) {
        const questionDetails = await this.getQuestionById(row.subject, row.questionId);
        if (questionDetails) {
          questions.push(questionDetails);
          console.log(`âœ… [FailedQuestions] AÃ±adida pregunta ${row.questionId} de ${row.subject} (${row.total_successes_since_last_fail}/1 aciertos totales)`);
        }
      }
      
      console.log(`ğŸ¯ [FailedQuestions] Total preguntas falladas obtenidas: ${questions.length}`);
      return questions;
      
    } catch (error) {
      console.error('âŒ Error obteniendo preguntas falladas:', error);
      return [];
    }
  }

  /**
   * MÃ©todo pÃºblico para obtener el conteo de preguntas falladas por materia
   */
  async getFailedQuestionsCount(userId: string, subject: string): Promise<number> {
    try {
      const result = await this.getFailedQuestions(userId, subject, 1000); // Usar lÃ­mite alto para contar todas
      return result.length;
    } catch (error) {
      console.error(`âŒ Error contando preguntas falladas para ${subject}:`, error);
      return 0;
    }
  }

  /**
   * MÃ©todo estÃ¡tico para obtener el mapeo de comandos a materias
   */
  static getSubjectMappings(): Record<string, string> {
    return STUDY_COMMANDS;
  }

  /**
   * ğŸ“ Verificar si una pregunta se acaba de graduar (1+ aciertos desde Ãºltimo fallo)
   */
  private async checkIfQuestionJustGraduated(tx: any, userId: string, subject: string, questionId: string): Promise<boolean> {
    try {
      // Contar aciertos totales desde el Ãºltimo fallo
      const result = await tx.$queryRaw`
        SELECT 
          COALESCE(
            (SELECT COUNT(*) 
             FROM "StudyResponse" sr2 
             WHERE sr2."userId" = ${userId}
               AND sr2."questionId" = ${questionId}
               AND sr2.subject = ${subject}
               AND sr2."isCorrect" = true 
               AND sr2."answeredAt" > COALESCE(
                 (SELECT MAX(sr3."answeredAt") 
                  FROM "StudyResponse" sr3 
                  WHERE sr3."userId" = ${userId}
                    AND sr3."questionId" = ${questionId}
                    AND sr3.subject = ${subject}
                    AND sr3."isCorrect" = false), 
                 '1970-01-01'::timestamp)
            ), 0) as total_successes_since_last_fail
      `;

      const successCount = Number((result as any[])[0]?.total_successes_since_last_fail || 0);
      
      // La pregunta se gradÃºa exactamente cuando alcanza 1 acierto desde el Ãºltimo fallo
      const isGraduated = successCount === 1;
      
      if (isGraduated) {
        console.log(`ğŸ“ checkIfQuestionJustGraduated: Pregunta ${questionId} graduada con ${successCount} acierto(s)`);
      }
      
      return isGraduated;
    } catch (error) {
      console.error('âŒ Error verificando graduaciÃ³n de pregunta:', error);
      return false;
    }
  }
  
  /**
   * Iniciar sesiÃ³n de estudio con preguntas falladas
   */
  async startFailedStudySession(userId: string, subject: string, totalQuestions: number): Promise<{ success: boolean; message: string; sessionId?: string }> {
    try {
      console.log(`ğŸ“ [FailedSession] Iniciando sesiÃ³n de preguntas falladas - Usuario: ${userId}, Materia: ${subject}, Cantidad: ${totalQuestions}`);
      
      // Obtener preguntas falladas
      const failedQuestions = await this.getFailedQuestions(userId, subject, totalQuestions);
      
      if (failedQuestions.length === 0) {
        // ğŸ” Verificar si el usuario ha estudiado alguna vez
        const hasEverStudied = await this.hasUserEverStudied(userId, subject);
        const subjectName = subject === 'all' ? 'todas las materias' : StudySessionService.getDisplayName(subject);
        
        if (!hasEverStudied) {
          // Usuario nuevo que nunca ha estudiado
          return { 
            success: false, 
            message: `ğŸ†• **Â¡Bienvenido al sistema de repaso!**\n\n` +
                    `Para usar \`/falladas\`, primero necesitas estudiar algunas preguntas y fallar alguna.\n\n` +
                    `ğŸ¯ **Â¿Por dÃ³nde empezar?**\n` +
                    `â€¢ \`/constitucion5\` - 5 preguntas de ConstituciÃ³n\n` +
                    `â€¢ \`/defensanacional3\` - 3 preguntas de Defensa Nacional\n` +
                    `â€¢ \`/pdc5\` - 5 preguntas de PDC\n\n` +
                    `ğŸ’¡ **Una vez que falles algunas preguntas, podrÃ¡s repasarlas con \`/falladas\`!**`
          };
        } else {
          // Usuario experimentado sin preguntas falladas pendientes
          return { 
            success: false, 
            message: `ğŸ‰ Â¡Excelente! No tienes preguntas falladas pendientes en **${subjectName}**.\n\n` +
                    `ğŸ“ **Â¡Has graduado todas tus preguntas falladas!**\n` +
                    `Esto significa que has acertado 1 vez cada pregunta que habÃ­as fallado previamente.\n\n` +
                    `Â¡Sigue estudiando para mantener tu nivel! ğŸ’ª`
          };
        }
      }
      
      // Si hay menos preguntas falladas que las solicitadas, ajustar la cantidad
      const actualQuantity = Math.min(totalQuestions, failedQuestions.length);
      
      // Crear sesiÃ³n especial para preguntas falladas
      const session = await prisma.$transaction(async (tx) => {
        // Eliminar sesiones previas del usuario
        await tx.userStudySession.deleteMany({
          where: { userId }
        });
        
        await new Promise(resolve => setTimeout(resolve, 100));
        
        // Crear nueva sesiÃ³n marcada como "falladas"
        const newSession = await tx.userStudySession.create({
          data: {
            userId,
            subject: subject === 'all' ? 'falladas' : `${subject}_falladas`, // Marcar como sesiÃ³n de falladas
            totalQuestions: actualQuantity,
            currentIndex: 0,
            questionsAsked: failedQuestions.map(q => q.id), // Pre-llenar con las preguntas falladas especÃ­ficas
            status: 'active',
            timeoutAt: new Date(Date.now() + 60000)
          }
        });
        
        console.log(`âœ… [FailedSession] SesiÃ³n de falladas creada: ${newSession.id}`);
        return newSession;
      });
      
      // Mensaje de confirmaciÃ³n personalizado
      const subjectDisplayName = subject === 'all' ? 'ğŸ”„ Repaso General' : `ğŸ”„ ${StudySessionService.getDisplayName(subject)}`;
      const confirmationMessage = 
        `ğŸ“ Â¡SesiÃ³n de REPASO iniciada!\n\n` +
        `ğŸ¯ Tipo: **Preguntas Falladas**\n` +
        `ğŸ“š Materia: ${subjectDisplayName}\n` +
        `ğŸ“Š Preguntas disponibles: ${failedQuestions.length}\n` +
        `ğŸ² Preguntas en esta sesiÃ³n: ${actualQuantity}\n\n` +
        `ğŸ† **Sistema de graduaciÃ³n:**\n` +
        `â€¢ Acierta 1 vez una pregunta = Â¡Graduada! ğŸ“\n` +
        `â€¢ Las preguntas graduadas no aparecerÃ¡n mÃ¡s\n\n` +
        `â±ï¸ Tienes 1 minuto por pregunta\n` +
        `âš¡ Usa /stop para cancelar`;
      
      // Programar envÃ­o de primera pregunta
      setTimeout(async () => {
        const firstQuestionSent = await this.sendNextFailedQuestion(session.id, failedQuestions);
        
        if (!firstQuestionSent.success) {
          await this.cancelSession(session.id);
          const { TelegramService } = await import('./telegramService');
          const telegramService = new TelegramService(process.env.TELEGRAM_BOT_TOKEN || '');
          await telegramService.sendMessage(userId, 'âŒ Error al enviar la primera pregunta de repaso');
        }
      }, 500);
      
      return { 
        success: true, 
        message: confirmationMessage,
        sessionId: session.id 
      };
      
    } catch (error) {
      console.error('âŒ Error iniciando sesiÃ³n de preguntas falladas:', error);
      return { success: false, message: 'âŒ Error interno del sistema' };
    }
  }
  
  /**
   * Enviar siguiente pregunta fallada especÃ­fica
   */
  private async sendNextFailedQuestion(sessionId: string, failedQuestions: StudyQuestion[]): Promise<{ success: boolean; message?: string; completed?: boolean }> {
    try {
      const session = await prisma.userStudySession.findUnique({
        where: { id: sessionId }
      });
      
      if (!session || session.status !== 'active') {
        return { success: false, message: 'SesiÃ³n no encontrada o inactiva' };
      }
      
      if (session.currentIndex >= session.totalQuestions || session.currentIndex >= failedQuestions.length) {
        await this.completeSession(session.id);
        return { success: true, completed: true };
      }
      
      // Obtener la pregunta especÃ­fica para este Ã­ndice
      const question = failedQuestions[session.currentIndex];
      
      if (!question) {
        await this.cancelSession(sessionId);
        return { success: false, message: 'âŒ No se pudo obtener la pregunta de repaso' };
      }
      
      return await this.sendQuestionToUser(session, question);
      
    } catch (error) {
      console.error('âŒ Error enviando pregunta fallada:', error);
      return { success: false, message: 'Error enviando pregunta de repaso' };
    }
  }

  // ==========================================
  // ğŸ¯ INICIAR SESIÃ“N DE ESTUDIO
  // ==========================================
  
  async startStudySession(userId: string, subject: string, totalQuestions: number, sessionType: 'normal' | 'failed' = 'normal'): Promise<{ success: boolean; message: string; sessionId?: string }> {
    try {
      // ğŸ“ Si es sesiÃ³n de preguntas falladas, usar el mÃ©todo especializado
      if (sessionType === 'failed') {
        return await this.startFailedStudySession(userId, subject, totalQuestions);
      }
      
      // âœ… SesiÃ³n normal: Verificar que el subject es vÃ¡lido y obtener el nombre de tabla correcto
      const commandKey = `/${subject}`;
      const tableName = STUDY_COMMANDS[commandKey as keyof typeof STUDY_COMMANDS];
      if (!tableName) {
        return { success: false, message: 'âŒ Materia no vÃ¡lida' };
      }

      // Usar transacciÃ³n para asegurar atomicidad
      const session = await prisma.$transaction(async (tx) => {
        // Eliminar TODAS las sesiones del usuario (no solo activas)
        const deletedCount = await tx.userStudySession.deleteMany({
          where: { userId }
        });
        console.log(`ğŸ—‘ï¸ ${deletedCount.count} sesiones eliminadas para usuario ${userId}`);

        // Esperar un momento para asegurar que la eliminaciÃ³n se complete
        await new Promise(resolve => setTimeout(resolve, 100));

        // Verificar que no queden sesiones
        const remainingSessions = await tx.userStudySession.count({
          where: { userId }
        });
        
        if (remainingSessions > 0) {
          throw new Error(`AÃºn existen ${remainingSessions} sesiones para el usuario ${userId}`);
        }

        // Crear nueva sesiÃ³n
        const newSession = await tx.userStudySession.create({
          data: {
            userId,
            subject,
            totalQuestions,
            currentIndex: 0,
            questionsAsked: [],
            status: 'active',
            timeoutAt: new Date(Date.now() + 60000) // 1 minuto para la primera pregunta
          }
        });

        console.log(`âœ… Nueva sesiÃ³n creada: ${newSession.id} para usuario ${userId}`);
        return newSession;
      });

      console.log(`âœ… TransacciÃ³n completada exitosamente para usuario ${userId}`);

      // PRIMERO: Retornar mensaje de confirmaciÃ³n (se enviarÃ¡ inmediatamente)
      const confirmationMessage = `ğŸ“š Â¡SesiÃ³n de estudio iniciada!\n\nğŸ¯ Materia: ${subject.toUpperCase()}\nğŸ“Š Preguntas: ${totalQuestions}\n\nâ±ï¸ Tienes 1 minuto por pregunta\nâš¡ Usa /stop para cancelar\nğŸ“ˆ Usa /progreso para ver tu estado`;

      // SEGUNDO: Programar envÃ­o de primera pregunta con un pequeÃ±o delay
      setTimeout(async () => {
        const firstQuestionSent = await this.sendNextQuestion(session.id);
        
        if (!firstQuestionSent.success) {
          await this.cancelSession(session.id);
          // Enviar mensaje de error si falla
          const { TelegramService } = await import('./telegramService');
          const telegramService = new TelegramService(process.env.TELEGRAM_BOT_TOKEN || '');
          await telegramService.sendMessage(userId, 'âŒ Error al enviar la primera pregunta');
        }
      }, 500); // Esperar 500ms para asegurar que el mensaje de confirmaciÃ³n se envÃ­e primero

      return { 
        success: true, 
        message: confirmationMessage,
        sessionId: session.id 
      };

    } catch (error) {
      console.error('Error iniciando sesiÃ³n de estudio:', error);
      return { success: false, message: 'âŒ Error interno del sistema' };
    }
  }

  // ==========================================
  // ğŸ¯ OBTENER PRÃ“XIMA PREGUNTA
  // ==========================================
  
  async sendNextQuestion(sessionId: string): Promise<{ success: boolean; message?: string; completed?: boolean }> {
    try {
      const session = await prisma.userStudySession.findUnique({
        where: { id: sessionId }
      });

      if (!session || session.status !== 'active') {
        return { success: false, message: 'SesiÃ³n no encontrada o inactiva' };
      }

      // ğŸ“ Si es una sesiÃ³n de preguntas falladas, usar el mÃ©todo especializado
      if (session.subject === 'falladas' || session.subject.endsWith('_falladas')) {
        // Para sesiones de falladas, las preguntas ya estÃ¡n pre-seleccionadas en questionsAsked
        const failedQuestions: StudyQuestion[] = [];
        
        // Recuperar las preguntas basÃ¡ndose en los IDs almacenados
        if (session.questionsAsked && session.questionsAsked.length > 0) {
          for (const questionId of session.questionsAsked) {
            // Extraer el subject original del session.subject 
            const originalSubject = session.subject === 'falladas' ? 'all' : session.subject.replace('_falladas', '');
            
            // Para 'all', necesitamos buscar en todas las materias
            if (originalSubject === 'all') {
              // Buscar la pregunta en todas las materias posibles
              let found = false;
              for (const subject of Object.keys(STUDY_COMMANDS).map(s => s.replace('/', ''))) {
                const question = await this.getQuestionById(subject, questionId);
                if (question) {
                  failedQuestions.push(question);
                  found = true;
                  break;
                }
              }
              if (!found) {
                console.warn(`âš ï¸ No se pudo encontrar la pregunta ${questionId} en ninguna materia`);
              }
            } else {
              // Buscar en la materia especÃ­fica
              const question = await this.getQuestionById(originalSubject, questionId);
              if (question) {
                failedQuestions.push(question);
              }
            }
          }
        }
        
        return await this.sendNextFailedQuestion(sessionId, failedQuestions);
      }

      // Verificar si ya completÃ³ todas las preguntas
      if (session.currentIndex >= session.totalQuestions) {
        await this.completeSession(session.id);
        return { success: true, completed: true };
      }

      // Obtener estadÃ­sticas para evitar repeticiÃ³n
      const stats = await this.getUserStats(session.userId, session.subject);
      
      // Obtener nombre de tabla correcto
      const commandKey = `/${session.subject}`;
      const tableName = STUDY_COMMANDS[commandKey as keyof typeof STUDY_COMMANDS];
      if (!tableName) {
        await this.cancelSession(sessionId);
        return { success: false, message: 'âŒ Materia no vÃ¡lida' };
      }

      // Obtener pregunta que no haya sido respondida (usar nombre de tabla correcto)
      const question = await this.getRandomQuestion(tableName, stats.questionsCompleted);
      
      if (!question) {
        // Si no hay mÃ¡s preguntas Ãºnicas, reiniciar el pool
        await this.resetQuestionPool(session.userId, session.subject);
        const retryQuestion = await this.getRandomQuestion(tableName, []);
        
        if (!retryQuestion) {
          await this.cancelSession(sessionId);
          return { success: false, message: 'âŒ No hay preguntas disponibles para esta materia' };
        }
        
        return await this.sendQuestionToUser(session, retryQuestion);
      }

      return await this.sendQuestionToUser(session, question);

    } catch (error) {
      console.error('Error enviando siguiente pregunta:', error);
      return { success: false, message: 'Error enviando pregunta' };
    }
  }

  // ==========================================
  // ğŸ¯ PROCESAR RESPUESTA DEL POLL
  // ==========================================
  
  async processPollAnswer(pollId: string, userId: string, selectedOption: number): Promise<void> {
    try {
      let shouldSendNextQuestion = false;
      let sessionIdForNext = '';
      
      await prisma.$transaction(async (tx) => {
        // 1. Encontrar la pregunta correspondiente al poll
        const pollMapping = await tx.telegramPollMapping.findUnique({
          where: { pollId },
        });

        if (!pollMapping) {
          console.error(`[StudySession] No se encontrÃ³ mapeo para el pollId: ${pollId}`);
          return;
        }
        
        const { questionId, subject } = pollMapping;

        // 2. Encontrar la sesiÃ³n de estudio activa del usuario
        // ğŸ”§ FIX: Para sesiones de falladas, el subject del poll mapping es diferente al subject de la sesiÃ³n
        let session = await tx.userStudySession.findFirst({
          where: { userId, status: 'active', subject: subject },
        });

        // Si no se encuentra, podrÃ­a ser una sesiÃ³n de falladas
        if (!session) {
          // Buscar sesiÃ³n de falladas generales
          session = await tx.userStudySession.findFirst({
            where: { userId, status: 'active', subject: 'falladas' },
          });
          
          // Si no, buscar sesiÃ³n de falladas especÃ­fica de la materia
          if (!session) {
            session = await tx.userStudySession.findFirst({
              where: { userId, status: 'active', subject: `${subject}_falladas` },
            });
          }
        }

        if (!session) {
          console.error(`[StudySession] No se encontrÃ³ sesiÃ³n activa para el usuario ${userId}. Subject del poll: ${subject}`);
          return;
        }
        
        console.log(`âœ… [StudySession] SesiÃ³n encontrada: ${session.id}, subject: ${session.subject}, currentIndex: ${session.currentIndex}`);
        
        // 3. Obtener los detalles completos de la pregunta
        const question = await this.getQuestionById(subject, questionId);

        if (!question) {
          console.error(`[StudySession] No se pudo obtener la pregunta con ID ${questionId} para la materia ${subject} (sesiÃ³n: ${session.subject})`);
          return;
        }

        // 4. Determinar si la respuesta es correcta usando el Ã­ndice correcto despuÃ©s del shuffle
        let correctAnswerIndex = question.correctAnswerIndex; // Default from DB
        
        // Intentar obtener el correctAnswerIndex correcto del mapping (despuÃ©s del shuffle)
        if (global.studyPollMappings && global.studyPollMappings.has(pollId)) {
          const mapping = global.studyPollMappings.get(pollId);
          correctAnswerIndex = mapping.correctAnswerIndex;
          console.log(`ğŸ² Usando correctAnswerIndex del mapping: ${correctAnswerIndex} (original: ${question.correctAnswerIndex})`);
        } else {
          console.log(`âš ï¸ No se encontrÃ³ mapping para pollId ${pollId}, usando correctAnswerIndex de DB: ${correctAnswerIndex}`);
        }
        
        const isCorrect = selectedOption === correctAnswerIndex;
        // Calcular tiempo de respuesta en milisegundos (no segundos)
        const responseTime = session.timeoutAt ? Math.max(0, Math.round(Date.now() - (session.timeoutAt.getTime() - 60000))) : 1000;

        // 5. Actualizar la sesiÃ³n y las estadÃ­sticas de estudio
        const updatedSession = await tx.userStudySession.update({
          where: { id: session.id },
          data: {
            currentIndex: { increment: 1 }, // Incrementar despuÃ©s de procesar respuesta
            timeoutAt: new Date(Date.now() + 60000), // Resetear timeout para la prÃ³xima pregunta
          },
        });

        // ğŸ”§ FIX CRÃTICO: Para sesiones de falladas, usar el subject original de la pregunta
        // No el subject de la sesiÃ³n ("falladas") sino el subject real ("defensanacional")
        const actualSubject = subject; // subject viene del poll mapping y es el correcto
        console.log(`ğŸ”§ [processPollAnswer] Guardando respuesta con subject: ${actualSubject} (sesiÃ³n: ${session.subject})`);
        
        // Pasar el 'tx' a updateUserStats con todos los datos necesarios
        await this.updateUserStats(tx, userId, actualSubject, isCorrect, responseTime, questionId, pollId, selectedOption, question.questionNumber || 0);

        // 5.5. ğŸ“ TRIGGER NOTIFICACIONES: Si la respuesta es correcta, verificar graduaciÃ³n
        if (isCorrect) {
          // Verificar si esta pregunta se acaba de graduar
          const wasGraduated = await this.checkIfQuestionJustGraduated(tx, userId, actualSubject, questionId);
          if (wasGraduated) {
            console.log(`ğŸ“ Pregunta graduada detectada: ${questionId} en ${actualSubject} para usuario ${userId}`);
            // âœ… Se graduÃ³ - el trigger de notificaciÃ³n se enviarÃ¡ despuÃ©s de la transacciÃ³n
            // Almacenar info para procesar notificaciÃ³n fuera de la transacciÃ³n
            if (!global.graduationNotifications) {
              global.graduationNotifications = [];
            }
            global.graduationNotifications.push({
              userId,
              subject: actualSubject,
              questionId,
              timestamp: new Date()
            });
          }
        }

        // 6. Notificar al usuario sobre su respuesta
        const feedbackMessage = StudySessionService.formatResponseFeedback(isCorrect, question, updatedSession);
        const { TelegramService } = await import('./telegramService');
        const telegramService = new TelegramService(process.env.TELEGRAM_BOT_TOKEN || '');
        await telegramService.sendMessage(userId, feedbackMessage);
        
        // 7. Verificar si debemos finalizar la sesiÃ³n
        if (updatedSession.currentIndex >= updatedSession.totalQuestions) {
          // Solo marcar la sesiÃ³n como completada en la transacciÃ³n
          await tx.userStudySession.update({
            where: { id: updatedSession.id },
            data: { status: 'completed', timeoutAt: null },
          });
          console.log(`ğŸ“ TransacciÃ³n completada. SesiÃ³n marcada como completada. Generando resumen...`);
          // El resumen se generarÃ¡ DESPUÃ‰S de la transacciÃ³n
          shouldSendNextQuestion = false;
          sessionIdForNext = updatedSession.id; // Usar para generar resumen despuÃ©s
        } else {
          // NO enviar la siguiente pregunta dentro de la transacciÃ³n
          // Se enviarÃ¡ despuÃ©s de que la transacciÃ³n se confirme
          shouldSendNextQuestion = true;
          sessionIdForNext = updatedSession.id;
          console.log(`ğŸ“ TransacciÃ³n completada. Programando envÃ­o de siguiente pregunta...`);
        }
      }, {
        timeout: 15000, // 15 segundos de timeout
      });
      
      // Realizar acciones DESPUÃ‰S de que la transacciÃ³n se confirme
      if (shouldSendNextQuestion) {
        console.log(`ğŸš€ Enviando siguiente pregunta para sesiÃ³n ${sessionIdForNext}...`);
        await this.sendNextQuestion(sessionIdForNext);
      } else if (sessionIdForNext) {
        // La sesiÃ³n ha terminado, generar resumen fuera de la transacciÃ³n
        console.log(`ğŸ Generando resumen de sesiÃ³n completada: ${sessionIdForNext}...`);
        
        // Cancelar timeout pendiente
        try {
          const scheduler = await getScheduler();
          scheduler.cancelTimeout(sessionIdForNext);
        } catch (error) {
          console.error('Error cancelando timeout:', error);
        }
        
        // Generar y enviar resumen DESPUÃ‰S de confirmar la transacciÃ³n
        const summary = await this.generateSessionCompletionMessage(sessionIdForNext);
        const { TelegramService } = await import('./telegramService');
        const telegramService = new TelegramService(process.env.TELEGRAM_BOT_TOKEN || '');
        await telegramService.sendMessage(userId, summary);
      }

      // ğŸ“ PROCESAR NOTIFICACIONES DE GRADUACIÃ“N (despuÃ©s de la transacciÃ³n)
      if (global.graduationNotifications && global.graduationNotifications.length > 0) {
        const notificationsToProcess = [...global.graduationNotifications];
        global.graduationNotifications = []; // Limpiar array global
        
        for (const notification of notificationsToProcess) {
          try {
            console.log(`ğŸ”” Procesando notificaciÃ³n de graduaciÃ³n: ${notification.questionId} en ${notification.subject}`);
            
            // Importar dinÃ¡micamente para evitar dependencias circulares
            const { NotificationService } = await import('./notificationService');
            const notificationService = new NotificationService();
            
            // Configurar bot de Telegram si es necesario
            const { TelegramService } = await import('./telegramService');
            const telegramService = new TelegramService(process.env.TELEGRAM_BOT_TOKEN || '');
            notificationService.setTelegramBot(telegramService);
            
            // Disparar notificaciones de graduaciÃ³n
            await notificationService.onQuestionGraduated(notification.userId, notification.subject);
            
            console.log(`âœ… NotificaciÃ³n de graduaciÃ³n procesada para usuario ${notification.userId}`);
          } catch (error) {
            console.error('âŒ Error procesando notificaciÃ³n de graduaciÃ³n:', error);
          }
        }
      }
      
    } catch (error) {
      console.error('Error al procesar la respuesta del poll:', error);
    }
  }

  // ==========================================
  // ğŸ¯ CANCELAR SESIÃ“N ACTIVA
  // ==========================================
  
  async cancelActiveSession(userId: string): Promise<void> {
    try {
      const activeSession = await prisma.userStudySession.findFirst({
        where: { userId, status: 'active' }
      });

      if (activeSession) {
        await this.cancelSession(activeSession.id);
      }
    } catch (error) {
      console.error('Error cancelando sesiÃ³n activa:', error);
    }
  }

  // ==========================================
  // ğŸ¯ VER PROGRESO DE SESIÃ“N
  // ==========================================
  
  async getSessionProgress(userId: string): Promise<{ success: boolean; message: string }> {
    try {
      const session = await prisma.userStudySession.findFirst({
        where: { userId, status: 'active' },
        include: {
          responses: {
            where: { answeredAt: { not: null } }
          }
        }
      });

      if (!session) {
        return { success: false, message: 'âŒ No tienes ninguna sesiÃ³n de estudio activa' };
      }

      const answered = session.responses.length;
      const correct = session.responses.filter(r => r.isCorrect).length;
      const incorrect = session.responses.filter(r => !r.isCorrect || r.timedOut).length;
      const percentage = answered > 0 ? Math.round((correct / answered) * 100) : 0;

      const progress = `ğŸ“Š **PROGRESO ACTUAL**\n\n` +
        `ğŸ¯ Materia: ${session.subject.toUpperCase()}\n` +
        `ğŸ“ˆ Progreso: ${session.currentIndex}/${session.totalQuestions}\n\n` +
        `âœ… Correctas: ${correct}\n` +
        `âŒ Incorrectas: ${incorrect}\n` +
        `ğŸ“Š Porcentaje: ${percentage}%\n\n` +
        `â±ï¸ Tiempo restante: ${Math.max(0, Math.ceil((session.timeoutAt!.getTime() - Date.now()) / 1000))}s`;

      return { success: true, message: progress };

    } catch (error) {
      console.error('Error obteniendo progreso:', error);
      return { success: false, message: 'âŒ Error obteniendo progreso' };
    }
  }

  // ==========================================
  // ğŸ”§ FUNCIONES PÃšBLICAS AUXILIARES
  // ==========================================
  
  static getDisplayName(subject: string): string {
    return this.TABLE_DISPLAY_NAMES[subject] || subject;
  }

  // ==========================================
  // ğŸ”§ FUNCIONES AUXILIARES PRIVADAS
  // ==========================================
  
  private static async getAvailableQuestionsCount(userId: string, tableName: string): Promise<number> {
    try {
      const result = await prisma.$queryRawUnsafe(`
        SELECT COUNT(*) as count FROM "${tableName}"
      `);
      
      return parseInt((result as any)[0].count);
    } catch (error) {
      console.error('âŒ Error contando preguntas:', error);
      console.error('âŒ Tabla consultada:', tableName);
      return 0;
    }
  }
  
  private static async getRandomUnusedQuestion(userId: string, tableName: string, excludeIds: string[]): Promise<any> {
    try {
      const excludeClause = excludeIds.length > 0 
        ? `AND id NOT IN (${excludeIds.map(id => `'${id}'`).join(',')})`
        : '';
      
      const result = await prisma.$queryRawUnsafe(`
        SELECT * FROM "${tableName}" 
        WHERE 1=1 ${excludeClause}
        ORDER BY RANDOM() 
        LIMIT 1
      `);
      
      return (result as any[])[0] || null;
    } catch (error) {
      console.error('âŒ Error obteniendo pregunta aleatoria:', error);
      return null;
    }
  }
  
  private static async findQuestionByPollId(pollId: string, tableName: string): Promise<any> {
    try {
      // Para sesiones de estudio, usar el mapping en memoria temporal
      if (global.studyPollMappings && global.studyPollMappings.has(pollId)) {
        const mapping = global.studyPollMappings.get(pollId);
        
        const result = await prisma.$queryRawUnsafe(`
          SELECT * FROM "${tableName}" WHERE id = $1
        `, mapping.questionId); // âœ… Pasar UUID directamente como string
        
        return (result as any[])[0] || null;
      }
      
      // Fallback: buscar en el mapeo de polls existente (para compatibilidad)
      const pollMapping = await prisma.telegramPoll.findFirst({
        where: { 
          pollId: pollId
        }
      });
      
      if (!pollMapping) return null;
      
      const result = await prisma.$queryRawUnsafe(`
        SELECT * FROM "${tableName}" WHERE id = $1
      `, pollMapping.questionId); // âœ… UUID como string, no parseInt
      
      return (result as any[])[0] || null;
    } catch (error) {
      console.error('âŒ Error buscando pregunta por pollId:', error);
      return null;
    }
  }
  

  
  private async generateSessionCompletionMessage(sessionId: string): Promise<string> {
    const session = await prisma.userStudySession.findUnique({
      where: { id: sessionId },
      include: {
        responses: true,
      },
    });

    if (!session) return 'Error: No se pudo generar el resumen de la sesiÃ³n.';

    // ğŸ§¹ LIMPIAR REGISTROS HUÃ‰RFANOS ANTES DEL CONTEO
    await this.cleanupOrphanedResponses(sessionId);

    // Obtener responses actualizadas despuÃ©s de la limpieza
    const cleanSession = await prisma.userStudySession.findUnique({
      where: { id: sessionId },
      include: {
        responses: true,
      },
    });

    if (!cleanSession) return 'Error: No se pudo generar el resumen de la sesiÃ³n.';

    // ğŸ”§ FIX CRÃTICO: Para sesiones de falladas, usar estadÃ­sticas de la materia real
    // No del subject "falladas" sino del subject real de las preguntas respondidas
    let statsSubject = cleanSession.subject;
    
    // Si es sesiÃ³n de falladas, obtener el subject de la primera respuesta real
    if (cleanSession.subject === 'falladas' || cleanSession.subject.endsWith('_falladas')) {
      const firstResponse = cleanSession.responses.find(r => r.answeredAt && r.subject !== 'falladas');
      if (firstResponse) {
        statsSubject = firstResponse.subject;
        console.log(`ğŸ”§ [generateSessionCompletionMessage] SesiÃ³n de falladas: usando estadÃ­sticas de ${statsSubject} en lugar de ${cleanSession.subject}`);
      }
    }

    const stats = await this.getUserStats(cleanSession.userId, statsSubject);

    console.log(`ğŸ“Š GENERANDO RESUMEN DE SESIÃ“N - ID: ${sessionId}`);
    console.log(`ğŸ“Š Total responses en BD: ${cleanSession.responses.length}`);
    console.log(`ğŸ“Š questionsAsked length: ${cleanSession.questionsAsked?.length || 0}`);
    console.log(`ğŸ“Š currentIndex: ${cleanSession.currentIndex}`);

    // ğŸ¯ USAR currentIndex COMO FUENTE DE VERDAD CONSISTENTE
    // Durante la sesiÃ³n usamos currentIndex en formatResponseFeedback, usemos eso mismo aquÃ­
    const totalQuestionsProcessed = cleanSession.currentIndex;
    console.log(`ğŸ“Š Total preguntas procesadas (currentIndex): ${totalQuestionsProcessed}`);

    // Filtrar solo las respuestas vÃ¡lidas que tienen answeredAt
    const validResponses = cleanSession.responses.filter(r => r.answeredAt !== null);
    console.log(`ğŸ“Š Responses con answeredAt: ${validResponses.length}`);

    // Separar por tipo - basÃ¡ndose en respuestas reales del usuario
    const actualUserResponses = validResponses.filter(r => r.timedOut !== true);
    const timedOutResponses = validResponses.filter(r => r.timedOut === true);
    
    console.log(`ğŸ“Š Respuestas reales del usuario: ${actualUserResponses.length}`);
    console.log(`ğŸ“Š Respuestas por timeout: ${timedOutResponses.length}`);

    // ğŸ” DEBUG DETALLADO: Mostrar cada respuesta individualmente
    console.log(`ğŸ” DEBUGGING DETALLADO DE RESPUESTAS:`);
    actualUserResponses.forEach((response, index) => {
      console.log(`   ğŸ“ Respuesta ${index + 1}:`);
      console.log(`      â””â”€ ID: ${response.id}`);
      console.log(`      â””â”€ questionId: ${response.questionId}`);
      console.log(`      â””â”€ isCorrect: ${response.isCorrect} (type: ${typeof response.isCorrect})`);
      console.log(`      â””â”€ timedOut: ${response.timedOut}`);
      console.log(`      â””â”€ selectedOption: ${response.selectedOption}`);
      console.log(`      â””â”€ answeredAt: ${response.answeredAt}`);
    });

    const correctAnswers = actualUserResponses.filter(r => r.isCorrect === true).length;
    const incorrectAnswers = actualUserResponses.filter(r => r.isCorrect === false).length;
    const timedOutCount = timedOutResponses.length;

    console.log(`ğŸ“Š Correctas: ${correctAnswers}`);
    console.log(`ğŸ“Š Incorrectas: ${incorrectAnswers}`);
    console.log(`ğŸ“Š Timeouts: ${timedOutCount}`);

    // ğŸ¯ EL TOTAL EN BD DEBE IGUALAR LAS PREGUNTAS PROCESADAS
    const totalResponsesInDB = correctAnswers + incorrectAnswers + timedOutCount;
    console.log(`ğŸ“Š Total respuestas en BD: ${totalResponsesInDB}`);

    console.log(`ğŸ“Š VERIFICACIÃ“N DE COHERENCIA:`);
    console.log(`   â””â”€ Preguntas procesadas (currentIndex): ${totalQuestionsProcessed}`);
    console.log(`   â””â”€ Respuestas registradas en BD: ${totalResponsesInDB}`);
    console.log(`   â””â”€ Â¿Coinciden?: ${totalQuestionsProcessed === totalResponsesInDB ? 'âœ… SÃ' : 'âŒ NO'}`);

    // Calcular precisiÃ³n solo sobre respuestas reales (sin timeouts)
    const accuracyBase = correctAnswers + incorrectAnswers;
    const accuracy = accuracyBase > 0 ? Math.round((correctAnswers / accuracyBase) * 100) : 0;

    console.log(`ğŸ“Š CONTEO FINAL:`);
    console.log(`   â””â”€ Preguntas objetivo: ${cleanSession.totalQuestions}`);
    console.log(`   â””â”€ Preguntas procesadas: ${totalQuestionsProcessed}`);
    console.log(`   â””â”€ Respuestas en BD: ${totalResponsesInDB}`);
    console.log(`   â””â”€ Correctas: ${correctAnswers}`);
    console.log(`   â””â”€ Incorrectas: ${incorrectAnswers}`);
    console.log(`   â””â”€ Timeouts: ${timedOutCount}`);
    console.log(`   â””â”€ PrecisiÃ³n: ${accuracy}%`);

    return this.generateCompletionMessage(stats, cleanSession.totalQuestions, correctAnswers, incorrectAnswers, accuracy, timedOutCount, totalQuestionsProcessed);
  }
  
  private generateCompletionMessage(
    stats: any, 
    totalQuestions: number,
    correctAnswers: number,
    incorrectAnswers: number,
    accuracy: number,
    timedOutCount: number,
    totalQuestionsProcessed: number
  ): string {
    const displayName = StudySessionService.getDisplayName(stats.subject);
    let message = `ğŸ **SesiÃ³n de estudio finalizada** ğŸ\n\n`;
    message += `ğŸ“š Materia: **${displayName}**\n`;
    message += `ğŸ“Š Preguntas de la sesiÃ³n: ${totalQuestions}\n`;
    message += `âœ… Respuestas correctas: ${correctAnswers}\n`;
    
    // ğŸ”§ FIX: Incluir timeouts en el conteo de respuestas incorrectas
    // Un timeout es efectivamente una respuesta incorrecta desde el punto de vista del usuario
    const totalIncorrect = incorrectAnswers + timedOutCount;
    message += `âŒ Respuestas incorrectas: ${totalIncorrect}\n`;
    
    // ğŸ¯ USAR currentIndex COMO FUENTE DE VERDAD CONSISTENTE
    // Ya no verificamos totalProcessed vs totalQuestions porque pueden ser diferentes
    // por preguntas saltadas, pero todas las respuestas procesadas se contabilizan correctamente
    const totalResponsesRegistered = correctAnswers + incorrectAnswers + timedOutCount;
    console.log(`ğŸ“Š [generateCompletionMessage] Respuestas registradas: ${totalResponsesRegistered}, Preguntas procesadas: ${totalQuestionsProcessed}`);
    
    // Solo mostrar "Procesadas" si hay una discrepancia real en los datos
    if (totalResponsesRegistered !== totalQuestionsProcessed) {
      console.log(`âš ï¸ [generateCompletionMessage] DISCREPANCIA: Respuestas en BD (${totalResponsesRegistered}) != Preguntas procesadas (${totalQuestionsProcessed})`);
      message += `âš ï¸ Procesadas: ${totalResponsesRegistered}/${totalQuestionsProcessed}\n`;
    }
    
    message += `ğŸ¯ PrecisiÃ³n: ${accuracy.toFixed(2)}%\n`;
    
    // Mensaje de racha mÃ¡s claro y contextual
    if (stats.currentStreak > 0) {
      message += `\nğŸ”¥ Â¡Racha consecutiva activa: **${stats.currentStreak}** aciertos seguidos!`;
    } else {
      message += `\nğŸ’­ Tu racha consecutiva se reiniciÃ³ (${correctAnswers} aciertos en esta sesiÃ³n).`;
    }
    
    message += `\n\nğŸ’ª Â¡Sigue estudiando!`;

    return message;
  }
  
  private static async updateUserStudyStats(userId: string, subject: string, isCorrect: boolean): Promise<void> {
    try {
      // Actualizar o crear estadÃ­sticas del usuario para esta materia
      await prisma.studyStats.upsert({
        where: {
          userId_subject: {
            userId,
            subject
          }
        },
        update: {
          totalQuestions: { increment: 1 },
          correctAnswers: isCorrect ? { increment: 1 } : undefined,
          lastStudyAt: new Date()
        },
        create: {
          userId,
          subject,
          totalQuestions: 1,
          correctAnswers: isCorrect ? 1 : 0,
          lastStudyAt: new Date()
        }
      });
    } catch (error) {
      console.error('âŒ Error actualizando estadÃ­sticas:', error);
    }
  }
  
  private static formatResponseFeedback(isCorrect: boolean, question: StudyQuestion, session: any): string {
    // ğŸ¯ USAR currentIndex como fuente de verdad - representa el progreso real despuÃ©s de procesar la respuesta
    const progress = `(${session.currentIndex}/${session.totalQuestions})`;
    console.log(`ğŸ“Š Progreso mostrado en feedback: ${progress} (currentIndex: ${session.currentIndex})`);
    
    if (isCorrect) {
      return `âœ… Â¡Correcto! ${progress}`;
    } else {
      const correctAnswer = question.options[question.correctAnswerIndex];
      return `âŒ Incorrecto ${progress}\n\nLa respuesta correcta era:\n*${correctAnswer}*`;
    }
  }

  /**
   * Enviar pregunta especÃ­fica al usuario
   */
  /**
   * Completar sesiÃ³n (mÃ©todo de instancia)
   */
  async completeSession(sessionId: string): Promise<void> {
    try {
      await prisma.userStudySession.update({
        where: { id: sessionId },
        data: { status: 'completed' }
      });

      // Cancelar timeout pendiente
      try {
        const scheduler = await getScheduler();
        scheduler.cancelTimeout(sessionId);
      } catch (error) {
        console.error('Error cancelando timeout:', error);
      }
    } catch (error) {
      console.error('Error completando sesiÃ³n:', error);
    }
  }

  private async sendQuestionToUser(session: any, question: StudyQuestion): Promise<{ success: boolean; message?: string }> {
    try {
      // Calcular el nÃºmero de pregunta a mostrar basado en preguntas ya enviadas + 1
      const questionNumber = session.questionsAsked ? session.questionsAsked.length + 1 : session.currentIndex + 1;
      console.log(`ğŸ“š Enviando pregunta ${questionNumber}/${session.totalQuestions} al usuario ${session.userId}`);
      console.log(`ğŸ“‹ ID de pregunta: ${question.id}`);

      const timeoutAt = new Date(Date.now() + 60000); // 1 minuto para responder

      // ğŸ”§ FIX: Para sesiones de falladas, usar el subject original de la pregunta
      // para que processPollAnswer pueda encontrar la pregunta correctamente
      const questionSubject = question.originalSubject || session.subject;
      
      // Preparar datos de la pregunta para el poll SIN responseId inicial
      const questionData: any = {
        id: question.id,
        question: question.question,
        options: question.options,
        correctAnswerIndex: question.correctAnswerIndex,
        subject: questionSubject, // Usar originalSubject si estÃ¡ disponible
        currentIndex: questionNumber, // Usar el nÃºmero calculado correctamente
        totalQuestions: session.totalQuestions,
        questionNumber: question.questionNumber
      };

      console.log(`ğŸ¯ Verificando viabilidad del poll para pregunta ${question.id}...`);

      // Enviar poll PRIMERO para verificar si es viable
      const pollResult = await this.sendStudyPoll(session.userId, questionData);

      if (!pollResult.success) {
        console.error(`âŒ Poll RECHAZADO para pregunta ${question.id} - opciones muy largas o error de envÃ­o`);
        console.log(`âš ï¸ Pregunta ${question.id} saltada - NO se crea ningÃºn registro en BD`);

        // Intentar con otra pregunta recursivamente sin incrementar currentIndex
        // Obtener estadÃ­sticas actualizadas para evitar repeticiÃ³n
        const stats = await this.getUserStats(session.userId, session.subject);
        const commandKey = `/${session.subject}`;
        const tableName = STUDY_COMMANDS[commandKey as keyof typeof STUDY_COMMANDS];
        
        if (tableName) {
          console.log(`ğŸ”„ Buscando pregunta alternativa para reemplazar ${question.id}...`);
          const nextQuestion = await this.getRandomQuestion(tableName, stats.questionsCompleted);
          if (nextQuestion) {
            console.log(`âœ… Pregunta alternativa encontrada: ${nextQuestion.id}`);
            return await this.sendQuestionToUser(session, nextQuestion);
          } else {
            console.error(`âŒ No se encontrÃ³ pregunta alternativa para ${question.id}`);
          }
        }
        
        return { success: false, message: 'No se pudo encontrar pregunta vÃ¡lida' };
      }

      console.log(`âœ… Poll ENVIADO exitosamente para pregunta ${question.id} - PollID: ${pollResult.pollId}`);

      // SOLO SI EL POLL SE ENVIÃ“ EXITOSAMENTE, crear el registro de respuesta
      const response = await prisma.studyResponse.create({
        data: {
          sessionId: session.id,
          userId: session.userId,
          subject: questionSubject, // Usar el subject correcto
          questionId: question.id,
          questionNumber: question.questionNumber,
          pollId: pollResult.pollId || '' // Usar el pollId devuelto
        }
      });

      console.log(`ğŸ“ Registro StudyResponse creado: ${response.id} para pregunta ${question.id}`);

      // âœ… SOLO SI EL POLL SE ENVIÃ“ EXITOSAMENTE, agregar a questionsAsked
      // NO INCREMENTAR currentIndex aquÃ­ - se harÃ¡ en processPollAnswer
      await prisma.userStudySession.update({
        where: { id: session.id },
        data: {
          questionsAsked: [...session.questionsAsked, question.id],
          lastActivityAt: new Date(),
          timeoutAt
        }
      });

      console.log(`ğŸ“‹ Pregunta ${question.id} agregada a questionsAsked. Total: ${session.questionsAsked.length + 1}`);

      // Programar timeout automÃ¡tico
      try {
        const scheduler = await getScheduler();
        scheduler.scheduleTimeout(session.id, timeoutAt);
        console.log(`â° Timeout programado para sesiÃ³n ${session.id} a las ${timeoutAt.toISOString()}`);
      } catch (error) {
        console.error('Error programando timeout:', error);
      }

      return { success: true };

    } catch (error) {
      console.error(`âŒ Error CRÃTICO enviando pregunta ${question.id} al usuario:`, error);
      return { success: false, message: 'Error enviando pregunta' };
    }
  }

  /**
   * Manejar timeout de pregunta
   */
  async handleQuestionTimeout(sessionId: string): Promise<void> {
    let shouldCompleteSession = false;
    let sessionIdForCompletion = '';
    let userId = '';

    await prisma.$transaction(async (tx) => {
      const session = await tx.userStudySession.findUnique({ where: { id: sessionId } });

      if (!session || session.status !== 'active' || !session.timeoutAt || session.timeoutAt > new Date()) {
        return; // SesiÃ³n no activa o no ha expirado
      }
      
      console.log(`[StudySession] Timeout detectado para sesiÃ³n ${session.id}`);

      // Incrementar currentIndex solo si es necesario para el timeout
      const questionsAnswered = session.questionsAsked ? session.questionsAsked.length : 0;
      
      const updatedSession = await tx.userStudySession.update({
        where: { id: session.id },
        data: {
          currentIndex: { increment: 1 }, // Contar como pregunta procesada por timeout
          timeoutAt: new Date(Date.now() + 60000), // Resetear para la siguiente
        },
      });

      // Crear registro de timeout
      await tx.studyResponse.create({
          data: {
              sessionId: session.id,
              userId: session.userId,
              subject: session.subject,
              questionId: "timeout", // ID genÃ©rico para timeouts
              questionNumber: questionsAnswered + 1,
              pollId: "timeout",
              timedOut: true,
              answeredAt: new Date()
          }
      });
      
      const { TelegramService } = await import('./telegramService');
      const telegramService = new TelegramService(process.env.TELEGRAM_BOT_TOKEN || '');
      await telegramService.sendMessage(session.userId, 'â° Â¡Tiempo agotado! Pasando a la siguiente pregunta.');

      if (updatedSession.currentIndex >= updatedSession.totalQuestions) {
        // Solo marcar la sesiÃ³n como completada en la transacciÃ³n
        await tx.userStudySession.update({
          where: { id: updatedSession.id },
          data: { status: 'completed', timeoutAt: null },
        });
        shouldCompleteSession = true;
        sessionIdForCompletion = sessionId;
        userId = session.userId;
      } else {
        // No hacer sendNextQuestion dentro de la transacciÃ³n
        // Se harÃ¡ despuÃ©s
      }
    }, {
      timeout: 15000, // 15 segundos de timeout
    });

    // Realizar acciones despuÃ©s de la transacciÃ³n
    if (shouldCompleteSession) {
      console.log(`ğŸ Generando resumen de sesiÃ³n completada por timeout: ${sessionIdForCompletion}...`);
      
      // Cancelar timeout pendiente
      try {
        const scheduler = await getScheduler();
        scheduler.cancelTimeout(sessionIdForCompletion);
      } catch (error) {
        console.error('Error cancelando timeout:', error);
      }
      
      // Generar y enviar resumen DESPUÃ‰S de confirmar la transacciÃ³n
      const summary = await this.generateSessionCompletionMessage(sessionIdForCompletion);
      const { TelegramService } = await import('./telegramService');
      const telegramService = new TelegramService(process.env.TELEGRAM_BOT_TOKEN || '');
      await telegramService.sendMessage(userId, summary);
    } else {
      // Enviar siguiente pregunta fuera de la transacciÃ³n
      await this.sendNextQuestion(sessionId);
    }
  }

  /**
   * Cancelar sesiÃ³n especÃ­fica
   */
  async cancelSession(sessionId: string): Promise<void> {
    try {
      await prisma.userStudySession.update({
        where: { id: sessionId },
        data: { status: 'cancelled' }
      });

      // Cancelar timeout pendiente
      try {
        const scheduler = await getScheduler();
        scheduler.cancelTimeout(sessionId);
      } catch (error) {
        console.error('Error cancelando timeout:', error);
      }
    } catch (error) {
      console.error('Error cancelando sesiÃ³n:', error);
    }
  }

  /**
   * Obtener pregunta aleatoria de una materia
   */
  private async getRandomQuestion(tableName: string, excludeIds: string[]): Promise<StudyQuestion | null> {
    try {
      // Construir query dinÃ¡micamente basado en el nombre de la tabla
      let query = `
        SELECT id, "questionNumber", question, options, "correctAnswerIndex", category, difficulty
        FROM "${tableName}" 
        WHERE "isActive" = true
      `;
      
      // Agregar exclusiones si las hay
      if (excludeIds.length > 0) {
        const placeholders = excludeIds.map((_, index) => `$${index + 1}`).join(',');
        query += ` AND id NOT IN (${placeholders})`;
      }
      
      query += ` ORDER BY RANDOM() LIMIT 1`;

      const result = excludeIds.length > 0 
        ? await prisma.$queryRawUnsafe(query, ...excludeIds)
        : await prisma.$queryRawUnsafe(query);
      const questions = result as any[];

      if (questions.length === 0) {
        console.log(`âŒ No se encontraron preguntas en tabla ${tableName} con exclusiones: ${excludeIds.length}`);
        return null;
      }

      console.log(`âœ… Pregunta aleatoria obtenida de tabla ${tableName}: ${questions[0].id}`);
      return {
        id: questions[0].id,
        questionNumber: questions[0].questionNumber,
        question: questions[0].question,
        options: questions[0].options,
        correctAnswerIndex: questions[0].correctAnswerIndex,
        category: questions[0].category,
        difficulty: questions[0].difficulty
      };

    } catch (error) {
      console.error('Error obteniendo pregunta aleatoria:', error);
      return null;
    }
  }

  /**
   * Obtener pregunta por ID de una materia especÃ­fica
   */
  private async getQuestionById(subject: string, questionId: string): Promise<StudyQuestion | null> {
    try {
      // ğŸ”§ FIX: Usar TABLE_MAPPING para obtener el nombre correcto de la tabla
      const tableName = StudySessionService.TABLE_MAPPING[subject];
      if (!tableName) {
        console.error(`âŒ Tabla no encontrada para subject: ${subject}`);
        return null;
      }

      const query = `
        SELECT id, "questionNumber", question, options, "correctAnswerIndex", category, difficulty
        FROM "${tableName}" 
        WHERE id = $1
      `;

      const result = await prisma.$queryRawUnsafe(query, questionId);
      const questions = result as any[];

      if (questions.length === 0) {
        console.log(`âŒ Pregunta con ID ${questionId} no encontrada en tabla ${tableName}`);
        return null;
      }

      console.log(`âœ… Pregunta encontrada: ${questions[0].id} en tabla ${tableName}`);
      return {
        id: questions[0].id,
        questionNumber: questions[0].questionNumber,
        question: questions[0].question,
        options: questions[0].options,
        correctAnswerIndex: questions[0].correctAnswerIndex,
        category: questions[0].category,
        difficulty: questions[0].difficulty,
        originalSubject: subject // Preservar el subject original para sesiones de falladas
      };

    } catch (error) {
      console.error('Error obteniendo pregunta por ID:', error);
      return null;
    }
  }

  /**
   * Obtener estadÃ­sticas del usuario para una materia
   */
  private async getUserStats(userId: string, subject: string): Promise<any> {
    try {
      let stats = await prisma.studyStats.findUnique({
        where: { 
          userId_subject: { userId, subject } 
        }
      });

      if (!stats) {
        stats = await prisma.studyStats.create({
          data: {
            userId,
            subject,
            questionsCompleted: []
          }
        });
      }

      return stats;
    } catch (error) {
      console.error('Error obteniendo estadÃ­sticas de usuario:', error);
      return { questionsCompleted: [] };
    }
  }

  /**
   * Actualizar estadÃ­sticas del usuario
   */
  private async updateUserStats(
    tx: any, // Acepta el cliente de transacciÃ³n
    userId: string,
    subject: string,
    isCorrect: boolean,
    responseTime: number,
    questionId: string,
    pollId: string,
    selectedOption: number,
    questionNumber: number
  ): Promise<void> {
    
    // ğŸ” DEBUG: Log entrada de funciÃ³n
    console.log(`ğŸ”§ [updateUserStats] INICIANDO para:`);
    console.log(`   â””â”€ userId: ${userId}`);
    console.log(`   â””â”€ questionId: ${questionId}`);
    console.log(`   â””â”€ pollId: ${pollId}`);
    console.log(`   â””â”€ isCorrect: ${isCorrect} (type: ${typeof isCorrect})`);
    console.log(`   â””â”€ selectedOption: ${selectedOption}`);
    console.log(`   â””â”€ questionNumber: ${questionNumber}`);
    // Buscar o crear estadÃ­sticas de estudio para la materia
    let stats = await tx.studyStats.findFirst({
      where: { userId, subject },
    });

    if (!stats) {
      stats = await tx.studyStats.create({
        data: {
          userId,
          subject,
          questionsCompleted: [],
        },
      });
    }

    // Actualizar estadÃ­sticas
    const newCorrectAnswers = stats.correctAnswers + (isCorrect ? 1 : 0);
    const newTotalQuestions = stats.totalQuestions + 1;
    const newCurrentStreak = isCorrect ? stats.currentStreak + 1 : 0;
    
    // Evitar aÃ±adir duplicados
    const newQuestionsCompleted = Array.from(new Set([...stats.questionsCompleted, questionId]));

    await tx.studyStats.update({
      where: { id: stats.id },
      data: {
        totalQuestions: newTotalQuestions,
        correctAnswers: newCorrectAnswers,
        currentStreak: newCurrentStreak,
        bestStreak: Math.max(stats.bestStreak, newCurrentStreak),
        questionsCompleted: newQuestionsCompleted,
      },
    });

    // ESTRATEGIA MEJORADA: Buscar registro existente primero para debugging
    const existingResponse = await tx.studyResponse.findFirst({
      where: {
        userId,
        questionId,
        answeredAt: null
      }
    });

    console.log(`ğŸ” BUSCANDO REGISTRO - userId: ${userId}, questionId: ${questionId}`);
    console.log(`ğŸ“ Registro encontrado:`, existingResponse ? { 
      id: existingResponse.id, 
      pollId: existingResponse.pollId, 
      answeredAt: existingResponse.answeredAt 
    } : 'NO ENCONTRADO');

    let updateResult: any = { count: 0 };

    if (existingResponse) {
      // Actualizar el registro existente usando el ID especÃ­fico
      updateResult = await tx.studyResponse.updateMany({
        where: {
          id: existingResponse.id, // Usar ID especÃ­fico en lugar de criterios mÃºltiples
          answeredAt: null // VerificaciÃ³n adicional de seguridad
        },
        data: {
          pollId: pollId,
          selectedOption: selectedOption,
          isCorrect,
          responseTime,
          answeredAt: new Date(),
        },
      });
      
      console.log(`âœ… ACTUALIZACIÃ“N EXITOSA - Registros actualizados: ${updateResult.count}`);
    } else {
      console.log(`âš ï¸ NO SE ENCONTRÃ“ REGISTRO PARA ACTUALIZAR - userId: ${userId}, questionId: ${questionId}`);
      
      // FALLBACK: Crear un nuevo registro si no se encontrÃ³ uno existente
      // Esto asegura que la respuesta se registre independientemente
      console.log(`ğŸ”§ CREANDO REGISTRO FALLBACK para asegurar que la respuesta se registre`);
      
      try {
        const fallbackResponse = await tx.studyResponse.create({
          data: {
            sessionId: existingResponse?.sessionId || 'fallback',
            userId,
            subject,
            questionId,
            questionNumber,
            pollId,
            selectedOption,
            isCorrect,
            responseTime,
            answeredAt: new Date(),
          }
        });
        
        console.log(`âœ… REGISTRO FALLBACK CREADO EXITOSAMENTE - ID: ${fallbackResponse.id}`);
        updateResult = { count: 1 }; // Simular Ã©xito para logging
      } catch (fallbackError) {
        console.error(`âŒ ERROR CREANDO REGISTRO FALLBACK:`, fallbackError);
      }
    }
    
    // Logging detallado del resultado
    console.log(`ğŸ“Š RESULTADO FINAL - userId: ${userId}, questionId: ${questionId}, isCorrect: ${isCorrect}, registrosActualizados: ${updateResult.count}`);
    
    // ğŸš¨ ALERTA SI TODAVÃA NO SE PROCESÃ“ CORRECTAMENTE
    if (updateResult.count === 0) {
      console.error(`âŒ FALLO CRÃTICO: NO SE PUDO REGISTRAR LA RESPUESTA - userId: ${userId}, questionId: ${questionId}, pollId: ${pollId}`);
      
      // Debug adicional: Buscar TODOS los registros para este usuario/pregunta
      const allUserResponses = await tx.studyResponse.findMany({
        where: { userId, questionId },
        select: { id: true, pollId: true, answeredAt: true, isCorrect: true, sessionId: true }
      });
      console.log(`ğŸ” TODOS los registros para userId ${userId} + questionId ${questionId}:`, allUserResponses);
      
      // Debug adicional: Buscar por pollId
      const pollResponses = await tx.studyResponse.findMany({
        where: { pollId },
        select: { id: true, userId: true, questionId: true, answeredAt: true, isCorrect: true }
      });
      console.log(`ğŸ” TODOS los registros para pollId ${pollId}:`, pollResponses);
    }

    // IntegraciÃ³n de GamificaciÃ³n - Intentar pero no fallar si hay error
    try {
      const userResponseForGamification: UserResponse = {
        telegramUserId: userId, // userId ya es el telegramUserId en este contexto
        questionId,
        isCorrect,
        responseTime,
      };
      await GamificationService._processUserResponseWithinTransaction(userResponseForGamification, tx);
      console.log(`âœ… GamificaciÃ³n procesada para usuario ${userId}`);
    } catch (error) {
      console.error('âš ï¸ Error en gamificaciÃ³n (no afecta al estudio):', error);
      // No relanzar el error para que no afecte al sistema de estudio
    }
  }

  /**
   * Reiniciar pool de preguntas para una materia
   */
  private async resetQuestionPool(userId: string, subject: string): Promise<void> {
    try {
      await prisma.studyStats.update({
        where: { 
          userId_subject: { userId, subject } 
        },
        data: {
          questionsCompleted: []
        }
      });
    } catch (error) {
      console.error('Error reiniciando pool de preguntas:', error);
    }
  }

  /**
   * Limpiar metadatos de la pregunta (formato: // contenido :: mÃ¡s contenido ::)
   */
  private cleanQuestionMetadata(questionText: string): string {
    if (!questionText) return questionText;
    
    // Eliminar el patrÃ³n: // [contenido] :: [mÃ¡s contenido] ::
    // Usar greedy match (.*) para ir hasta el Ãºltimo "::" 
    // Ejemplo: "// Pregunta 3. ConstituciÃ³n EspaÃ±ola ::ArtÃ­culo 76.2::  Â¿quÃ© establece..."
    // Resultado: "Â¿quÃ© establece..."
    const cleanedQuestion = questionText.replace(/^\/\/.*::\s*/, '').trim();
    
    return cleanedQuestion;
  }

  /**
   * Enviar poll de estudio a Telegram
   */
  private async sendStudyPoll(userId: string, questionData: any): Promise<{ success: boolean; pollId?: string }> {
    try {
      console.log(`ğŸ“Š ENVIANDO POLL DE ESTUDIO - Usuario: ${userId}, Pregunta: ${questionData.id}`);

      // ğŸ§¹ LIMPIAR METADATOS ANTES DE USAR LA PREGUNTA
      const rawQuestion = questionData.question || 'Pregunta no disponible';
      const question = this.cleanQuestionMetadata(rawQuestion);
      
      // ğŸ” DEBUG: Mostrar antes y despuÃ©s de la limpieza si hay cambios
      if (rawQuestion !== question) {
        console.log(`ğŸ§¹ PREGUNTA LIMPIADA:`);
        console.log(`   ğŸ“ Antes: ${rawQuestion.substring(0, 100)}...`);
        console.log(`   âœ¨ DespuÃ©s: ${question.substring(0, 100)}...`);
      }
      
      // Las opciones pueden venir como array de strings
      let options: string[] = [];
      if (Array.isArray(questionData.options)) {
        // Limpiar opciones eliminando porcentajes al inicio (ej: "%100%texto" -> "texto")
        options = questionData.options.map((option: string) => {
          // Eliminar porcentajes al inicio como "%100%" o "%-33.33333%"
          return option.replace(/^%[-\d.]+%/, '').trim();
        }).filter((option: string) => option && option.length > 0);
      }

      if (options.length < 2) {
        console.error('âŒ Opciones insuficientes para la pregunta:', questionData.id);
        return { success: false };
      }

      // Verificar lÃ­mite de caracteres de Telegram (100 caracteres por opciÃ³n)
      const maxOptionLength = options.reduce((max, option) => Math.max(max, option.length), 0);
      if (maxOptionLength > 100) {
        console.log(`âš ï¸ PREGUNTA SALTADA: OpciÃ³n muy larga (${maxOptionLength} caracteres, mÃ¡ximo 100) - ID: ${questionData.id}`);
        return { success: false };
      }

      // El correctAnswerIndex ya viene 0-indexed desde la base de datos
      const originalCorrectIndex = questionData.correctAnswerIndex !== undefined ? 
        questionData.correctAnswerIndex : 0;

      // Randomizar opciones para evitar que la respuesta correcta siempre sea la A
      const optionsWithIndex = options.map((option: string, index: number) => ({
        option,
        originalIndex: index
      }));

      // Mezclar las opciones aleatoriamente
      const shuffledOptions = [...optionsWithIndex].sort(() => Math.random() - 0.5);
      
      // Encontrar la nueva posiciÃ³n de la respuesta correcta despuÃ©s del shuffle
      const newCorrectIndex = shuffledOptions.findIndex(
        item => item.originalIndex === originalCorrectIndex
      );

      // Extraer solo las opciones mezcladas para el poll
      const finalOptions = shuffledOptions.map(item => item.option);

      console.log('ğŸ² Opciones randomizadas:', {
        original: options,
        shuffled: finalOptions,
        originalCorrectIndex,
        newCorrectIndex,
        correctAnswer: finalOptions[newCorrectIndex]
      });

      // Formatear header con informaciÃ³n de progreso
      const header = `ğŸ¯ PREGUNTA ${questionData.currentIndex}/${questionData.totalQuestions}\n` +
                    `ğŸ“š ${StudySessionService.getDisplayName(questionData.subject)}\n` +
                    `â±ï¸ Tiempo lÃ­mite: 1 minuto\n\n`;

      const fullQuestion = this.truncatePollQuestion(header, question, 280);

      const pollData = {
        chat_id: userId,
        question: fullQuestion,
        options: JSON.stringify(finalOptions), // Usar opciones mezcladas
        type: 'quiz',
        correct_option_id: newCorrectIndex, // Usar nuevo Ã­ndice despuÃ©s del shuffle
        is_anonymous: false,
        allows_multiple_answers: false,
        explanation: `âœ… La respuesta correcta es: ${finalOptions[newCorrectIndex]}`,
        open_period: 60 // 1 minuto lÃ­mite
      };

      const BOT_TOKEN = process.env.TELEGRAM_BOT_TOKEN;
      if (!BOT_TOKEN) {
        console.error('âŒ TELEGRAM_BOT_TOKEN no configurado');
        return { success: false };
      }

      const response = await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/sendPoll`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(pollData),
      });

      if (!response.ok) {
        const errorData = await response.json();
        console.error('âŒ Error enviando poll de estudio:', errorData);
        return { success: false };
      }

      const data = await response.json();
      const pollId = data.result.poll.id;

      // Actualizar el pollId en la respuesta si se proporcionÃ³ responseId
      if (questionData.responseId) {
        await prisma.studyResponse.update({
          where: { id: questionData.responseId },
          data: { pollId }
        });
      }

      // Crear mapping en base de datos para persistencia entre requests
      await prisma.telegramPollMapping.create({
        data: {
          pollId,
          questionId: questionData.id,
          subject: questionData.subject
        }
      });

      // TambiÃ©n mantener en memoria para compatibilidad
      if (!global.studyPollMappings) {
        global.studyPollMappings = new Map();
      }
      
      global.studyPollMappings.set(pollId, {
        questionId: questionData.id,
        subject: questionData.subject,
        correctAnswerIndex: newCorrectIndex,
        responseId: questionData.responseId,
        timestamp: Date.now()
      });

      console.log(`âœ… Poll de estudio enviado - ID: ${pollId}`);
      return { success: true, pollId };

    } catch (error) {
      console.error('âŒ Error enviando poll de estudio:', error);
      return { success: false };
    }
  }

  /**
   * Truncar pregunta para cumplir lÃ­mites de Telegram
   */
  private truncatePollQuestion(header: string, question: string, maxLength: number = 300): string {
    const fullText = header + question;
    
    if (fullText.length <= maxLength) {
      return fullText;
    }
    
    // Calcular espacio disponible para la pregunta
    const availableSpace = maxLength - header.length - 3; // 3 para "..."
    
    if (availableSpace <= 0) {
      // Si el header es muy largo, truncar todo
      return fullText.substring(0, maxLength - 3) + '...';
    }
    
    // Truncar solo la pregunta
    const truncatedQuestion = question.substring(0, availableSpace) + '...';
    return header + truncatedQuestion;
  }

  /**
   * Cancelar sesiÃ³n por comando /stop
   */
  async stopSession(userId: string): Promise<{ success: boolean; message: string }> {
    try {
      const session = await prisma.userStudySession.findFirst({
        where: { userId, status: 'active' }
      });

      if (!session) {
        return { success: false, message: 'âŒ No tienes ninguna sesiÃ³n activa' };
      }

      await this.cancelSession(session.id);

      return { 
        success: true, 
        message: `ğŸ›‘ **SesiÃ³n cancelada**\n\nğŸ“š Materia: ${session.subject.toUpperCase()}\nğŸ“Š Progreso: ${session.currentIndex}/${session.totalQuestions}\n\nğŸ’¡ Puedes iniciar una nueva sesiÃ³n cuando quieras` 
      };

    } catch (error) {
      console.error('Error deteniendo sesiÃ³n:', error);
      return { success: false, message: 'âŒ Error cancelando sesiÃ³n' };
    }
  }

  private async cleanupOrphanedResponses(sessionId: string): Promise<void> {
    try {
      // Buscar registros de la sesiÃ³n que nunca fueron completados
      // (no tienen answeredAt y no son timeouts legÃ­timos)
      const orphanedResponses = await prisma.studyResponse.findMany({
        where: {
          sessionId: sessionId,
          answeredAt: null,
          timedOut: { not: true }, // No son timeouts legÃ­timos
          createdAt: {
            lte: new Date(Date.now() - 2 * 60 * 1000) // Creados hace mÃ¡s de 2 minutos
          }
        }
      });

      if (orphanedResponses.length > 0) {
        const deleteCount = await prisma.studyResponse.deleteMany({
          where: {
            id: {
              in: orphanedResponses.map(r => r.id)
            }
          }
        });

        console.log(`ğŸ§¹ ${deleteCount.count} registros huÃ©rfanos eliminados de sesiÃ³n ${sessionId}`);
        orphanedResponses.forEach(r => {
          console.log(`   - Registro huÃ©rfano: ${r.id} (pregunta: ${r.questionId})`);
        });
      } else {
        console.log(`âœ… No se encontraron registros huÃ©rfanos en sesiÃ³n ${sessionId}`);
      }
    } catch (error) {
      console.error('Error limpiando respuestas huÃ©rfanas:', error);
    }
  }
}

// Exportar instancia por defecto para facilitar el uso
export const studySessionService = new StudySessionService(); 