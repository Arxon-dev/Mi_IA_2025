// Tournament Service - TypeScript wrapper for tournament-instant-v2.js
import { prisma } from '@/lib/prisma';

// Types for tournament functions
interface TournamentManager {
  isRunning: boolean;
  start(): void;
  handlePollAnswer(pollAnswer: any): Promise<boolean>;
}

interface TournamentPollAnswer {
  poll_id: string;
  user: {
    id: number;
    is_bot: boolean;
    first_name: string;
    last_name?: string;
    username?: string;
  };
  option_ids: number[];
}

export class TournamentService {
  private static instance: TournamentService;
  private tournamentModule: any = null;
  private initialized = false;

  private constructor() {}

  public static getInstance(): TournamentService {
    if (!TournamentService.instance) {
      TournamentService.instance = new TournamentService();
    }
    return TournamentService.instance;
  }

  /**
   * ‚úÖ M√âTODO PARA CALCULAR PRIZEPOOL DIN√ÅMICAMENTE
   */
  private calculateDynamicPrizePool(participantCount: number, questionsCount: number): number {
    // F√≥rmula: Base por pregunta + bonus por participante + multiplicador de competitividad
    const basePerQuestion = 5; // 5 puntos base por pregunta
    const participantBonus = participantCount * 10; // 10 puntos adicionales por participante
    const competitivenessMultiplier = participantCount > 10 ? 1.5 : 1.2; // M√°s atractivo con m√°s gente
    
    const basePrize = (questionsCount * basePerQuestion) + participantBonus;
    const finalPrize = Math.round(basePrize * competitivenessMultiplier);
    
    // M√≠nimo garantizado de 100 puntos para que sea atractivo
    return Math.max(finalPrize, 100);
  }

  /**
   * Initialize the tournament module dynamically
   */
  private async initializeTournamentModule() {
    if (this.initialized) return;

    try {
      // En lugar de importar din√°micamente, vamos a marcarlo como no disponible
      // y usar la l√≥gica interna del servicio TypeScript
      console.log('üèÜ Inicializando sistema de torneos integrado (modo interno)...');
      this.tournamentModule = {
        isRunning: true,
        getTournamentManager: () => ({
          isRunning: true,
          start: () => console.log('‚úÖ Tournament manager started (internal mode)'),
          handlePollAnswer: async (pollAnswer: any) => {
            return await this.handleTournamentPollAnswer(pollAnswer);
          }
        }),
        ensureTournamentManagerRunning: () => ({
          isRunning: true,
          start: () => console.log('‚úÖ Tournament manager running (internal mode)'),
          handlePollAnswer: async (pollAnswer: any) => {
            return await this.handleTournamentPollAnswer(pollAnswer);
          }
        })
      };
      this.initialized = true;
      console.log('‚úÖ Tournament module initialized successfully (internal mode)');
    } catch (error) {
      console.error('‚ùå Error initializing tournament module:', error);
      this.tournamentModule = null;
      this.initialized = true; // Marcar como inicializado para evitar reintentos
    }
  }

  /**
   * Get tournament manager instance
   */
  public async getTournamentManager(): Promise<TournamentManager | null> {
    await this.initializeTournamentModule();
    
    if (!this.tournamentModule) {
      console.warn('‚ö†Ô∏è Tournament module not available');
      return null;
    }

    try {
      return this.tournamentModule.getTournamentManager();
    } catch (error) {
      console.error('‚ùå Error getting tournament manager:', error);
      return null;
    }
  }

  /**
   * Handle tournament poll answer
   */
  public async handleTournamentPollAnswer(pollAnswer: TournamentPollAnswer): Promise<boolean> {
    // Using imported prisma instance
    
    try {
      const userId = pollAnswer.user.id.toString();
      const pollId = pollAnswer.poll_id;
      const selectedOption = pollAnswer.option_ids[0];

      console.log(`üèÜ Procesando respuesta de torneo: Poll ${pollId}, Usuario ${userId}, Opci√≥n ${selectedOption}`);

      // Buscar si es una respuesta de torneo usando los nombres de campos correctos
      const response = await prisma.tournamentresponse.findFirst({
        where: {
          pollid: pollId
        }
      });

      if (!response) {
        console.log(`‚ùå No se encontr√≥ respuesta de torneo para poll ${pollId}`);
        return false;
      }

      console.log(`‚úÖ Encontrada respuesta de torneo: ${response.id}`);
      
      // Actualizar la respuesta con la opci√≥n seleccionada
      await prisma.tournamentresponse.update({
        where: { id: response.id },
        data: {
          selectedoption: selectedOption,
          answeredat: new Date(),
          iscorrect: selectedOption === 0 // Asumiendo que la opci√≥n 0 es correcta
        }
      });

      console.log(`‚úÖ Respuesta de torneo actualizada correctamente`);
      return true;

    } catch (error) {
      console.error('‚ùå Error procesando respuesta de torneo:', error);
      return false;
    }
  }

  /**
   * Normalize question data from different sources
   */
  private normalizeQuestionData(questionData: any, sourceTable: string) {
    if (sourceTable === 'ExamenOficial2024' || sourceTable === 'ExamenOficial2018') {
      // Para ambas tablas 2018 y 2024, las opciones est√°n en un array
      let options: any[] = [];
      try {
        options = typeof questionData.options === 'string' 
          ? JSON.parse(questionData.options) 
          : questionData.options || [];
      } catch (error) {
        console.error('‚ùå Error parseando opciones:', error);
        options = [];
      }

      return {
        questionText: questionData.question,
        options: options,
        correctOptionIndex: questionData.correctAnswerIndex
      };
    } else if (sourceTable === 'ValidQuestion') {
      // Para ValidQuestion, usar parsedQuestion y parsedOptions
      let options: any[] = [];
      try {
        if (typeof questionData.parsedOptions === 'string') {
          options = JSON.parse(questionData.parsedOptions);
        } else if (Array.isArray(questionData.parsedOptions)) {
          options = questionData.parsedOptions;
        } else if (typeof questionData.parsedOptions === 'object' && questionData.parsedOptions !== null) {
          // Para ValidQuestion.parsedOptions que es un objeto con keys numericas
          const optionsObj = questionData.parsedOptions;
          options = Object.keys(optionsObj).sort().map(key => optionsObj[key]);
        } else {
          options = [];
        }
      } catch (error) {
        console.error('‚ùå Error parseando opciones de ValidQuestion:', error);
        options = [];
      }

      return {
        questionText: questionData.parsedQuestion,
        options: options,
        correctOptionIndex: questionData.correctAnswerIndex
      };
    }

    // Fallback por si acaso
    return {
      questionText: questionData.question || questionData.questionText || questionData.parsedQuestion,
      options: [],
      correctOptionIndex: 0
    };
  }

  /**
   * Ensure tournament manager is running
   */
  public async ensureTournamentManagerRunning(): Promise<TournamentManager | null> {
    await this.initializeTournamentModule();
    
    if (!this.tournamentModule) {
      console.warn('‚ö†Ô∏è Tournament module not available');
      return null;
    }

    try {
      return this.tournamentModule.ensureTournamentManagerRunning();
    } catch (error) {
      console.error('‚ùå Error ensuring tournament manager is running:', error);
      return null;
    }
  }

  /**
   * Check if tournament system is available
   */
  public async isAvailable(): Promise<boolean> {
    await this.initializeTournamentModule();
    return this.tournamentModule !== null;
  }

  /**
   * Get tournament list for user
   */
  public async getTournamentList(userId: string) {
    // Using imported prisma instance
    
    try {
      const tournaments = await prisma.tournament.findMany({
        where: {
          status: {
            in: ['open', 'active', 'upcoming']
          }
        },
        include: {
          _count: {
            select: { participants: true }
          },
          participants: {
            where: { userid: userId },
            select: { id: true, status: true }
          }
        },
        orderBy: { scheduleddate: 'asc' }
      });

      return tournaments;
    } catch (error) {
      console.error('‚ùå Error getting tournament list:', error);
      return [];
    } finally {
      await prisma.$disconnect();
    }
  }

  /**
   * Join tournament
   */
  public async joinTournament(tournamentId: string, userId: string) {
    // Using imported prisma instance
    
    try {
      // Check if tournament exists and is open for registration
      const tournament = await prisma.tournament.findUnique({
        where: { id: tournamentId },
        include: {
          _count: {
            select: { participants: true }
          },
          participants: {
            where: { userid: userId },
            select: { id: true, status: true }
          }
        }
      });

      if (!tournament) {
        return { success: false, message: 'Tournament not found' };
      }

      if (tournament.participants.length > 0) {
        return { success: false, message: 'Already registered for this tournament' };
      }

      if (tournament.maxparticipants && tournament._count.participants >= tournament.maxparticipants) {
        return { success: false, message: 'Tournament is full' };
      }

      // Create participant
      const participant = await prisma.tournamentparticipant.create({
        data: {
          id: `${tournamentId}-${userId}-${Date.now()}`,
          tournamentid: tournamentId,
          userid: userId,
          status: 'registered'
        }
      });

      // Update tournament questions count if needed
      if (tournament.questionscount === 0) {
        await prisma.tournament.update({
          where: { id: tournamentId },
          data: {
            questionscount: 50, // Default questions count
            prizepool: tournament.prizepool || 100
          }
        });
      }

      return { success: true, participant };
    } catch (error) {
      console.error('‚ùå Error joining tournament:', error);
      return { success: false, message: 'Error joining tournament' };
    } finally {
      await prisma.$disconnect();
    }
  }

  /**
   * Leave tournament
   */
  public async leaveTournament(tournamentId: string, userId: string) {
    // Using imported prisma instance
    
    try {
      await prisma.tournamentparticipant.deleteMany({
        where: {
          tournamentid: tournamentId,
          userid: userId
        }
      });

      return { success: true };
    } catch (error) {
      console.error('‚ùå Error leaving tournament:', error);
      return { success: false, message: 'Error leaving tournament' };
    } finally {
      await prisma.$disconnect();
    }
  }

  /**
   * Get user tournament history
   */
  public async getUserTournamentHistory(userId: string) {
    // Using imported prisma instance
    
    try {
      const participations = await prisma.tournamentparticipant.findMany({
        where: { userid: userId },
        include: {
          tournament: {
            select: {
              id: true,
              name: true,
              status: true,
              scheduleddate: true,
              actualendtime: true,
              questionscount: true
            }
          },
          responses: {
            select: {
              id: true,
              iscorrect: true,
              selectedoption: true,
              pointsawarded: true,
              answeredat: true
            }
          }
        },
        orderBy: { registeredat: 'desc' }
      });

      return participations;
    } catch (error) {
      console.error('‚ùå Error getting tournament history:', error);
      return [];
    } finally {
      await prisma.$disconnect();
    }
  }

  /**
   * Send next question if needed based on tournament rules
   */
  private async sendNextQuestionIfNeeded(participant: any, prisma: any) {
    try {
      const tournament = participant.tournament;
      const currentQuestionNumber = participant.currentQuestion;
      
      console.log(`üîç Verificando siguiente pregunta para ${participant.user.firstName} - Pregunta actual: ${currentQuestionNumber}/${tournament.questionscount}`);

      // Verificar si hay m√°s preguntas
      if (currentQuestionNumber > tournament.questionscount) {
        console.log(`üèÅ ${participant.user.firstName} ha completado todas las preguntas del torneo`);
        
        // Marcar participante como completado
        await prisma.tournamentparticipant.update({
          where: { id: participant.id },
          data: { 
            completedat: new Date(),
            status: 'completed'
          }
        });
        
        // Enviar mensaje personal de finalizaci√≥n
        await this.sendTournamentCompletionMessage(participant, tournament, prisma);
        
        // Verificar si el torneo debe finalizar
        await this.checkTournamentCompletion(tournament.id, prisma);
        return;
      }

      // Buscar la siguiente pregunta
      const nextQuestion = await prisma.tournamentquestion.findFirst({
        where: {
          tournamentid: tournament.id,
          questionnumber: currentQuestionNumber
        }
      });

      if (!nextQuestion) {
        console.log(`‚ö†Ô∏è No se encontr√≥ la pregunta ${currentQuestionNumber} para el torneo`);
        return;
      }

      // ‚úÖ IMPLEMENTACI√ìN COMPLETA: Enviar la siguiente pregunta autom√°ticamente
      console.log(`üì§ Enviando pregunta ${currentQuestionNumber} a ${participant.user.firstName}`);
      console.log(`üìã Pregunta siguiente: ID ${nextQuestion.questionid} de ${nextQuestion.sourcetable}`);

      // Obtener datos de la pregunta desde la tabla correspondiente
      let questionData;
      if (nextQuestion.sourcetable === 'ExamenOficial2018') {
        questionData = await prisma.examenOficial2018.findUnique({
          where: { id: nextQuestion.questionid }
        });
      } else if (nextQuestion.sourcetable === 'ExamenOficial2024') {
        questionData = await prisma.examenOficial2024.findUnique({
          where: { id: nextQuestion.questionid }
        });
      } else if (nextQuestion.sourcetable === 'ValidQuestion') {
        questionData = await prisma.validQuestion.findUnique({
          where: { id: nextQuestion.questionid }
        });
      }

      if (!questionData) {
        console.error(`‚ùå No se encontraron datos para la pregunta ${nextQuestion.questionid}`);
        return;
      }

      // Normalizar datos de la pregunta
      const normalizedQuestion = this.normalizeQuestionData(questionData, nextQuestion.sourcetable);
      
      // Crear registro de respuesta para tracking
      const tournamentResponse = await prisma.tournamentresponse.create({
        data: {
          participantid: participant.id,
          questionid: nextQuestion.id,
          questionnumber: currentQuestionNumber,
          pollid: '' // Se actualizar√° despu√©s del env√≠o
        }
      });

      // Enviar poll via Telegram
      const success = await this.sendTelegramPoll(
        participant.user.telegramUserId,
        normalizedQuestion.questionText,
        normalizedQuestion.options,
        normalizedQuestion.correctOptionIndex,
        currentQuestionNumber,
        tournament.questionscount,
        tournament.name
      );

      if (success.success && success.pollId) {
        // Actualizar el pollId en el registro de respuesta
        await prisma.tournamentresponse.update({
          where: { id: tournamentResponse.id },
          data: { pollid: success.pollId }
        });
        console.log(`‚úÖ Pregunta ${currentQuestionNumber} enviada exitosamente a ${participant.user.firstName} (Poll ID: ${success.pollId})`);
      } else if (success.reason === 'question_too_long') {
        console.warn(`‚ö†Ô∏è Pregunta ${currentQuestionNumber} demasiado larga (${success.questionLength} chars). Buscando pregunta alternativa...`);
        
        // Buscar una pregunta alternativa v√°lida del mismo torneo
        const alternativeQuestion = await this.findAlternativeValidQuestion(
          tournament.id, 
          nextQuestion.id,
          currentQuestionNumber,
          prisma
        );
        
        if (alternativeQuestion) {
          console.log(`üîÑ Usando pregunta alternativa: ID ${alternativeQuestion.questionid} de ${alternativeQuestion.sourcetable}`);
          
          // Obtener datos de la pregunta alternativa
          let alternativeQuestionData;
          if (alternativeQuestion.sourcetable === 'ExamenOficial2018') {
            alternativeQuestionData = await prisma.examenOficial2018.findUnique({
              where: { id: alternativeQuestion.questionid }
            });
          } else if (alternativeQuestion.sourcetable === 'ExamenOficial2024') {
            alternativeQuestionData = await prisma.examenOficial2024.findUnique({
              where: { id: alternativeQuestion.questionid }
            });
          } else if (alternativeQuestion.sourcetable === 'ValidQuestion') {
            alternativeQuestionData = await prisma.validQuestion.findUnique({
              where: { id: alternativeQuestion.questionid }
            });
          }
          
          if (alternativeQuestionData) {
            const normalizedAlternative = this.normalizeQuestionData(alternativeQuestionData, alternativeQuestion.sourcetable);
            
            // Intentar enviar la pregunta alternativa
            const alternativeSuccess = await this.sendTelegramPoll(
              participant.user.telegramUserId,
              normalizedAlternative.questionText,
              normalizedAlternative.options,
              normalizedAlternative.correctOptionIndex,
              currentQuestionNumber,
              tournament.questionscount,
              tournament.name
            );
            
            if (alternativeSuccess.success && alternativeSuccess.pollId) {
              // Actualizar el registro para usar la pregunta alternativa
              await prisma.tournamentresponse.update({
                where: { id: tournamentResponse.id },
                data: { 
                  pollid: alternativeSuccess.pollId,
                  questionid: alternativeQuestion.id
                }
              });
              console.log(`‚úÖ Pregunta alternativa ${currentQuestionNumber} enviada exitosamente a ${participant.user.firstName} (Poll ID: ${alternativeSuccess.pollId})`);
            } else {
              console.error(`‚ùå Error enviando pregunta alternativa ${currentQuestionNumber} a ${participant.user.firstName}`);
            }
          }
        }
      } else {
        console.error(`‚ùå Error enviando pregunta ${currentQuestionNumber} a ${participant.user.firstName}. Motivo: ${success.reason || 'Desconocido'}`);
        
        // ‚úÖ MEJORAR LOG DE ERRORES CON M√ÅS DETALLES
        if (success.reason === 'question_too_long') {
          console.error(`üìè Pregunta rechazada por longitud: ${success.questionLength} caracteres (m√°ximo 1024)`);
        }
        
        // ‚úÖ CONTINUAR ENV√çO AUNQUE FALLE UNA PREGUNTA (RESILENCIA MEJORADA)
        console.log(`üîÑ Continuando torneo para ${participant.user.firstName} sin esta pregunta...`);
        
        // Marcar la pregunta como respondida para continuar
        await prisma.tournamentresponse.update({
          where: { id: tournamentResponse.id },
          data: { 
            pollid: 'SKIPPED_' + Date.now(),
            iscorrect: false,
            pointsawarded: 0,
            answeredat: new Date()
          }
        });
        
        // Actualizar progreso del participante para continuar
        await prisma.tournamentparticipant.update({
          where: { id: participant.id },
          data: { currentquestion: currentQuestionNumber + 1 }
        });
        
        // Intentar enviar la siguiente pregunta inmediatamente
        setTimeout(() => {
          this.sendNextQuestionIfNeeded(participant, prisma);
        }, 1000);
      }

    } catch (error) {
      console.error('‚ùå Error enviando siguiente pregunta:', error);
    }
  }

  /**
   * ‚úÖ FUNCI√ìN DE SANITIZACI√ìN PARA TELEGRAM
   */
  private sanitizeForTelegram(text: string): string {
    if (!text) return '';
    
    // Limpiar caracteres especiales problem√°ticos para la API de Telegram
    return text
      .replace(/[\u200B-\u200D\uFEFF]/g, '') // Eliminar caracteres de espacio en blanco invisibles
      .replace(/[^\x00-\x7F]/g, (char) => {   // Manejar caracteres Unicode problem√°ticos
        // Mantener caracteres UTF-8 comunes pero problem√°ticos
        const safeUnicode = '√°√©√≠√≥√∫√±√Å√â√ç√ì√ö√ë¬ø¬°√º√ú‚Ç¨';
        return safeUnicode.includes(char) ? char : '';
      })
      .replace(/[`*_\[\]()~>#+=|{}.!-]/g, '') // Eliminar caracteres que pueden interferir con Markdown
      .replace(/\s+/g, ' ')                   // Normalizar espacios m√∫ltiples
      .trim();
  }

  /**
   * Send Telegram poll for tournament question
   */
  private async sendTelegramPoll(
    telegramUserId: string,
    questionText: string,
    options: string[],
    correctAnswerIndex: number,
    currentQuestion: number,
    totalQuestions: number,
    tournamentName: string
  ): Promise<{ success: boolean; pollId?: string; reason?: string; questionLength?: number }> {
    try {
      const TELEGRAM_BOT_TOKEN = process.env.TELEGRAM_BOT_TOKEN;
      
      if (!TELEGRAM_BOT_TOKEN) {
        console.error('‚ùå TELEGRAM_BOT_TOKEN no configurado');
        return { success: false };
      }

      // Crear header del torneo
      const questionHeader = `üèÜ TORNEO: ${tournamentName}\n‚ùì Pregunta ${currentQuestion}/${totalQuestions}\n\n`;
      const fullQuestion = questionHeader + questionText;
      
      // ‚úÖ L√çMITE REAL DE TELEGRAM PARA POLLS (1024 caracteres)
      const TELEGRAM_POLL_MAX_LENGTH = 1024;
      
      // ‚úÖ SANITIZACI√ìN PARA TELEGRAM
      const sanitizedQuestion = this.sanitizeForTelegram(fullQuestion);
      
      if (sanitizedQuestion.length > TELEGRAM_POLL_MAX_LENGTH) {
        console.warn(`‚ö†Ô∏è Pregunta muy larga para poll de Telegram: ${sanitizedQuestion.length} caracteres`);
        return { success: false, reason: 'Pregunta demasiado larga para Telegram' };
      }

      // Continuar con el env√≠o del poll...
      return { success: true, pollId: 'temp-id' };
    } catch (error) {
      console.error('‚ùå Error enviando poll de Telegram:', error);
      return { success: false, reason: 'Error interno' };
    }
  }

  /**
   * Enviar mensaje de finalizaci√≥n de torneo al participante
   */
  private async sendTournamentCompletionMessage(participant: any, tournament: any, prisma: any): Promise<void> {
    try {
      console.log(`üèÜ Enviando mensaje de finalizaci√≥n de torneo a participante ${participant.id}`);
      // Implementaci√≥n b√°sica - se puede expandir seg√∫n necesidades
      // Aqu√≠ se enviar√≠a un mensaje de Telegram al usuario
    } catch (error) {
      console.error('Error enviando mensaje de finalizaci√≥n:', error);
    }
  }

  /**
   * Verificar si el torneo debe finalizar
   */
  private async checkTournamentCompletion(tournamentId: string, prisma: any): Promise<void> {
    try {
      console.log(`üîç Verificando si el torneo ${tournamentId} debe finalizar`);
      // Implementaci√≥n b√°sica - se puede expandir seg√∫n necesidades
      // Aqu√≠ se verificar√≠a si todos los participantes han terminado
    } catch (error) {
      console.error('Error verificando finalizaci√≥n del torneo:', error);
    }
  }

  /**
   * Buscar una pregunta alternativa v√°lida para el torneo
   */
  private async findAlternativeValidQuestion(
    tournamentId: string, 
    currentQuestionId: string,
    questionNumber: number,
    prisma: any
  ): Promise<any | null> {
    try {
      console.log(`üîç Buscando pregunta alternativa para torneo ${tournamentId}, pregunta ${questionNumber}`);
      
      // Implementaci√≥n b√°sica - buscar otra pregunta del mismo torneo
      const alternativeQuestion = await prisma.tournamentquestion.findFirst({
        where: {
          tournamentid: tournamentId,
          questionnumber: questionNumber,
          id: {
            not: currentQuestionId
          }
        }
      });

      if (alternativeQuestion) {
        console.log(`‚úÖ Pregunta alternativa encontrada: ${alternativeQuestion.id}`);
        return alternativeQuestion;
      } else {
        console.log(`‚ùå No se encontr√≥ pregunta alternativa para la pregunta ${questionNumber}`);
        return null;
      }
    } catch (error) {
      console.error('Error buscando pregunta alternativa:', error);
      return null;
    }
  }
}