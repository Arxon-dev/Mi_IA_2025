import { PrismaClient } from '@prisma/client';
import { prisma } from '@/lib/prisma';
import { telegramuser, subscriptionplan, usersubscription, paymenttransaction, userquotausage } from '@prisma/client';

export type SubscriptionFeature = 
  | 'questions' 
  | 'failed_questions' 
  | 'advanced_stats' 
  | 'simulations' 
  | 'ai_analysis'
  | 'custom_exams'
  | 'moodle_integration';

export interface FeatureAccessResult {
  allowed: boolean;
  reason?: string;
  upgradeUrl?: string;
  currentPlan?: string;
  requiredPlan?: string;
  remainingQuota?: number;
}

export interface QuotaInfo {
  questions: number | null; // null = ilimitado
  simulations: number | null;
  reports: number | null;
  aiAnalysis: number | null;
}

// Tipo personalizado para plan simulado
interface SimulatedPlan {
  name: string;
  displayname: string;
  canusefailedquestions: boolean;
  canuseadvancedstats: boolean;
  canusesimulations: boolean;
  canuseaianalysis: boolean;
  canusecustomexams: boolean;
  canusemoodleintegration: boolean;
  dailyquestionslimit: number | null;
  maxsimulationsperday: number | null;
  maxreportspermonth?: number | null;
}

export class SubscriptionService {
  
  /**
   * Verificar si un usuario puede acceder a una funcionalidad espec√≠fica
   */
  static async canUserAccessFeature(
    userId: string, 
    feature: SubscriptionFeature,
    requestedAmount: number = 1
  ): Promise<FeatureAccessResult> {
    try {
      // Buscar usuario y suscripci√≥n usando SQL directo (como /mi_plan que funciona)
      const userResults = await prisma.$queryRaw`
        SELECT 
          tu.*,
          s.*,
          p."name" as "planName",
          p."displayName" as "planDisplayName",
          p."canUseFailedQuestions",
          p."canUseAdvancedStats",
          p."canUseSimulations",
          p."canUseAIAnalysis",
          p."canUseCustomExams",
          p."canUseMoodleIntegration",
          p."dailyQuestionsLimit",
          p."maxSimulationsPerDay"
        FROM "TelegramUser" tu
        LEFT JOIN "UserSubscription" s ON tu."id" = s."userId" AND s."status" = 'active'
        LEFT JOIN "SubscriptionPlan" p ON s."planId" = p."id"
        WHERE tu."telegramUserId" = ${userId}
        LIMIT 1
      ` as any[];

      const userResult = userResults[0];
      
      if (!userResult) {
        return {
          allowed: false,
          reason: 'Usuario no encontrado',
        };
      }

      // Si no tiene suscripci√≥n activa, est√° en plan gratuito (muy limitado)
      if (!userResult.planName) {
        return await this.checkFreeUserAccess(feature, requestedAmount);
      }

      // Crear objetos simulados para compatibilidad
      const plan: SimulatedPlan = {
        name: userResult.planName,
        displayname: userResult.planDisplayName,
        canusefailedquestions: userResult.canUseFailedQuestions,
        canuseadvancedstats: userResult.canUseAdvancedStats,
        canusesimulations: userResult.canUseSimulations,
        canuseaianalysis: userResult.canUseAIAnalysis,
        canusecustomexams: userResult.canUseCustomExams,
        canusemoodleintegration: userResult.canUseMoodleIntegration,
        dailyquestionslimit: userResult.dailyQuestionsLimit,
        maxsimulationsperday: userResult.maxSimulationsPerDay
      };

      // Verificar si el plan permite la funcionalidad
      const featureAllowed = this.isPlanFeatureEnabled(plan, feature);
      if (!featureAllowed) {
        return {
          allowed: false,
          reason: `Funcionalidad no disponible en plan ${plan.displayname}`,
          currentPlan: plan.displayname,
          requiredPlan: this.getRequiredPlanForFeature(feature),
          upgradeUrl: '/premium'
        };
      }

      // Si es Premium, todo est√° permitido sin l√≠mites
      if (plan.name === 'premium') {
        return { allowed: true };
      }

      // Para plan B√°sico, verificar cuotas diarias
      if (plan.name === 'basic') {
        return await this.checkBasicPlanQuota(userId, feature, requestedAmount, plan);
      }

      return { allowed: true };

    } catch (error) {
      console.error('Error verificando acceso a funcionalidad:', error);
      return {
        allowed: false,
        reason: 'Error interno verificando permisos'
      };
    }
  }

  /**
   * Verificar acceso para usuarios gratuitos (sin suscripci√≥n)
   */
  private static async checkFreeUserAccess(
    feature: SubscriptionFeature, 
    requestedAmount: number
  ): Promise<FeatureAccessResult> {
    // Los usuarios gratuitos solo pueden ver preguntas del canal p√∫blico
    if (feature === 'questions') {
      return {
        allowed: false,
        reason: 'Las preguntas privadas requieren suscripci√≥n',
        requiredPlan: 'B√°sico',
        upgradeUrl: '/basico'
      };
    }

    return {
      allowed: false,
      reason: `La funcionalidad requiere suscripci√≥n`,
      requiredPlan: this.getRequiredPlanForFeature(feature),
      upgradeUrl: feature === 'moodle_integration' ? '/premium' : '/basico'
    };
  }

  /**
   * Verificar cuotas para plan B√°sico
   */
  private static async checkBasicPlanQuota(
    userId: string,
    feature: SubscriptionFeature,
    requestedAmount: number,
    plan: SimulatedPlan
  ): Promise<FeatureAccessResult> {
    const today = new Date();
    today.setHours(0, 0, 0, 0);

    // Obtener uso actual del d√≠a
    const todayUsage = await prisma.userquotausage.findFirst({
      where: {
        userid: userId,
        date: today
      }
    });

          const currentUsage = todayUsage || {
        questionsused: 0,
        failedquestionsused: 0,
        simulationsused: 0,
        reportsgenerated: 0,
        aianalysisused: 0
      };

    // Verificar l√≠mites seg√∫n funcionalidad
    switch (feature) {
      case 'questions':
      case 'failed_questions':
        const totalQuestionsUsed = currentUsage.questionsused + currentUsage.failedquestionsused;
        const limit = plan.dailyquestionslimit || 100;
        if (totalQuestionsUsed + requestedAmount > limit) {
          // üîî Enviar notificaci√≥n de l√≠mite alcanzado (import din√°mico para evitar dependencias circulares)
          this.sendQuotaLimitNotificationAsync(userId, 'questions', totalQuestionsUsed, limit);
          
                      return {
              allowed: false,
              reason: `L√≠mite diario alcanzado (${limit} preguntas/d√≠a)`,
              currentPlan: plan.displayname,
              requiredPlan: 'Premium',
              remainingQuota: Math.max(0, limit - totalQuestionsUsed),
              upgradeUrl: '/premium'
            };
        }
        break;

      case 'simulations':
        const simulationsLimit = plan.maxsimulationsperday || 1;
        if (currentUsage.simulationsused + requestedAmount > simulationsLimit) {
          return {
            allowed: false,
            reason: `L√≠mite diario de simulacros alcanzado (${simulationsLimit}/d√≠a)`,
            currentPlan: plan.displayname,
            requiredPlan: 'Premium',
            remainingQuota: Math.max(0, simulationsLimit - currentUsage.simulationsused),
            upgradeUrl: '/premium'
          };
        }
        break;

      case 'advanced_stats':
      case 'ai_analysis':
      case 'custom_exams':
      case 'moodle_integration':
        return {
          allowed: false,
          reason: `Funcionalidad solo disponible en Premium`,
          currentPlan: plan.displayname,
          requiredPlan: 'Premium',
          upgradeUrl: '/premium'
        };
    }

    return { allowed: true };
  }

  /**
   * Verificar si un plan tiene habilitada una funcionalidad
   */
  private static isPlanFeatureEnabled(plan: SimulatedPlan, feature: SubscriptionFeature): boolean {
    switch (feature) {
      case 'questions':
      case 'failed_questions':
        return plan.canusefailedquestions;
      case 'advanced_stats':
        return plan.canuseadvancedstats;
      case 'simulations':
        return plan.canusesimulations;
      case 'ai_analysis':
        return plan.canuseaianalysis;
      case 'custom_exams':
        return plan.canusecustomexams;
      case 'moodle_integration':
        return plan.canusemoodleintegration;
      default:
        return false;
    }
  }

  /**
   * Obtener el plan m√≠nimo requerido para una funcionalidad
   */
  private static getRequiredPlanForFeature(feature: SubscriptionFeature): string {
    switch (feature) {
      case 'questions':
      case 'failed_questions':
        return 'B√°sico';
      case 'advanced_stats':
      case 'simulations':
      case 'ai_analysis':
      case 'custom_exams':
      case 'moodle_integration':
        return 'Premium';
      default:
        return 'B√°sico';
    }
  }

  /**
   * Incrementar el uso de cuota para una funcionalidad
   */
  static async incrementQuotaUsage(
    telegramUserId: string, 
    type: 'questions' | 'failed_questions' | 'simulations' | 'reports' | 'ai_analysis',
    amount: number = 1
  ): Promise<void> {
    try {
      const user = await prisma.telegramuser.findUnique({
        where: { telegramuserid: telegramUserId }
      });

      if (!user) {
        // Usuario no encontrado, no hacer tracking
        return;
      }

      // Buscar suscripci√≥n activa del usuario
      const subscription = await prisma.usersubscription.findUnique({
        where: { userid: user.id }
      });

      if (!subscription) {
        // Usuario sin suscripci√≥n, no hacer tracking
        return;
      }

      const today = new Date();
      today.setHours(0, 0, 0, 0);

      // Buscar registro existente
      const existingUsage = await prisma.userquotausage.findFirst({
        where: {
          userid: user.id,
          date: today
        }
      });

      if (existingUsage) {
        // Actualizar registro existente
        await prisma.userquotausage.update({
          where: {
            id: existingUsage.id
          },
          data: {
            [this.getUsageField(type)]: {
              increment: amount
            },
            updatedat: new Date()
          }
        });
      } else {
        // Crear nuevo registro
        await prisma.userquotausage.create({
          data: {
            id: require('crypto').randomUUID(),
            userid: user.id,
            subscriptionid: subscription.id,
            date: today,
            [this.getUsageField(type)]: amount,
            createdat: new Date(),
            updatedat: new Date()
          }
        });
      }

    } catch (error) {
      console.error('Error incrementando cuota de uso:', error);
      // No lanzar error para no bloquear la funcionalidad
    }
  }

  /**
   * Mapear tipo de uso a campo de BD
   */
  private static getUsageField(type: string): string {
    const mapping: Record<string, string> = {
      'questions': 'questionsused',
      'failed_questions': 'failedquestionsused',
      'simulations': 'simulationsused',
      'reports': 'reportsgenerated',
      'ai_analysis': 'aianalysisused'
    };
    return mapping[type] || 'questionsused';
  }

  /**
   * Obtener suscripci√≥n actual del usuario
   */
  static async getCurrentSubscription(userId: string): Promise<usersubscription | null> {
    try {
      return await prisma.usersubscription.findUnique({
        where: { userid: userId }
      });
    } catch (error) {
      console.error('Error obteniendo suscripci√≥n actual:', error);
      return null;
    }
  }

  /**
   * Obtener estad√≠sticas de uso del usuario
   */
  static async getUsageStats(userId: string, date?: Date): Promise<userquotausage | null> {
    try {
      const targetDate = date || new Date();
      targetDate.setHours(0, 0, 0, 0);

      return await prisma.userquotausage.findFirst({
        where: {
          userid: userId,
          date: targetDate
        }
      });
    } catch (error) {
      console.error('Error obteniendo estad√≠sticas de uso:', error);
      return null;
    }
  }

  /**
   * Obtener cuota restante del usuario
   */
  static async getRemainingQuota(userId: string): Promise<QuotaInfo> {
    try {
      const subscription = await this.getCurrentSubscription(userId);
      
      if (!subscription || subscription.status !== 'active') {
        return {
          questions: 0,
          simulations: 0,
          reports: 0,
          aiAnalysis: 0
        };
      }

      // Obtener el plan por separado
      const plan = await prisma.subscriptionplan.findUnique({
        where: { id: subscription.planid }
      });

      if (!plan) {
        return {
          questions: 0,
          simulations: 0,
          reports: 0,
          aiAnalysis: 0
        };
      }

      // Si es Premium, todo ilimitado
      if (plan.name === 'premium') {
        return {
          questions: null,
          simulations: null,
          reports: null,
          aiAnalysis: null
        };
      }

      // Para plan B√°sico, calcular restante
      const usage = await this.getUsageStats(userId);
      const usedQuestions = (usage?.questionsused || 0) + (usage?.failedquestionsused || 0);
      const usedSimulations = usage?.simulationsused || 0;
      const usedReports = usage?.reportsgenerated || 0;
      const usedAI = usage?.aianalysisused || 0;

      return {
        questions: Math.max(0, (plan.dailyquestionslimit || 100) - usedQuestions),
        simulations: Math.max(0, (plan.maxsimulationsperday || 1) - usedSimulations),
        reports: Math.max(0, (plan.maxreportspermonth || 4) - usedReports),
        aiAnalysis: plan.canuseaianalysis ? null : 0
      };

    } catch (error) {
      console.error('Error calculando cuota restante:', error);
      return {
        questions: 0,
        simulations: 0,
        reports: 0,
        aiAnalysis: 0
      };
    }
  }

  /**
   * Actualizar suscripci√≥n del usuario
   */
  static async upgradeSubscription(userId: string, newPlanId: string): Promise<boolean> {
    try {
      const user = await prisma.telegramuser.findUnique({
        where: { id: userId }
      });

      if (!user) {
        return false;
      }

      const newPlan = await prisma.subscriptionplan.findUnique({
        where: { id: newPlanId }
      });

      if (!newPlan) {
        return false;
      }

      const now = new Date();
      const endDate = new Date(now);
      endDate.setMonth(endDate.getMonth() + 1); // 1 mes desde ahora

      // Buscar suscripci√≥n existente
      const existingSubscription = await prisma.usersubscription.findUnique({
        where: { userid: userId }
      });

      if (existingSubscription) {
        // Actualizar suscripci√≥n existente
        await prisma.usersubscription.update({
          where: { id: existingSubscription.id },
          data: {
            planid: newPlanId,
            status: 'active',
            startdate: now,
            enddate: endDate,
            updatedat: now
          }
        });
      } else {
        // Crear nueva suscripci√≥n
        await prisma.usersubscription.create({
          data: {
            id: require('crypto').randomUUID(),
            userid: userId,
            planid: newPlanId,
            status: 'active',
            startdate: now,
            enddate: endDate,
            updatedat: now
          }
        });
      }

      return true;

    } catch (error) {
      console.error('Error actualizando suscripci√≥n:', error);
      return false;
    }
  }

  /**
   * Cancelar suscripci√≥n del usuario
   */
  static async cancelSubscription(userId: string, reason?: string): Promise<boolean> {
    try {
      const subscription = await prisma.usersubscription.findUnique({
        where: { userid: userId }
      });

      if (!subscription) {
        return false;
      }

      await prisma.usersubscription.update({
        where: { id: subscription.id },
        data: {
          status: 'cancelled',
          autorenew: false,
          cancelreason: reason,
          updatedat: new Date()
        }
      });

      return true;

    } catch (error) {
      console.error('Error cancelando suscripci√≥n:', error);
      return false;
    }
  }

  /**
   * Renovar suscripci√≥n
   */
  static async renewSubscription(subscriptionId: string): Promise<boolean> {
    try {
      const subscription = await prisma.usersubscription.findUnique({
        where: { id: subscriptionId }
      });

      if (!subscription) {
        return false;
      }

      const now = new Date();
      const newEndDate = new Date(subscription.enddate || now);
      newEndDate.setMonth(newEndDate.getMonth() + 1);

      await prisma.usersubscription.update({
        where: { id: subscriptionId },
        data: {
          status: 'active',
          enddate: newEndDate,
          lastpaymentdate: now,
          nextpaymentdate: newEndDate,
          updatedat: now
        }
      });

      return true;

    } catch (error) {
      console.error('Error renovando suscripci√≥n:', error);
      return false;
    }
  }

  /**
   * Obtener todos los planes disponibles
   */
  static async getAvailablePlans(): Promise<subscriptionplan[]> {
    try {
      return await prisma.subscriptionplan.findMany({
        where: { isactive: true },
        orderBy: { price: 'asc' }
      });
    } catch (error) {
      console.error('Error obteniendo planes:', error);
      return [];
    }
  }

  /**
   * Crear planes iniciales si no existen
   */
  static async createInitialPlans(): Promise<void> {
    try {
      const existingPlans = await prisma.subscriptionplan.count();
      
      if (existingPlans > 0) {
        console.log('Planes ya existen, omitiendo creaci√≥n inicial');
        return;
      }

      console.log('Creando planes iniciales...');

      // Plan B√°sico
      await prisma.subscriptionplan.create({
        data: {
          id: require('crypto').randomUUID(),
          name: 'basic',
          displayname: 'B√°sico',
          description: '100 preguntas/d√≠a, sistema de preguntas falladas, estad√≠sticas b√°sicas',
          price: 4.99,
          currency: 'EUR',
          billingperiod: 'monthly',
          dailyquestionslimit: 100,
          monthlyquestionslimit: 3000,
          canusefailedquestions: true,
          canuseadvancedstats: false,
          canusesimulations: false,
          canuseaianalysis: false,
          canusecustomexams: false,
          canusemoodleintegration: false,
          maxsimulationsperday: 1,
          maxreportspermonth: 4,
          isactive: true,
          updatedat: new Date()
        }
      });

      // Plan Premium
      await prisma.subscriptionplan.create({
        data: {
          id: require('crypto').randomUUID(),
          name: 'premium',
          displayname: 'Premium',
          description: 'Preguntas ilimitadas, integraci√≥n Moodle, estad√≠sticas avanzadas, simulacros personalizados, an√°lisis IA',
          price: 9.99,
          currency: 'EUR',
          billingperiod: 'monthly',
          dailyquestionslimit: null, // Ilimitado
          monthlyquestionslimit: null, // Ilimitado
          canusefailedquestions: true,
          canuseadvancedstats: true,
          canusesimulations: true,
          canuseaianalysis: true,
          canusecustomexams: true,
          canusemoodleintegration: true,
          maxsimulationsperday: null, // Ilimitado
          maxreportspermonth: null, // Ilimitado
          isactive: true,
          updatedat: new Date()
        }
      });

      console.log('‚úÖ Planes iniciales creados exitosamente');

    } catch (error) {
      console.error('Error creando planes iniciales:', error);
    }
  }

  /**
   * üîî Enviar notificaci√≥n de l√≠mite de quota de forma as√≠ncrona (FASE 2)
   */
  private static sendQuotaLimitNotificationAsync(
    userId: string, 
    limitType: 'questions' | 'simulations', 
    currentUsage: number, 
    limit: number
  ): void {
    // Import din√°mico para evitar dependencias circulares
    import('@/services/subscriptionNotificationService').then(({ SubscriptionNotificationService }) => {
      SubscriptionNotificationService.sendQuotaLimitNotification(userId, limitType, currentUsage, limit)
        .catch(error => console.error('‚ùå Error enviando notificaci√≥n de l√≠mite:', error));
    }).catch(error => console.error('‚ùå Error importando servicio de notificaciones:', error));
  }
} 