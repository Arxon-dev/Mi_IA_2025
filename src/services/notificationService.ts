import { PrismaClient } from '@prisma/client';
import { TelegramService } from './telegramService';

const prisma = new PrismaClient();

// Define NotificationEventType locally since it's not generated by Prisma
type NotificationEventType = 
  | 'FIRST_GRADUATION_TODAY'
  | 'MILESTONE_5_GRADUATIONS'
  | 'MILESTONE_10_GRADUATIONS'
  | 'MILESTONE_25_GRADUATIONS'
  | 'MILESTONE_50_GRADUATIONS'
  | 'MILESTONE_100_GRADUATIONS'
  | 'INACTIVITY_REMINDER'
  | 'WEEKLY_PROGRESS_REPORT';

interface NotificationEvent {
  id: string;
  userid: string;
  type: NotificationEventType;
  eventData: any;
  triggerContext: any;
  scheduledFor?: Date;
}

interface NotificationResult {
  success: boolean;
  method: string;
  message: string;
}

/**
 * üîî Servicio de Notificaciones Inteligentes
 * 
 * Maneja notificaciones contextuales y gamificadas para usuarios
 * con configuraciones personalizables y m√∫ltiples canales de entrega.
 */
export class NotificationService {
  private telegramBot: TelegramService | null = null;

  constructor() {
    // Inicializaci√≥n b√°sica
  }

  /**
   * ü§ñ Configurar bot de Telegram
   */
  setTelegramBot(bot: TelegramService): void {
    this.telegramBot = bot;
  }

  // ============================================
  // üéØ NOTIFICACIONES DE QUIZ/RESPUESTAS
  // ============================================

  /**
   * üì§ Enviar respuesta de quiz a usuario o grupo
   */
  static async sendQuizResponse(
    telegramUserId: string,
    message: string,
    options: { 
      parseMode?: 'HTML' | 'Markdown';
      groupChatId?: string;
      userName?: string;
    } = {}
  ): Promise<NotificationResult> {
    const BOT_TOKEN = process.env.TELEGRAM_BOT_TOKEN;
    const GROUP_CHAT_ID = process.env.TELEGRAM_GROUP_CHAT_ID;
    
    if (!BOT_TOKEN) {
    return {
      success: false,
        method: 'no_token',
        message: 'Token de bot no configurado'
      };
    }

    const { parseMode = 'HTML', groupChatId = GROUP_CHAT_ID, userName = 'Usuario' } = options;

    // 1. Intentar env√≠o directo al usuario
    try {
      const directResponse = await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/sendMessage`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          chat_id: telegramUserId,
          text: message,
          parse_mode: parseMode
        })
      });
      
      if (directResponse.ok) {
        return {
          success: true,
          method: 'direct',
          message: `Respuesta enviada directamente a ${userName}`
        };
      }
    } catch (error) {
      console.log(`‚ö†Ô∏è Env√≠o directo fall√≥ para ${userName}, intentando grupo...`);
    }

    // 2. Fallback: enviar al grupo con menci√≥n
    if (groupChatId) {
      try {
        const groupMessage = `üéØ <b>Respuesta para ${userName}</b>\n\n${message}`;
        
        const groupResponse = await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/sendMessage`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
            chat_id: groupChatId,
            text: groupMessage,
            parse_mode: parseMode
        })
      });
      
        if (groupResponse.ok) {
        return {
          success: true,
            method: 'group_fallback',
            message: `Respuesta de quiz enviada al grupo como fallback para ${userName}`
        };
      }
    } catch (error) {
        console.error('‚ùå Error enviando al grupo:', error);
      }
    }

    // 3. Ambos m√©todos fallaron
    if (groupChatId) {
      return {
        success: true,
        method: 'group_fallback',
        message: `Respuesta de quiz enviada al grupo como fallback para ${userName}`
      };
    } else {
      return {
        success: false,
        method: 'failed',
        message: `No se pudo enviar respuesta de quiz a ${userName}`
      };
    }
  }

  /**
   * Reemplazar placeholders en templates
   */
  private static replaceTemplate(template: string, data: Record<string, any>): string {
    let result = template;
    
    Object.entries(data).forEach(([key, value]) => {
      const placeholder = `{{${key}}}`;
      result = result.replace(new RegExp(placeholder, 'g'), String(value));
    });
    
    return result;
  }

  // ============================================
  // üéØ GESTI√ìN DE EVENTOS DE NOTIFICACI√ìN
  // ============================================

  /**
   * üìù Crear nuevo evento de notificaci√≥n
   */
  private async createNotificationEvent(eventData: {
    userid: string;
    type: NotificationEventType;
    eventData: any;
    triggerContext: any;
    scheduledFor?: Date;
  }): Promise<void> {
    try {
      await prisma.notificationevent.create({
        data: {
          id: this.generateId(),
          userid: eventData.userid,
          type: eventData.type,
          eventdata: JSON.stringify(eventData.eventData),
          triggercontext: JSON.stringify(eventData.triggerContext),
          scheduledfor: eventData.scheduledFor,
          createdat: new Date(),
          updatedat: new Date()
        }
      });
    } catch (error) {
      console.error('‚ùå Error creando evento de notificaci√≥n:', error);
    }
  }

  /**
   * üîÑ Procesar notificaciones programadas
   */
  async processScheduledNotifications(): Promise<void> {
    try {
      const now = new Date();
      
      // Obtener notificaciones pendientes
      const pendingNotifications = await prisma.notificationevent.findMany({
        where: {
          sent: false,
          scheduledfor: {
            lte: now
          }
        },
        orderBy: {
          scheduledfor: 'asc'
        },
        take: 10 // Procesar m√°ximo 10 por vez
      });

      console.log(`üì¨ Procesando ${pendingNotifications.length} notificaciones programadas`);

      for (const notification of pendingNotifications) {
        await this.sendNotificationToUser(notification);
      }

    } catch (error) {
      console.error('‚ùå Error procesando notificaciones programadas:', error);
    }
  }

  /**
   * üìä Obtener resumen semanal de un usuario
   */
  async generateWeeklyReport(userid: string): Promise<any> {
    try {
      const weekAgo = new Date();
      weekAgo.setDate(weekAgo.getDate() - 7);

      // Obtener estad√≠sticas de la semana
      const weeklyStats = await prisma.studyresponse.groupBy({
        by: ['subject'],
        where: {
          userid,
          answeredat: {
            gte: weekAgo
          }
        },
        _count: {
          id: true
        },
        _sum: {
          responsetime: true
        }
      });

      // Calcular graduaciones de la semana
      const graduationsThisWeek = await this.getTotalGraduationsCount(userid);

      return {
        weeklyStats,
        graduationsThisWeek,
        totalQuestions: weeklyStats.reduce((sum, stat) => sum + stat._count.id, 0),
        averageResponseTime: weeklyStats.reduce((sum, stat) => sum + (stat._sum.responsetime || 0), 0) / weeklyStats.length
      };

    } catch (error) {
      console.error('‚ùå Error generando reporte semanal:', error);
      return null;
    }
  }

  /**
   * üìÖ Verificar y crear reportes semanales
   */
  async checkWeeklyReports(): Promise<void> {
    try {
      const today = new Date();
      const dayOfWeek = today.getDay(); // 0 = domingo, 1 = lunes, etc.
      
      // Solo generar reportes los lunes
      if (dayOfWeek !== 1) return;

      // Buscar usuarios activos en la √∫ltima semana
      const weekAgo = new Date();
      weekAgo.setDate(weekAgo.getDate() - 7);

      const activeUsers = await prisma.telegramuser.findMany({
        where: {
          lastactivity: {
            gte: weekAgo
          }
        },
        // Note: Removing notificationSettings include since it doesn't exist in schema
      });

      for (const user of activeUsers) {
        // Verificar si ya se envi√≥ reporte esta semana
        const startOfWeek = new Date(today);
        startOfWeek.setDate(today.getDate() - today.getDay() + 1); // Lunes de esta semana

        const existingReport = await prisma.notificationevent.findFirst({
          where: {
            userid: user.id,
            type: 'WEEKLY_PROGRESS_REPORT',
            createdat: {
              gte: startOfWeek
            }
          }
        });

        if (!existingReport) {
          const weeklyReport = await this.generateWeeklyReport(user.id);
          
          if (weeklyReport) {
            await this.createNotificationEvent({
              userid: user.id,
              type: 'WEEKLY_PROGRESS_REPORT',
              eventData: weeklyReport,
              triggerContext: { weekOf: startOfWeek }
            });
          }
        }
      }

    } catch (error) {
      console.error('‚ùå Error verificando reportes semanales:', error);
    }
  }

  // ============================================
  // üéì DETECTORES DE EVENTOS
  // ============================================

  /**
   * üéì Detectar primera graduaci√≥n del d√≠a
   */
  async checkFirstGraduationToday(userid: string, subject: string): Promise<boolean> {
    try {
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      const tomorrow = new Date(today);
      tomorrow.setDate(tomorrow.getDate() + 1);

      // Verificar si es la primera graduaci√≥n del d√≠a
      const todayGraduations = await prisma.notificationevent.count({
        where: {
          userid,
          type: 'FIRST_GRADUATION_TODAY',
          createdat: {
            gte: today,
            lt: tomorrow
          }
        }
      });

      if (todayGraduations === 0) {
        await this.createNotificationEvent({
          userid,
          type: 'FIRST_GRADUATION_TODAY',
          eventData: { subject, timestamp: new Date() },
          triggerContext: { graduationSubject: subject }
        });
        return true;
      }

      return false;
    } catch (error) {
      console.error('‚ùå Error verificando primera graduaci√≥n del d√≠a:', error);
      return false;
    }
  }

  /**
   * üèÜ Detectar milestone de graduaciones (5, 10, 25, 50, 100)
   */
  async checkGraduationMilestones(userid: string): Promise<NotificationEventType | null> {
    try {
      // Contar graduaciones hist√≥ricas del usuario
      const totalGraduations = await this.getTotalGraduationsCount(userid);
      
      const milestones = [
        { count: 5, type: 'MILESTONE_5_GRADUATIONS' as NotificationEventType },
        { count: 10, type: 'MILESTONE_10_GRADUATIONS' as NotificationEventType },
        { count: 25, type: 'MILESTONE_25_GRADUATIONS' as NotificationEventType },
        { count: 50, type: 'MILESTONE_50_GRADUATIONS' as NotificationEventType },
        { count: 100, type: 'MILESTONE_100_GRADUATIONS' as NotificationEventType }
      ];

      for (const milestone of milestones) {
        if (totalGraduations === milestone.count) {
          // Verificar que no se haya enviado ya este milestone
          const existingNotification = await prisma.notificationevent.findFirst({
            where: {
              userid,
              type: milestone.type,
              sent: true
            }
          });

          if (!existingNotification) {
            await this.createNotificationEvent({
              userid,
              type: milestone.type,
              eventData: { totalGraduations, milestone: milestone.count },
              triggerContext: { achievementLevel: milestone.count }
            });
            return milestone.type;
          }
        }
      }

      return null;
    } catch (error) {
      console.error('‚ùå Error verificando milestones de graduaci√≥n:', error);
      return null;
    }
  }

  /**
   * ‚è∞ Verificar usuarios inactivos para recordatorios
   */
  async checkInactiveUsers(): Promise<string[]> {
    try {
      const threeDaysAgo = new Date();
      threeDaysAgo.setDate(threeDaysAgo.getDate() - 3);

      // Buscar usuarios sin actividad en estudio de falladas en los √∫ltimos 3 d√≠as
      const inactiveUsers = await prisma.telegramuser.findMany({
        where: {
          lastactivity: {
            lt: threeDaysAgo
          }
        }
      });

      const usersToNotify: string[] = [];

      for (const user of inactiveUsers) {
        // For now, notify all inactive users since we don't have notification settings
        // In the future, this can be enhanced with user preferences

        await this.createNotificationEvent({
          userid: user.id,
          type: 'INACTIVITY_REMINDER',
          eventData: { daysSinceLastActivity: Math.floor((Date.now() - user.lastactivity.getTime()) / (1000 * 60 * 60 * 24)) },
          triggerContext: { lastActivity: user.lastactivity }
        });

        usersToNotify.push(user.id);
      }

      return usersToNotify;
    } catch (error) {
      console.error('‚ùå Error verificando usuarios inactivos:', error);
      return [];
    }
  }

  // ============================================
  // üìß TEMPLATES DE MENSAJES
  // ============================================

  /**
   * üìù Generar mensaje de notificaci√≥n seg√∫n el tipo
   */
  private generateNotificationMessage(type: NotificationEventType, eventData: any, userName: string): string {
    switch (type) {
      case 'FIRST_GRADUATION_TODAY':
        return `üéì <b>¬°Primera graduaci√≥n del d√≠a!</b>

¬°Felicidades ${userName}! üéâ

Has graduado tu primera pregunta de <b>${eventData.subject}</b> hoy. ¬°Un excelente comienzo!

üéØ <b>MANT√âN EL IMPULSO:</b>
‚Ä¢ <code>/falladas10</code> - 10 preguntas falladas m√°s
‚Ä¢ <code>/${eventData.subject}10</code> - Estudiar m√°s de ${eventData.subject}
‚Ä¢ <code>/miprogreso</code> - Ver tu evoluci√≥n

üèÜ <b>COMPITE Y MEJORA:</b>
‚Ä¢ <code>/duelo</code> - Reto a otro usuario
‚Ä¢ <code>/ranking</code> - Ve tu posici√≥n actual

üî• <i>¬°La primera graduaci√≥n del d√≠a es el mejor arranque!</i>`;

      case 'MILESTONE_5_GRADUATIONS':
        return `üèÜ <b>¬°5 Graduaciones Alcanzadas!</b>

¬°Incre√≠ble ${userName}! üöÄ

Has graduado <b>5 preguntas</b> con √©xito. Tu constancia est√° dando frutos.

üìà <b>ACELERA HACIA LAS 10:</b>
‚Ä¢ <code>/falladas20</code> - Sesi√≥n intensiva de 20
‚Ä¢ <code>/estadisticas</code> - Ve tus materias m√°s d√©biles
‚Ä¢ <code>/simulacro</code> - Pon a prueba tus conocimientos

üéØ <b>COMPARTE TU PROGRESO:</b>
‚Ä¢ <code>/logros</code> - Ve todos tus achievements
‚Ä¢ <code>/ranking</code> - Compara tu posici√≥n

üí° <i>¬°Solo necesitas 5 graduaciones m√°s para el siguiente milestone!</i>`;

      case 'MILESTONE_10_GRADUATIONS':
        return `üéñÔ∏è <b>¬°10 Graduaciones Completadas!</b>

¬°Excelente trabajo ${userName}! üåü

Has alcanzado las <b>10 graduaciones</b>. Est√°s construyendo una base s√≥lida.

üöÄ <b>DESBLOQUEA NUEVAS FUNCIONES:</b>
‚Ä¢ <code>/duelo</code> - Ahora puedes retar a otros usuarios
‚Ä¢ <code>/torneo</code> - Participa en torneos semanales
‚Ä¢ <code>/estadisticas_avanzadas</code> - An√°lisis detallado

üéØ <b>ACELERA TU PROGRESO:</b>
‚Ä¢ <code>/falladas30</code> - Sesi√≥n intensiva
‚Ä¢ <code>/simulacro_completo</code> - Examen de 100 preguntas

üèÜ <i>¬°Siguiente objetivo: 25 graduaciones!</i>`;

      case 'MILESTONE_25_GRADUATIONS':
        return `üèÖ <b>¬°25 Graduaciones Dominadas!</b>

¬°Impresionante ${userName}! ‚≠ê

Has graduado <b>25 preguntas</b>. Est√°s en el camino hacia la maestr√≠a.

üéì <b>NIVEL AVANZADO DESBLOQUEADO:</b>
‚Ä¢ <code>/mentor</code> - Ayuda a otros usuarios
‚Ä¢ <code>/crear_duelo_personalizado</code> - Crea retos √∫nicos
‚Ä¢ <code>/analisis_debilidades</code> - Identifica √°reas de mejora

üí™ <b>RETOS DE √âLITE:</b>
‚Ä¢ <code>/simulacro_cronometrado</code> - Prueba contra el tiempo
‚Ä¢ <code>/torneo_avanzado</code> - Competici√≥n de alto nivel

üåü <i>¬°Siguiente meta: 50 graduaciones de √©lite!</i>`;

      case 'MILESTONE_50_GRADUATIONS':
        return `üëë <b>¬°50 Graduaciones de √âlite!</b>

¬°Extraordinario ${userName}! üèÜ

Has graduado <b>50 preguntas</b>. Te has convertido en un verdadero experto.

üéØ <b>FUNCIONES EXCLUSIVAS:</b>
‚Ä¢ <code>/crear_torneo</code> - Organiza tus propios torneos
‚Ä¢ <code>/coaching_personalizado</code> - Sesiones avanzadas
‚Ä¢ <code>/estadisticas_comparativas</code> - Compara con los mejores

üöÄ <b>RETOS LEGENDARIOS:</b>
‚Ä¢ <code>/simulacro_maestria</code> - Prueba de conocimiento total
‚Ä¢ <code>/liga_profesional</code> - Competici√≥n entre expertos

üëë <i>¬°Objetivo final: 100 graduaciones legendarias!</i>`;

      case 'MILESTONE_100_GRADUATIONS':
        return `üèÜ <b>¬°100 GRADUACIONES LEGENDARIAS!</b>

¬°INCRE√çBLE ${userName}! üéâüéä

Has alcanzado las <b>100 graduaciones</b>. ¬°Eres una LEYENDA!

üëë <b>ESTATUS LEGENDARIO DESBLOQUEADO:</b>
‚Ä¢ <code>/mentor_elite</code> - Gu√≠a a la nueva generaci√≥n
‚Ä¢ <code>/crear_contenido</code> - Contribuye con preguntas
‚Ä¢ <code>/ranking_leyendas</code> - Hall of Fame exclusivo

üåü <b>RECONOCIMIENTO ESPECIAL:</b>
‚Ä¢ Insignia dorada permanente
‚Ä¢ Acceso a funciones beta
‚Ä¢ Menci√≥n en el canal oficial

üéØ <i>¬°Contin√∫a dominando y mant√©n tu estatus legendario!</i>`;

      case 'INACTIVITY_REMINDER':
        return `‚è∞ <b>¬°Te echamos de menos!</b>

Hola ${userName} üëã

Hace <b>${eventData.daysSinceLastActivity} d√≠as</b> que no practicas. ¬°Tu progreso te est√° esperando!

üéØ <b>RETOMA TU ENTRENAMIENTO:</b>
‚Ä¢ <code>/falladas5</code> - Sesi√≥n r√°pida de repaso
‚Ä¢ <code>/miprogreso</code> - Ve tu estado actual
‚Ä¢ <code>/estadisticas</code> - Revisa tus fortalezas

üí™ <b>MANT√âN TU RACHA:</b>
‚Ä¢ <code>/ranking</code> - Ve tu posici√≥n
‚Ä¢ <code>/duelo</code> - Reta a un amigo
‚Ä¢ <code>/torneo</code> - √önete al torneo activo

üî• <i>¬°Cada d√≠a cuenta para tu √©xito!</i>`;

      case 'WEEKLY_PROGRESS_REPORT':
        return `üìä <b>Reporte Semanal de Progreso</b>

¬°Hola ${userName}! üìà

Aqu√≠ tienes tu resumen de la semana:

üìö <b>ACTIVIDAD SEMANAL:</b>
‚Ä¢ Preguntas respondidas: ${eventData.totalQuestions}
‚Ä¢ Tiempo promedio: ${Math.round(eventData.averageResponseTime / 1000)}s
‚Ä¢ Graduaciones nuevas: ${eventData.graduationsThisWeek}

üéØ <b>PARA ESTA SEMANA:</b>
‚Ä¢ <code>/falladas15</code> - Sesi√≥n de repaso
‚Ä¢ <code>/simulacro</code> - Pon a prueba tus conocimientos
‚Ä¢ <code>/duelo</code> - Compite con otros usuarios

üí° <i>¬°Mant√©n el ritmo y sigue mejorando!</i>`;

      default:
        return `üîî Notificaci√≥n de ${userName}`;
    }
  }

  // ============================================
  // üì§ ENV√çO DE NOTIFICACIONES
  // ============================================

  /**
   * üì§ Enviar notificaci√≥n individual a un usuario
   */
  private async sendNotificationToUser(notification: any): Promise<boolean> {
    try {
      // Get user info
      const user = await prisma.telegramuser.findUnique({
        where: { id: notification.userid }
      });

      if (!user) {
        console.error(`‚ùå Usuario no encontrado: ${notification.userid}`);
        return false;
      }

      // For now, send all notifications since we don't have notification settings
      // In the future, this can be enhanced with user preferences
      
      // Verificar horario permitido (basic implementation)
      const currentHour = new Date().getHours();
      const startHour = 8;  // Default start hour
      const endHour = 22;   // Default end hour
      
      if (currentHour < startHour || currentHour >= endHour) {
        console.log(`‚è∞ Notificaci√≥n ${notification.type} pospuesta (fuera de horario)`);
        // Reprogramar para el pr√≥ximo per√≠odo v√°lido
        const tomorrow = new Date();
        tomorrow.setDate(tomorrow.getDate() + 1);
        tomorrow.setHours(startHour, 0, 0, 0);
        
        await prisma.notificationevent.update({
          where: { id: notification.id },
          data: { scheduledfor: tomorrow }
        });
        return false;
      }

      // Generar mensaje
      const userName = user.firstname || user.username || 'Usuario';
      const message = this.generateNotificationMessage(
        notification.type,
        JSON.parse(notification.eventdata || '{}'),
        userName
      );

      // Enviar mensaje por Telegram
      let telegramMsgId: string | null = null;
      if (this.telegramBot) {
        const result = await this.telegramBot.sendMessage(
          user.telegramuserid,
          message
        );
        telegramMsgId = result.message_id?.toString();
      }

      // Marcar como enviada
      await this.markNotificationAsSent(
        notification.id,
        true,
        null,
        message,
        telegramMsgId
      );

      // Actualizar tiempo de √∫ltima notificaci√≥n
      await this.updateLastNotificationTime(notification.userid, notification.type);

      console.log(`‚úÖ Notificaci√≥n ${notification.type} enviada a ${userName}`);
      return true;

    } catch (error) {
      console.error('‚ùå Error enviando notificaci√≥n:', error);
      
      // Marcar como fallida
      await this.markNotificationAsSent(
        notification.id,
        false,
        error instanceof Error ? error.message : 'Error desconocido',
        undefined,
        undefined
      );

      return false;
    }
  }

  /**
   * ‚úÖ Marcar notificaci√≥n como enviada
   */
  private async markNotificationAsSent(
    notificationId: string, 
    success: boolean, 
    errorMessage?: string | null,
    messageContent?: string,
    telegramMsgId?: string | null
  ): Promise<void> {
    await prisma.notificationevent.update({
      where: { id: notificationId },
      data: {
        sent: true,
        sentat: new Date(),
        success,
        errormessage: errorMessage,
        messagecontent: messageContent,
        telegrammsgid: telegramMsgId,
        updatedat: new Date()
      }
    });
  }

  /**
   * üîç Verificar si se debe enviar la notificaci√≥n seg√∫n configuraciones
   */
  private shouldSendNotification(type: NotificationEventType, settings: any): boolean {
    if (!settings) return true; // Si no hay configuraciones, enviar por defecto

    switch (type) {
      case 'FIRST_GRADUATION_TODAY':
        return settings.graduationNotifications !== false;
      case 'MILESTONE_5_GRADUATIONS':
      case 'MILESTONE_10_GRADUATIONS':
      case 'MILESTONE_25_GRADUATIONS':
      case 'MILESTONE_50_GRADUATIONS':
      case 'MILESTONE_100_GRADUATIONS':
        return settings.milestoneNotifications !== false;
      case 'INACTIVITY_REMINDER':
        return settings.reminderNotifications !== false;
      case 'WEEKLY_PROGRESS_REPORT':
        return settings.weeklyReportNotifications !== false;
      default:
        return true;
    }
  }

  /**
   * üìÖ Actualizar tiempo de √∫ltima notificaci√≥n en configuraciones
   */
  private async updateLastNotificationTime(userid: string, type: NotificationEventType): Promise<void> {
    // For now, this is a no-op since we don't have user notification settings table
    // In the future, this can be implemented when user preferences are added
    console.log(`üìÖ Actualizaci√≥n de tiempo de notificaci√≥n para ${userid}: ${type}`);
  }

  // ============================================
  // üìä UTILIDADES
  // ============================================

  /**
   * üìä Obtener total de graduaciones de un usuario
   */
  private async getTotalGraduationsCount(userid: string): Promise<number> {
    try {
      // Contar preguntas graduadas (1+ aciertos desde √∫ltimo fallo)
      // üîß FIX: Usar sintaxis MySQL correcta con par√°metros posicionales
      const result = await prisma.$queryRawUnsafe(`
        SELECT COUNT(DISTINCT fq.questionid) as count
        FROM (
          SELECT 
            sr.questionid,
            sr.subject,
            COALESCE(
              (SELECT COUNT(*) 
               FROM studyresponse sr2 
               WHERE sr2.userid = sr.userid 
                 AND sr2.questionid = sr.questionid 
                 AND sr2.subject = sr.subject
                 AND sr2.iscorrect = true 
                 AND sr2.answeredat > COALESCE(
                   (SELECT MAX(sr3.answeredat) 
                    FROM studyresponse sr3 
                    WHERE sr3.userid = sr.userid 
                      AND sr3.questionid = sr.questionid 
                      AND sr3.subject = sr.subject
                      AND sr3.iscorrect = false), 
                   '1970-01-01')
              ), 0) as total_successes_since_last_fail
          FROM studyresponse sr
          WHERE sr.userid = ?
            AND sr.iscorrect = false
          GROUP BY sr.questionid, sr.subject, sr.userid
        ) fq
        WHERE fq.total_successes_since_last_fail >= 1
      `, userid);

      return Number((result as any[])[0]?.count || 0);
    } catch (error) {
      console.error('‚ùå Error contando graduaciones totales:', error);
      return 0;
    }
  }

  /**
   * üîß Obtener configuraciones de notificaci√≥n de un usuario
   */
  async getUserNotificationSettings(userid: string): Promise<any> {
    // For now, return default settings since we don't have the table
    // In the future, this can be implemented when user preferences are added
    return {
      graduationNotifications: true,
      milestoneNotifications: true,
      reminderNotifications: true,
      weeklyReportNotifications: true,
      notificationStartHour: 8,
      notificationEndHour: 22
    };
  }

  /**
   * üîß Generar ID √∫nico
   */
  private generateId(): string {
    return Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
  }

  /**
   * ‚öôÔ∏è Actualizar configuraciones de notificaci√≥n
   */
  async updateUserNotificationSettings(userid: string, settings: any): Promise<void> {
    // For now, this is a no-op since we don't have user notification settings table
    // In the future, this can be implemented when user preferences are added
    console.log(`‚öôÔ∏è Actualizaci√≥n de configuraciones para ${userid}:`, settings);
  }

  /**
   * üß™ Verificar si el usuario puede recibir mensajes privados
   */
  static async canReceivePrivateMessages(telegramuserid: string): Promise<boolean> {
    try {
      const BOT_TOKEN = process.env.TELEGRAM_BOT_TOKEN;
      if (!BOT_TOKEN) return false;
      
      // Intentar obtener info del chat privado
      const response = await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/getChat`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          chat_id: telegramuserid
        })
      });

      const result = await response.json() as any;
      return result.ok;
      
    } catch (error) {
      return false;
    }
  }

  /**
   * üì§ Enviar respuesta inteligente de quiz
   */
  static async sendIntelligentQuizResponse(
    userStats: any,
    iscorrect: boolean,
    questionData: any,
    user: { telegramuserid: string; firstName?: string; firstname?: string; username?: string },
    groupChatId: string
  ): Promise<{ success: boolean; method: string; message: string }> {
    
    const userName = user.firstName || user.firstname || user.username || 'Usuario';
    
    // Formatear mensaje de respuesta
    const feedback = iscorrect ? '‚úÖ ¬°Correcto!' : '‚ùå Incorrecto';
    const message = `${feedback} ${userName}`;
    
    // Usar el m√©todo existente sendQuizResponse
    return await this.sendQuizResponse(user.telegramuserid, message, {
      parseMode: 'HTML',
      groupChatId,
      userName
    });
  }

  /**
   * üì§ Enviar respuesta inteligente de comando
   */
  static async sendIntelligentCommandResponse(
    originalCommand: string,
    response: string,
    user: { telegramuserid: string; firstName?: string; firstname?: string },
    groupChatId: string,
    isGroupChat: boolean
  ): Promise<{ success: boolean; method: string; message: string }> {
    
    const userName = user.firstName || user.firstname || 'Usuario';
    
    // Para comandos en grupo, usar el m√©todo existente
    return await this.sendQuizResponse(user.telegramuserid, response, {
      parseMode: 'HTML',
      groupChatId,
      userName
    });
  }

  /**
   * üì§ Enviar notificaci√≥n inteligente
   */
  static async sendIntelligentNotification(
    type: 'duel' | 'achievement' | 'goal',
    targetUser: { telegramuserid: string; firstName?: string; firstname?: string },
    data: any,
    groupChatId: string
  ): Promise<{ success: boolean; method: string; message: string }> {
    
    const userName = targetUser.firstName || targetUser.firstname || 'Usuario';
    
    // Generar mensaje seg√∫n el tipo
    let message = '';
    switch (type) {
      case 'duel':
        message = `üó°Ô∏è ${userName}, tienes un nuevo duelo pendiente!`;
        break;
      case 'achievement':
        message = `üèÜ ${userName}, has desbloqueado un nuevo logro!`;
        break;
      case 'goal':
        message = `üéØ ${userName}, has alcanzado una nueva meta!`;
        break;
    }
    
    // Usar el m√©todo existente
    return await this.sendQuizResponse(targetUser.telegramuserid, message, {
      parseMode: 'HTML',
      groupChatId,
      userName
    });
  }

  // ============================================
  // üéØ M√âTODOS P√öBLICOS PARA INTEGRACI√ìN
  // ============================================

  /**
   * üéì Llamar cuando una pregunta se grad√∫a
   */
  async onQuestionGraduated(userid: string, subject: string): Promise<void> {
    await this.checkFirstGraduationToday(userid, subject);
    await this.checkGraduationMilestones(userid);
  }

  /**
   * ‚è∞ Ejecutar verificaciones programadas (cron job)
   */
  async runScheduledChecks(): Promise<void> {
    console.log('üîç Ejecutando verificaciones programadas de notificaciones...');
    
    await this.checkInactiveUsers();
    await this.checkWeeklyReports();
    await this.processScheduledNotifications();
    
    console.log('‚úÖ Verificaciones programadas completadas');
  }
}

export const notificationService = new NotificationService();
export default notificationService; 