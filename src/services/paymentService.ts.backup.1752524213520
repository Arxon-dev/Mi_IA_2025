import { PrismaClient } from '@prisma/client';
import { SubscriptionService } from './subscriptionService';

const prisma = new PrismaClient();

export interface InvoiceData {
  title: string;
  description: string;
  payload: string;
  providerToken: string;
  currency: string;
  prices: Array<{ label: string; amount: number; }>;
  maxTipAmount?: number;
  suggestedTipAmounts?: number[];
  startParameter?: string;
  providerData?: string;
  photoUrl?: string;
  photoSize?: number;
  photoWidth?: number;
  photoHeight?: number;
  needName?: boolean;
  needPhoneNumber?: boolean;
  needEmail?: boolean;
  needShippingAddress?: boolean;
  sendPhoneNumberToProvider?: boolean;
  sendEmailToProvider?: boolean;
  isFlexible?: boolean;
}

export interface PaymentResult {
  success: boolean;
  transactionId?: string;
  error?: string;
  invoiceUrl?: string;
}

export interface PreCheckoutQuery {
  id: string;
  from: any;
  currency: string;
  totalAmount: number;
  invoicePayload: string;
  shippingOptionId?: string;
  orderInfo?: any;
}

export interface SuccessfulPayment {
  currency: string;
  totalAmount: number;
  invoicePayload: string;
  shippingOptionId?: string;
  orderInfo?: any;
  telegramPaymentChargeId: string;
  providerPaymentChargeId: string;
}

export class PaymentService {
  
  // Configuraci√≥n espec√≠fica para Espa√±a
  private static readonly SPAIN_CONFIG = {
    currency: 'EUR',
    vatRate: 0.21, // IVA 21%
    supportedMethods: ['visa', 'mastercard', 'maestro'],
    needName: true,
    needEmail: true,
    needPhoneNumber: false, // Opcional para Bizum
    sendEmailToProvider: true
  };

  /**
   * Crear factura de Telegram Payments para usuario espa√±ol
   */
  static async createTelegramInvoice(
    userId: string, 
    planId: string, 
    discountCode?: string
  ): Promise<PaymentResult> {
    try {
      // Obtener plan
      const plan = await prisma.subscriptionPlan.findUnique({
        where: { id: planId }
      });

      if (!plan) {
        return { success: false, error: 'Plan no encontrado' };
      }

      // Obtener usuario
      const user = await prisma.telegramUser.findUnique({
        where: { id: userId }
      });

      if (!user) {
        return { success: false, error: 'Usuario no encontrado' };
      }

      // Calcular precios (ya incluyen IVA en Espa√±a)
      const priceInCents = Math.round(plan.price * 100); // Convertir a centavos
      const basePrice = Math.round((plan.price / (1 + this.SPAIN_CONFIG.vatRate)) * 100);
      const vatAmount = priceInCents - basePrice;

      // Aplicar descuento si existe
      let finalPrice = priceInCents;
      if (discountCode) {
        finalPrice = await this.applyDiscount(priceInCents, discountCode);
      }

      // Crear payload √∫nico para tracking
      const payload = `subscription_${planId}_${userId}_${Date.now()}`;

      // Crear registro de transacci√≥n pendiente
      const transaction = await prisma.paymentTransaction.create({
        data: {
          userId,
          amount: finalPrice / 100, // Volver a euros
          baseAmount: basePrice / 100,
          vatAmount: vatAmount / 100,
          currency: this.SPAIN_CONFIG.currency,
          status: 'pending',
          paymentMethod: 'telegram',
          transactionType: 'subscription',
          description: `Suscripci√≥n ${plan.displayName} - OpoMelilla Premium`,
          customerName: `${user.firstName || ''} ${user.lastName || ''}`.trim(),
          customerEmail: user.email
        }
      });

      // Configurar invoice data espec√≠fica para Espa√±a
      const invoiceData: InvoiceData = {
        title: `${plan.displayName} - OpoMelilla Premium`,
        description: `Suscripci√≥n mensual a ${plan.displayName}. Incluye IVA (21%). ${plan.description}`,
        payload,
        providerToken: process.env.STRIPE_SECRET_KEY!,
        currency: this.SPAIN_CONFIG.currency,
        prices: [
          {
            label: `${plan.displayName} (1 mes)`,
            amount: finalPrice
          }
        ],
        needName: this.SPAIN_CONFIG.needName,
        needEmail: this.SPAIN_CONFIG.needEmail,
        needPhoneNumber: this.SPAIN_CONFIG.needPhoneNumber,
        sendEmailToProvider: this.SPAIN_CONFIG.sendEmailToProvider,
        isFlexible: false,
        photoUrl: 'https://your-domain.com/images/logo-premium.png', // Opcional
        startParameter: `plan_${planId}`
      };

      return {
        success: true,
        transactionId: transaction.id,
        invoiceUrl: JSON.stringify(invoiceData) // En Telegram se env√≠a directamente
      };

    } catch (error) {
      console.error('Error creando invoice de Telegram:', error);
      return {
        success: false,
        error: 'Error creando invoice'
      };
    }
  }

  /**
   * Manejar pre-checkout query (validaci√≥n antes del pago)
   */
  static async handlePreCheckoutQuery(preCheckout: PreCheckoutQuery): Promise<boolean> {
    try {
      console.log('üîç Pre-checkout query recibido:', preCheckout);

      // Extraer informaci√≥n del payload
      const payloadParts = preCheckout.invoicePayload.split('_');
      if (payloadParts.length < 4 || payloadParts[0] !== 'subscription') {
        console.error('Payload inv√°lido:', preCheckout.invoicePayload);
        return false;
      }

      const planId = payloadParts[1];
      const userId = payloadParts[2];

      // Verificar que el plan existe y est√° activo
      const plan = await prisma.subscriptionPlan.findUnique({
        where: { id: planId, isActive: true }
      });

      if (!plan) {
        console.error('Plan no encontrado o inactivo:', planId);
        return false;
      }

      // Verificar que el usuario existe
      const user = await prisma.telegramUser.findUnique({
        where: { id: userId }
      });

      if (!user) {
        console.error('Usuario no encontrado:', userId);
        return false;
      }

      // Verificar que la cantidad coincide (en centavos)
      const expectedAmount = Math.round(plan.price * 100);
      if (preCheckout.totalAmount !== expectedAmount) {
        console.error('Cantidad no coincide:', {
          esperado: expectedAmount,
          recibido: preCheckout.totalAmount
        });
        return false;
      }

      console.log('‚úÖ Pre-checkout query validado correctamente');
      return true;

    } catch (error) {
      console.error('Error en pre-checkout query:', error);
      return false;
    }
  }

  /**
   * Procesar pago exitoso de Telegram
   */
  static async processSuccessfulPayment(
    userId: string,
    payment: SuccessfulPayment
  ): Promise<boolean> {
    try {
      console.log('üí∞ Procesando pago exitoso:', payment);

      // Extraer informaci√≥n del payload
      const payloadParts = payment.invoicePayload.split('_');
      if (payloadParts.length < 4 || payloadParts[0] !== 'subscription') {
        console.error('Payload inv√°lido en pago exitoso:', payment.invoicePayload);
        return false;
      }

      const planId = payloadParts[1];
      const userIdFromPayload = payloadParts[2];

      // Verificar que el userId coincide
      if (userId !== userIdFromPayload) {
        console.error('Usuario no coincide:', { userId, userIdFromPayload });
        return false;
      }

      // Usar transacci√≥n de BD para consistencia
      const result = await prisma.$transaction(async (tx) => {
        // Buscar transacci√≥n pendiente
        const transaction = await tx.paymentTransaction.findFirst({
          where: {
            userId,
            status: 'pending',
            paymentMethod: 'telegram'
          },
          orderBy: { createdAt: 'desc' }
        });

        if (!transaction) {
          throw new Error('Transacci√≥n pendiente no encontrada');
        }

        // Actualizar transacci√≥n como completada
        await tx.paymentTransaction.update({
          where: { id: transaction.id },
          data: {
            status: 'completed',
            telegramPaymentId: payment.telegramPaymentChargeId,
            externalTransactionId: payment.providerPaymentChargeId,
            completedAt: new Date(),
            updatedAt: new Date()
          }
        });

        // Activar o actualizar suscripci√≥n
        const activationSuccess = await SubscriptionService.upgradeSubscription(userId, planId);
        if (!activationSuccess) {
          throw new Error('Error activando suscripci√≥n');
        }

        return transaction;
      });

      // Generar factura espa√±ola (opcional, para registros)
      await this.generateSpanishInvoice(result.id);

      console.log('‚úÖ Pago procesado exitosamente, suscripci√≥n activada');
      return true;

    } catch (error) {
      console.error('Error procesando pago exitoso:', error);
      
      // Marcar transacci√≥n como fallida si existe
      try {
        await prisma.paymentTransaction.updateMany({
          where: {
            userId,
            status: 'pending',
            paymentMethod: 'telegram'
          },
          data: {
            status: 'failed',
            failureReason: error.message,
            updatedAt: new Date()
          }
        });
      } catch (updateError) {
        console.error('Error actualizando transacci√≥n fallida:', updateError);
      }

      return false;
    }
  }

  /**
   * Manejar pago fallido
   */
  static async processFailedPayment(
    userId: string,
    reason: string,
    telegramPaymentId?: string
  ): Promise<void> {
    try {
      console.log('‚ùå Procesando pago fallido:', { userId, reason });

      await prisma.paymentTransaction.updateMany({
        where: {
          userId,
          status: 'pending',
          paymentMethod: 'telegram'
        },
        data: {
          status: 'failed',
          failureReason: reason,
          telegramPaymentId,
          updatedAt: new Date()
        }
      });

    } catch (error) {
      console.error('Error procesando pago fallido:', error);
    }
  }

  /**
   * Aplicar c√≥digo de descuento
   */
  private static async applyDiscount(originalPrice: number, discountCode: string): Promise<number> {
    // Implementar l√≥gica de descuentos aqu√≠
    // Por ahora, solo algunos c√≥digos de ejemplo
    const discounts = {
      'BIENVENIDA10': 0.10, // 10% descuento
      'ESTUDIANTE15': 0.15, // 15% descuento
      'VERANO20': 0.20      // 20% descuento
    };

    const discount = discounts[discountCode.toUpperCase()];
    if (discount) {
      return Math.round(originalPrice * (1 - discount));
    }

    return originalPrice;
  }

  /**
   * Generar factura espa√±ola (PDF)
   */
  private static async generateSpanishInvoice(transactionId: string): Promise<void> {
    try {
      // Implementar generaci√≥n de factura PDF aqu√≠
      // Por ahora solo registrar que se debe generar
      console.log('üìÑ Generando factura espa√±ola para transacci√≥n:', transactionId);
      
      // Actualizar transacci√≥n con n√∫mero de factura
      const invoiceNumber = `FAC-${new Date().getFullYear()}-${String(Date.now()).slice(-6)}`;
      
      await prisma.paymentTransaction.update({
        where: { id: transactionId },
        data: {
          invoiceNumber,
          invoicePath: `/facturas/${invoiceNumber}.pdf` // Ruta donde se guardar√°
        }
      });

    } catch (error) {
      console.error('Error generando factura espa√±ola:', error);
    }
  }

  /**
   * Obtener historial de transacciones del usuario
   */
  static async getUserTransactions(userId: string): Promise<PaymentTransaction[]> {
    try {
      return await prisma.paymentTransaction.findMany({
        where: { userId },
        orderBy: { createdAt: 'desc' },
        take: 20 // √öltimas 20 transacciones
      });
    } catch (error) {
      console.error('Error obteniendo transacciones del usuario:', error);
      return [];
    }
  }

  /**
   * Procesar reembolso
   */
  static async processRefund(
    transactionId: string,
    reason: string,
    amount?: number
  ): Promise<boolean> {
    try {
      const transaction = await prisma.paymentTransaction.findUnique({
        where: { id: transactionId },
        include: { user: true }
      });

      if (!transaction) {
        return false;
      }

      const refundAmount = amount || transaction.amount;

      // Actualizar transacci√≥n
      await prisma.paymentTransaction.update({
        where: { id: transactionId },
        data: {
          status: 'refunded',
          refundedAt: new Date(),
          failureReason: reason,
          updatedAt: new Date()
        }
      });

      // Cancelar suscripci√≥n si es necesario
      if (transaction.transactionType === 'subscription') {
        await SubscriptionService.cancelSubscription(
          transaction.userId, 
          `Reembolso: ${reason}`
        );
      }

      console.log('‚úÖ Reembolso procesado:', {
        transactionId,
        userId: transaction.userId,
        amount: refundAmount
      });

      return true;

    } catch (error) {
      console.error('Error procesando reembolso:', error);
      return false;
    }
  }

  /**
   * Verificar estado de pago
   */
  static async getPaymentStatus(transactionId: string): Promise<string | null> {
    try {
      const transaction = await prisma.paymentTransaction.findUnique({
        where: { id: transactionId },
        select: { status: true }
      });

      return transaction?.status || null;
    } catch (error) {
      console.error('Error verificando estado de pago:', error);
      return null;
    }
  }

  /**
   * Limpiar transacciones antiguas pendientes (tarea de mantenimiento)
   */
  static async cleanupOldPendingTransactions(): Promise<void> {
    try {
      const oneDayAgo = new Date();
      oneDayAgo.setDate(oneDayAgo.getDate() - 1);

      const result = await prisma.paymentTransaction.updateMany({
        where: {
          status: 'pending',
          createdAt: {
            lt: oneDayAgo
          }
        },
        data: {
          status: 'cancelled',
          failureReason: 'Timeout - transacci√≥n expirada',
          updatedAt: new Date()
        }
      });

      console.log(`üßπ Limpieza: ${result.count} transacciones pendientes caducadas`);
    } catch (error) {
      console.error('Error limpiando transacciones antiguas:', error);
    }
  }
} 