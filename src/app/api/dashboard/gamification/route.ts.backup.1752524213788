import { NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';

export async function GET() {
  try {
    console.log('üéÆ Gamification API: Fetching real data...');

    // Estad√≠sticas generales
    const totalUsers = await prisma.telegramUser.count();
    const totalResponses = await prisma.telegramResponse.count();
    
    // Calcular precisi√≥n promedio
    const correctResponses = await prisma.telegramResponse.count({
      where: { isCorrect: true }
    });
    const averageAccuracy = totalResponses > 0 ? Math.round((correctResponses / totalResponses) * 100) : 0;

    // Contar rachas activas (usuarios con racha > 0)
    const activeStreaks = await prisma.telegramUser.count({
      where: { streak: { gt: 0 } }
    });

    // Obtener la racha m√°xima
    const topStreakResult = await prisma.telegramUser.findFirst({
      orderBy: { bestStreak: 'desc' },
      select: { bestStreak: true }
    });
    const topStreak = topStreakResult?.bestStreak || 0;

    // Calcular puntos totales otorgados
    const totalPointsResult = await prisma.telegramUser.aggregate({
      _sum: { totalPoints: true }
    });
    const totalPointsAwarded = totalPointsResult._sum.totalPoints || 0;

    // Ranking general (top 10)
    const leaderboardRaw = await prisma.telegramUser.findMany({
      orderBy: { totalPoints: 'desc' },
      take: 10,
      select: {
        telegramUserId: true,
        firstName: true,
        lastName: true,
        username: true,
        totalPoints: true,
        level: true,
        streak: true
      }
    });

    const leaderboard = leaderboardRaw.map((user, index) => ({
      rank: index + 1,
      user: {
        telegramUserId: user.telegramUserId,
        username: user.username,
        firstName: user.firstName,
        lastName: user.lastName
      },
      points: user.totalPoints,
      level: user.level,
      streak: user.streak
    }));

    // Ranking semanal (√∫ltimos 7 d√≠as)
    const weekAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000);
    
    // Obtener respuestas de la √∫ltima semana
    const weeklyResponses = await prisma.telegramResponse.findMany({
      where: { answeredAt: { gte: weekAgo } },
      include: { user: true }
    });

    // Agrupar por usuario y calcular puntos semanales
    const weeklyPointsMap = new Map();
    weeklyResponses.forEach(response => {
      const userId = response.user.telegramUserId;
      const points = response.isCorrect ? 10 : 0; // Asumiendo 10 puntos por respuesta correcta
      
      if (!weeklyPointsMap.has(userId)) {
        weeklyPointsMap.set(userId, {
          user: response.user,
          points: 0
        });
      }
      
      weeklyPointsMap.get(userId).points += points;
    });

    // Convertir a array y ordenar por puntos
    const weeklyLeaderboard = Array.from(weeklyPointsMap.values())
      .sort((a, b) => b.points - a.points)
      .slice(0, 10)
      .map((entry, index) => ({
        rank: index + 1,
        user: {
          telegramUserId: entry.user.telegramUserId,
          username: entry.user.username,
          firstName: entry.user.firstName,
          lastName: entry.user.lastName
        },
        points: entry.points,
        level: entry.user.level,
        streak: entry.user.streak
      }));

    // Ranking mensual (mes actual)
    const firstDayOfMonth = new Date();
    firstDayOfMonth.setDate(1);
    firstDayOfMonth.setHours(0, 0, 0, 0);
    
    // Obtener respuestas del mes actual
    const monthlyResponses = await prisma.telegramResponse.findMany({
      where: { answeredAt: { gte: firstDayOfMonth } },
      include: { user: true }
    });

    // Agrupar por usuario y calcular puntos mensuales
    const monthlyPointsMap = new Map();
    monthlyResponses.forEach(response => {
      const userId = response.user.telegramUserId;
      const points = response.isCorrect ? 10 : 0;
      
      if (!monthlyPointsMap.has(userId)) {
        monthlyPointsMap.set(userId, {
          user: response.user,
          points: 0
        });
      }
      
      monthlyPointsMap.get(userId).points += points;
    });

    // Convertir a array y ordenar por puntos
    const monthlyLeaderboard = Array.from(monthlyPointsMap.values())
      .sort((a, b) => b.points - a.points)
      .slice(0, 10)
      .map((entry, index) => ({
        rank: index + 1,
        user: {
          telegramUserId: entry.user.telegramUserId,
          username: entry.user.username,
          firstName: entry.user.firstName,
          lastName: entry.user.lastName
        },
        points: entry.points,
        level: entry.user.level,
        streak: entry.user.streak
      }));

    // Obtener logros reales de la base de datos (si tienes una tabla de achievements)
    // Por ahora, mantenemos algunos logros ejemplo basados en datos reales
    const achievements = [
      {
        id: '1',
        name: 'Primera Respuesta',
        description: 'Responde tu primera pregunta',
        icon: 'üéØ',
        category: 'volume',
        points: 50,
        rarity: 'common',
        unlockedCount: totalUsers // Todos los usuarios han respondido al menos una vez para estar registrados
      },
      {
        id: '2',
        name: 'Racha de 7 d√≠as',
        description: 'Responde preguntas durante 7 d√≠as consecutivos',
        icon: 'üî•',
        category: 'streak',
        points: 250,
        rarity: 'rare',
        unlockedCount: await prisma.telegramUser.count({
          where: { bestStreak: { gte: 7 } }
        })
      },
      {
        id: '3',
        name: 'Velocista',
        description: 'Responde 10 preguntas en menos de 10 segundos',
        icon: '‚ö°',
        category: 'speed',
        points: 200,
        rarity: 'rare',
        unlockedCount: Math.floor(totalUsers * 0.1) // Estimaci√≥n del 10%
      },
      {
        id: '4',
        name: 'Perfeccionista',
        description: 'Alcanza 100% de precisi√≥n en 10 respuestas',
        icon: 'üíØ',
        category: 'accuracy',
        points: 300,
        rarity: 'epic',
        unlockedCount: Math.floor(totalUsers * 0.05) // Estimaci√≥n del 5%
      }
    ];

    const stats = {
      totalUsers,
      totalResponses,
      averageAccuracy,
      activeStreaks,
      topStreak,
      totalPointsAwarded
    };

    const response = {
      leaderboard,
      weeklyLeaderboard,
      monthlyLeaderboard,
      achievements,
      stats,
      lastUpdate: new Date().toISOString()
    };

    console.log('‚úÖ Gamification API: Real data fetched successfully');
    console.log('üéÆ Gamification Stats:', {
      users: totalUsers,
      responses: totalResponses,
      accuracy: averageAccuracy,
      activeStreaks,
      topStreak,
      totalPoints: totalPointsAwarded
    });

    return NextResponse.json(response);

  } catch (error) {
    console.error('‚ùå Gamification API error:', error);
    
    return NextResponse.json({
      error: 'Error fetching gamification data',
      leaderboard: [],
      weeklyLeaderboard: [],
      achievements: [],
      stats: {
        totalUsers: 0,
        totalResponses: 0,
        averageAccuracy: 0,
        activeStreaks: 0,
        topStreak: 0,
        totalPointsAwarded: 0
      },
      lastUpdate: new Date().toISOString()
    }, { status: 500 });

  } finally {
    await prisma.$disconnect();
  }
} 