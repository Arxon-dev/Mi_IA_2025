import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/services/prismaService';
import type { QuestionTableName } from '@/types/questionTables';

// üéØ API Endpoint para guardar preguntas en diferentes tablas
export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { tableName, questions, sectionId, documentId } = body;

    // Validar datos de entrada
    if (!tableName || !questions || !Array.isArray(questions)) {
      return NextResponse.json(
        { error: 'tableName y questions son requeridos' },
        { status: 400 }
      );
    }

    if (questions.length === 0) {
      return NextResponse.json(
        { error: 'La lista de preguntas no puede estar vac√≠a' },
        { status: 400 }
      );
    }

    console.log(`[API /questions/custom-table] Guardando ${questions.length} preguntas en ${tableName}`);

    // Procesar preguntas seg√∫n la tabla destino
    let savedQuestions: any[] = [];

    if (tableName === 'SectionQuestion') {
      // Si es SectionQuestion, usar el m√©todo tradicional
      if (!sectionId) {
        return NextResponse.json(
          { error: 'sectionId es requerido para SectionQuestion' },
          { status: 400 }
        );
      }

      savedQuestions = await createSectionQuestions(sectionId, questions);
    } else {
      // Para las nuevas tablas tem√°ticas
      savedQuestions = await createCustomTableQuestions(tableName, questions, sectionId, documentId);
    }

    return NextResponse.json({
      success: true,
      tableName,
      questions: savedQuestions,
      count: savedQuestions.length
    });

  } catch (error) {
    console.error('[API /questions/custom-table] Error:', error);
    return NextResponse.json(
      { 
        error: 'Error interno del servidor',
        details: error instanceof Error ? error.message : 'Error desconocido'
      },
      { status: 500 }
    );
  }
}

// Funci√≥n para crear preguntas en SectionQuestion (m√©todo tradicional)
async function createSectionQuestions(sectionId: string, questions: any[]) {
  const questionsData = questions.map(q => ({
    sectionId,
    content: q.content || q.question || '',
    type: q.type || 'gift',
    difficulty: q.difficulty || 'medium',
    bloomLevel: q.bloomLevel || null,
    lastScheduledSendAt: q.lastScheduledSendAt || null,
    sendCount: q.sendCount || 0,
    lastSuccessfulSendAt: q.lastSuccessfulSendAt || null,
    isActive: q.isActive !== undefined ? q.isActive : true
  }));

  const result = await prisma.sectionQuestion.createMany({
    data: questionsData,
    skipDuplicates: true
  });

  // Retornar las preguntas creadas
  return await prisma.sectionQuestion.findMany({
    where: { sectionId },
    orderBy: { createdAt: 'desc' },
    take: questions.length
  });
}

// Funci√≥n para crear preguntas en tablas tem√°ticas
async function createCustomTableQuestions(
  tableName: QuestionTableName, 
  questions: any[], 
  sectionId?: string, 
  documentId?: string
) {
  // Obtener el siguiente n√∫mero de pregunta
  const nextQuestionNumber = await getNextQuestionNumber(tableName);
  
  // Mapear datos de pregunta al formato requerido por las nuevas tablas
  const questionsData = questions.map((q, index) => {
    // Extraer datos de la pregunta en formato GIFT
    const questionContent = q.content || q.question || '';
    const parsedQuestion = parseGiftQuestion(questionContent);
    
    return {
      title: q.customTitle || parsedQuestion?.title || null,
      feedback: parsedQuestion?.feedback || null,
      questionNumber: nextQuestionNumber + index,
      question: parsedQuestion?.pregunta || questionContent,
      options: parsedQuestion?.opciones || [],
      correctAnswerIndex: parsedQuestion?.respuestaCorrecta || 0,
      category: getTableCategory(tableName),
      difficulty: q.difficulty || 'OFICIAL',
      isActive: q.isActive !== undefined ? q.isActive : true,
      sendCount: q.sendCount || 0,
      lastSuccessfulSendAt: q.lastSuccessfulSendAt || null,
      lastUsedInTournament: q.lastUsedInTournament || null,
      tournamentUsageCount: q.tournamentUsageCount || 0,
      lastTournamentId: q.lastTournamentId || null,
      
      // üîó Campos de compatibilidad y trazabilidad
      type: q.type || 'gift',
      bloomLevel: q.bloomLevel || null,
      sectionId: sectionId || null,
      documentId: documentId || null,
      sourceSection: sectionId ? `Section-${sectionId}` : null
    };
  });

  // Usar el nombre de tabla din√°micamente con Prisma
  const modelName = getModelName(tableName);
  
  // Crear las preguntas usando acceso din√°mico
  const result = await (prisma as any)[modelName].createMany({
    data: questionsData,
    skipDuplicates: true
  });

  // Retornar las preguntas creadas
  return await (prisma as any)[modelName].findMany({
    orderBy: { createdAt: 'desc' },
    take: questions.length
  });
}

// Helper: Parsear pregunta en formato GIFT
function parseGiftQuestion(giftText: string) {
  try {
    // 1. Extraer t√≠tulo de la etiqueta <b>
    const titleMatch = giftText.match(/<b>(.*?)<\/b>/i);
    const title = titleMatch ? titleMatch[1].trim() : null;

    // 2. Extraer el contenido dentro de las llaves {}
    const blockMatch = giftText.match(/\{([\s\S]*?)\}/);
    const blockContent = blockMatch ? blockMatch[1] : '';

    // 3. Extraer opciones y respuesta correcta
    const optionsPart = blockContent.split('#### RETROALIMENTACI√ìN:')[0];
    const lines = optionsPart.trim().split('\n').filter(line => line.trim() !== '');
    const opciones = lines.map(line => line.substring(1).trim());
    const respuestaCorrecta = lines.findIndex(line => line.startsWith('='));

    // 4. Extraer feedback
    const feedbackMatch = blockContent.match(/#### RETROALIMENTACI√ìN:([\s\S]*)/);
    const feedback = feedbackMatch ? feedbackMatch[1].trim() : null;

    // 5. Extraer el cuerpo de la pregunta (todo antes de las llaves)
    let pregunta = '';
    const questionBodyEnd = giftText.indexOf('{');
    if (questionBodyEnd !== -1) {
      pregunta = giftText.substring(0, questionBodyEnd).trim();
    }

    // Quitar el t√≠tulo del cuerpo de la pregunta para no duplicarlo
    pregunta = pregunta.replace(/<b>.*?<\/b><br><br>/i, '').trim();

    return {
      title,
      pregunta, // Contiene el comentario y el texto de la pregunta
      opciones,
      respuestaCorrecta: respuestaCorrecta !== -1 ? respuestaCorrecta : null,
      feedback,
    };
  } catch (error) {
    console.error('Error al parsear la pregunta GIFT:', error);
    return null;
  }
}

// Helper: Obtener siguiente n√∫mero de pregunta para una tabla
async function getNextQuestionNumber(tableName: QuestionTableName): Promise<number> {
  const modelName = getModelName(tableName);
  
  try {
    const lastQuestion = await (prisma as any)[modelName].findFirst({
      orderBy: { questionNumber: 'desc' },
      select: { questionNumber: true }
    });
    
    return (lastQuestion?.questionNumber || 0) + 1;
  } catch (error) {
    console.error(`Error getting next question number for ${tableName}:`, error);
    return 1;
  }
}

// Helper: Obtener categor√≠a seg√∫n nombre de tabla
function getTableCategory(tableName: QuestionTableName): string {
  const categoryMap: Record<QuestionTableName, string> = {
    'SectionQuestion': 'section',
    'Constitucion': 'constitucion',
    'DefensaNacional': 'defensanacional',
    'Rio': 'rio',
    'Minsdef': 'minsdef',
    'OrganizacionFas': 'organizacionfas',
    'Emad': 'emad',
    'Et': 'et',
    'Armada': 'armada',
    'Aire': 'aire',
    'Carrera': 'carrera',
    'Tropa': 'tropa',
    'Rroo': 'rroo',
    'DerechosYDeberes': 'derechosydeberes',
    'RegimenDisciplinario': 'regimendisciplinario',
    'IniciativasQuejas': 'iniciativasquejas',
    'Igualdad': 'igualdad',
    'Omi': 'omi',
    'Pac': 'pac',
    'SeguridadNacional': 'seguridadnacional',
    'Pdc': 'pdc',
    'Onu': 'onu',
    'Otan': 'otan',
    'Osce': 'osce',
    'Ue': 'ue',
    'MisionesInternacionales': 'misionesinternacionales'
  };
  
  return categoryMap[tableName] || tableName.toLowerCase();
}

// Helper: Convertir nombre de tabla a nombre de modelo de Prisma
function getModelName(tableName: QuestionTableName): string {
  if (tableName === 'SectionQuestion') return 'sectionQuestion';
  
  // Para las nuevas tablas, usar el nombre tal como est√° (en PascalCase)
  return tableName.charAt(0).toLowerCase() + tableName.slice(1);
} 