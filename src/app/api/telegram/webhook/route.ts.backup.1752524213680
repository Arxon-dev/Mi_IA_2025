import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import { GamificationService } from '@/services/gamificationService';
import { ExamRankingService } from '@/services/examRankingService';
import { DuelService } from '@/services/duelService';
import { NotificationService } from '@/services/notificationService';
import { Examen2024Service } from '@/services/examen2024Service';
import { SimulacroService } from '@/services/simulacroService';
import { Simulacro2024Service } from '@/services/simulacro2024Service';
import { DuelManager } from '@/services/duelManager';
import { TournamentService } from '@/services/tournamentService';
import { StudySessionService } from '@/services/studySessionService';
import { PaymentService } from '@/services/paymentServiceRedsys';
import { SubscriptionCommands } from '@/services/subscriptionCommandsSimple';
import { SubscriptionService } from '@/services/subscriptionService';

const BOT_TOKEN = process.env.TELEGRAM_BOT_TOKEN || '8039179482:AAG6bugxwgsmWLVHGoWpE5nih_PQpD3KPBs';

// FunciÃ³n para generar IDs Ãºnicos
function generateId(): string {
  return Date.now().toString() + Math.random().toString(36).substr(2, 9);
}

// Usando instancia centralizada de prisma

// Instancia del servicio de sesiones de estudio
const studySessionService = new StudySessionService();

// ğŸ† SISTEMA DE TORNEOS INTEGRADO - Paso 3 completado
// Using TypeScript tournament service to avoid webpack issues

// Inicializar sistema de torneos automÃ¡ticamente
let tournamentSystemInitialized = false;

async function initializeTournamentSystem() {
  if (!tournamentSystemInitialized) {
    console.log('ğŸ† Inicializando sistema de torneos integrado...');
    await TournamentService.getInstance().ensureTournamentManagerRunning();
    tournamentSystemInitialized = true;
    console.log('âœ… Sistema de torneos integrado iniciado');
  }
}

// ğŸª– NOTA: Los sistemas militares se probarÃ¡n con script independiente
// Para integraciÃ³n completa, se requiere configuraciÃ³n adicional de TypeScript

interface TelegramUpdate {
  update_id: number;
  message?: {
    message_id: number;
    from: {
      id: number;
      is_bot: boolean;
      first_name: string;
      last_name?: string;
      username?: string;
    };
    chat: {
      id: number;
      type: string;
    };
    date: number;
    text?: string;
    reply_to_message?: {
      message_id: number;
      date?: number;
      text?: string;
    };
    // ğŸ†• NUEVO: Agregar detecciÃ³n de nuevos miembros
    new_chat_members?: Array<{
      id: number;
      is_bot: boolean;
      first_name: string;
      last_name?: string;
      username?: string;
    }>;
    // ğŸ’° NUEVO: Agregar soporte para pagos exitosos
    successful_payment?: {
      currency: string;
      total_amount: number;
      invoice_payload: string;
      shipping_option_id?: string;
      order_info?: any;
      telegram_payment_charge_id: string;
      provider_payment_charge_id: string;
    };
  };
  poll_answer?: {
    poll_id: string;
    user: {
      id: number;
      is_bot: boolean;
      first_name: string;
      last_name?: string;
      username?: string;
    };
    option_ids: number[];
  };
  // ğŸ’³ NUEVO: Agregar soporte para pre-checkout queries
  pre_checkout_query?: {
    id: string;
    from: {
      id: number;
      is_bot: boolean;
      first_name: string;
      last_name?: string;
      username?: string;
    };
    currency: string;
    total_amount: number;
    invoice_payload: string;
    shipping_option_id?: string;
    order_info?: any;
  };
}

// FunciÃ³n para extraer el ID de la pregunta del mensaje original
function extractQuestionId(text: string): string | null {
  // Buscar patrones como "ID: 123" o "#123" en el texto
  const patterns = [
    /ID:\s*([a-zA-Z0-9-]+)/i,
    /#([a-zA-Z0-9-]+)/,
    /Pregunta\s+([a-zA-Z0-9-]+)/i
  ];

  for (const pattern of patterns) {
    const match = text.match(pattern);
    if (match) {
      return match[1];
    }
  }

  return null;
}

function extractRankingType(text: string): 'general' | 'semanal' | 'mensual' {
  const lowerText = text.toLowerCase();
  
  if (lowerText.includes('semanal') || lowerText.includes('semana')) {
    return 'semanal';
  } else if (lowerText.includes('mensual') || lowerText.includes('mes')) {
    return 'mensual';
  } else {
    return 'general';
  }
}

// FunciÃ³n para verificar si la respuesta es correcta
function checkAnswer(userAnswer: string, correctAnswers: string[]): boolean {
  const normalizedUserAnswer = userAnswer.toLowerCase().trim();
  
  return correctAnswers.some(answer => 
    answer.toLowerCase().trim() === normalizedUserAnswer
  );
}

// FunciÃ³n para calcular el tiempo de respuesta
function calculateResponseTime(questionTime: number, responseTime: number): number {
  return Math.max(0, responseTime - questionTime);
}

// FunciÃ³n para enviar mensajes a Telegram
async function sendTelegramMessage(chatid: number | string, message: string): Promise<boolean> {
  try {
    console.log('Enviando mensaje a Telegram:', { chatid, messageLength: message.length });
    
    const response = await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/sendMessage`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        chat_id: chatid,
        text: message,
        parse_mode: 'HTML'  // Cambiado de Markdown a HTML
      }),
    });

    const result = await response.json();
    
    console.log('Respuesta de Telegram API:', result);
    
    if (!result.ok) {
      console.error('Error enviando mensaje a Telegram:', result.description);
      
      // Intentar enviar sin formato si falla
      const fallbackResponse = await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/sendMessage`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          chat_id: chatid,
          text: message.replace(/<[^>]*>/g, '') // Quitar HTML tags
        }),
      });
      
      const fallbackResult = await fallbackResponse.json();
      console.log('Respuesta fallback:', fallbackResult);
      
      return fallbackResult.ok;
    }

    console.log('âœ… Mensaje enviado exitosamente a Telegram');
    return true;
  } catch (error) {
    console.error('âŒ Error en sendTelegramMessage:', error);
    return false;
  }
}

// GET endpoint for testing
export async function GET() {
  return NextResponse.json({ 
    status: 'ok', 
    message: 'Telegram webhook endpoint is working!',
    timestamp: new Date().toISOString()
  });
}

// ============ FUNCIONES AUXILIARES PARA FEEDBACK INMEDIATO ============

/**
 * Calcula los puntos ganados por una respuesta
 * NOTA: Esta funciÃ³n es solo para feedback inmediato.
 * El cÃ¡lculo real se hace en gamificationService.ts con el sistema hÃ­brido completo.
 */
function calculatePointsEarned(iscorrect: boolean, responseTime?: number): number {
  // Esta funciÃ³n es solo para mostrar feedback inmediato aproximado
  // El cÃ¡lculo real con protecciones se hace en gamificationService.ts
  
  const basePoints = iscorrect ? 10 : -2; // AproximaciÃ³n para feedback inmediato
  
  let bonusPoints = 0;

  // Bonus por velocidad (respuesta rÃ¡pida < 30 segundos)
  if (responseTime && responseTime < 30) {
    bonusPoints += 5;
  }

  // Bonus extra por respuesta muy rÃ¡pida (< 10 segundos)
  if (responseTime && responseTime < 10) {
    bonusPoints += 5;
  }

  return basePoints + bonusPoints;
}

/**
 * Genera mensaje de feedback inmediato para el usuario
 */
function generateImmediateFeedback(
  userStats: any, 
  iscorrect: boolean, 
  pointsEarned: number, 
  responseTime?: number
): string {
  const timestamp = new Date().toLocaleTimeString('es-ES');
  const correctIcon = iscorrect ? 'âœ…' : 'âŒ';
  const resultText = iscorrect ? 'Â¡Correcto!' : 'Incorrecto';
  
  let message = `${correctIcon} <b>${resultText}</b>\n`;
  
  // Mostrar puntos ganados/perdidos
  if (pointsEarned >= 0) {
    message += `ğŸ¯ <b>+${pointsEarned} puntos</b> ganados\n`;
  } else {
    message += `ğŸ“‰ <b>${pointsEarned} puntos</b> (puntos reales calculados con protecciones)\n`;
  }
  
  if (responseTime) {
    message += `â±ï¸ Tiempo: ${responseTime}s`;
    if (responseTime < 10) {
      message += ' âš¡ Â¡SÃºper rÃ¡pido!';
    } else if (responseTime < 30) {
      message += ' ğŸš€ Â¡RÃ¡pido!';
    }
    message += '\n';
  }
  
  message += `\nğŸ“Š <b>Estado actual:</b>\n`;
  message += `â€¢ Total: <b>${userStats.totalpoints}</b> puntos\n`;
  message += `â€¢ Nivel: <b>${userStats.level}</b>\n`;
  message += `â€¢ Ranking: <b>#${userStats.rank}</b>\n`;
  message += `â€¢ Racha: <b>${userStats.streak}</b> dÃ­as\n`;
  message += `â€¢ PrecisiÃ³n: <b>${userStats.accuracy}%</b>\n`;
  message += `\nğŸ• Actualizado: ${timestamp}`;
  
  return message;
}

// ============ INTERFAZ BOT PARA SUSCRIPCIONES ============

/**
 * Crear interfaz del bot para comandos de suscripciÃ³n
 */
function createBotInterface(chatid: number) {
  return {
    async sendMessage(targetchatid: number, text: string, options?: any): Promise<any> {
      return await sendTelegramMessage(targetchatid, text);
    },
    async sendInvoice(targetchatid: number, invoiceData: any): Promise<any> {
      try {
        const response = await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/sendInvoice`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            chat_id: targetchatid,
            ...invoiceData
          })
        });
        
        const result = await response.json();
        console.log('ğŸ“§ Invoice enviada:', result.ok ? 'âœ… Exitoso' : 'âŒ FallÃ³');
        return result;
      } catch (error) {
        console.error('âŒ Error enviando invoice:', error);
        throw error;
      }
    }
  };
}

// ============ FUNCIÃ“N PRINCIPAL ============

export async function POST(request: NextRequest) {
  try {
    const update: TelegramUpdate = await request.json();
    
    // ğŸ† Inicializar sistema de torneos automÃ¡ticamente al recibir cualquier update
    initializeTournamentSystem();
    
    // FILTRAR HEALTH CHECKS ANTES DE LOGGING COMPLETO
    if (update && typeof update === 'object' && 'test' in update && update.test === 'health_check') {
      // Log mÃ­nimo para health checks
      console.log(`ğŸ’“ Health check: ${new Date().toLocaleTimeString()}`);
      return NextResponse.json({ status: 'ok', type: 'health_check' });
    }
    
    // LOGGING COMPLETO SOLO PARA UPDATES IMPORTANTES
    console.log('ğŸ”” ============ WEBHOOK UPDATE RECIBIDO ============');
    console.log('ğŸ“… Timestamp:', new Date().toISOString());
    console.log('ğŸ†” Update ID:', update.update_id);
    console.log('ğŸ“Š UPDATE COMPLETO (RAW JSON):', JSON.stringify(update, null, 2));
    console.log('ğŸ“‹ Tipo de update:', {
      hasMessage: !!update.message,
      hasPollAnswer: !!update.poll_answer,
      hasOther: !update.message && !update.poll_answer
    });
    
    // ğŸ’³ MANEJAR PAGOS DE TELEGRAM PRIMERO (PRE-CHECKOUT Y PAGOS EXITOSOS)
    if (update.pre_checkout_query) {
      console.log('ğŸ’³ ======== PRE-CHECKOUT QUERY DETECTADO ========');
      const preCheckout = update.pre_checkout_query;
      
      const isValid = await PaymentService.validatePreCheckout({
        id: preCheckout.id,
        from: preCheckout.from,
        currency: preCheckout.currency,
        total_amount: preCheckout.total_amount,
        invoice_payload: preCheckout.invoice_payload,
        shipping_option_id: preCheckout.shipping_option_id,
        order_info: preCheckout.order_info
      });

      // Responder a Telegram
      try {
        const response = await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/answerPreCheckoutQuery`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            pre_checkout_query_id: preCheckout.id,
            ok: isValid,
            error_message: isValid ? undefined : 'Error validando el pago. IntÃ©ntalo de nuevo.'
          })
        });
        
        console.log('ğŸ“¤ Pre-checkout query respondido:', isValid ? 'âœ… Aprobado' : 'âŒ Rechazado');
      } catch (error) {
        console.error('âŒ Error respondiendo pre-checkout query:', error);
      }

      return NextResponse.json({ ok: true, preCheckoutHandled: isValid });
    }

    // Si NO es poll_answer, mensaje, ni pre_checkout_query, mostrar debugging limitado
    if (!update.poll_answer && !update.message && !update.pre_checkout_query) {
      console.log('ğŸ” DEBUGGING - Propiedades del update:');
      console.log('   - Object.keys(update):', Object.keys(update));
      console.log('   - Todas las propiedades:', update);
      console.log('â„¹ï¸  Update ignorado: sin mensaje, poll_answer ni pre_checkout_query');
      return NextResponse.json({ ok: true });
    }
    


    // Manejar respuestas de polls (SISTEMA PRINCIPAL + TORNEOS)
    if (update.poll_answer) {
      console.log('ğŸ—³ï¸  ======== POLL ANSWER DETECTADO ========');
      console.log('ğŸ‘¤ Usuario que responde:', {
        telegramId: update.poll_answer.user.id,
        username: `@${update.poll_answer.user.username || 'SIN_USERNAME'}`,
        firstName: update.poll_answer.user.first_name,
        lastName: update.poll_answer.user.last_name || '',
        isBot: update.poll_answer.user.is_bot
      });
      console.log('ğŸ—³ï¸  Poll details:', {
        pollid: update.poll_answer.poll_id,
        selectedOptions: update.poll_answer.option_ids,
        optionCount: update.poll_answer.option_ids.length
      });
      
      // ğŸ† PASO 3: Intentar manejar con sistema de torneos primero
      const tournamentPollAnswer = {
        poll_id: update.poll_answer.poll_id,
        user: update.poll_answer.user,
        option_ids: update.poll_answer.option_ids
      };
      const handledByTournament = await TournamentService.getInstance().handleTournamentPollAnswer(tournamentPollAnswer);
      
      if (handledByTournament) {
        console.log('ğŸ† Poll answer manejado por sistema de torneos');
        return NextResponse.json({ ok: true, handledBy: 'tournament' });
      }
      
      // Si no fue manejado por torneos, usar sistema normal
      console.log('ğŸ“‹ Poll answer manejado por sistema normal');
      return await handlePollAnswer(update.poll_answer);
    }

    // ğŸ†• NUEVO: Manejar nuevos miembros del grupo
    if (update.message?.new_chat_members && update.message.new_chat_members.length > 0) {
      console.log('ğŸ‘‹ ======== NUEVOS MIEMBROS DETECTADOS ========');
      return await handleNewChatMembers(update.message);
    }

    // ğŸ’° MANEJAR PAGOS EXITOSOS
    if (update.message?.successful_payment) {
      console.log('ğŸ’° ======== PAGO EXITOSO DETECTADO ========');
      const payment = update.message.successful_payment;
      const userid = update.message.from.id.toString();
      
      console.log('ğŸ’³ Detalles del pago:', {
        userid,
        currency: payment.currency,
        totalAmount: payment.total_amount,
        payloadInfo: payment.invoice_payload?.substring(0, 50) + '...'
      });
      
      const success = await PaymentService.processSuccessfulPayment(userid, {
        currency: payment.currency,
        total_amount: payment.total_amount,
        invoice_payload: payment.invoice_payload,
        shipping_option_id: payment.shipping_option_id,
        order_info: payment.order_info,
        telegram_payment_charge_id: payment.telegram_payment_charge_id,
        provider_payment_charge_id: payment.provider_payment_charge_id
      });

      if (success) {
        console.log('âœ… Pago procesado exitosamente, suscripciÃ³n activada');
        
        // Generar mensaje de confirmaciÃ³n usando PaymentService
        const payloadParts = payment.invoice_payload.split('_');
        const planName = payloadParts[1] || 'premium';
        const confirmationMessage = PaymentService.generatePaymentConfirmation(planName, payment.total_amount);

        await sendTelegramMessage(update.message.chat.id, confirmationMessage);
      } else {
        console.log('âŒ Error procesando pago exitoso');
        await sendTelegramMessage(update.message.chat.id, 
          'âŒ Hubo un problema procesando tu pago. Contacta con soporte: @Carlos_esp'
        );
      }

      return NextResponse.json({ ok: true, paymentProcessed: success });
    }

    const message = update.message;
    
    if (!message) {
      console.log('â„¹ï¸  Update ignorado: sin mensaje');
      return NextResponse.json({ ok: true });
    }
    
    const user = message.from;
    
    // FILTRAR MENSAJES DEL BOT - No procesar sus propios mensajes
    if (user.is_bot) {
      console.log('ğŸ¤– Ignorando mensaje del bot:', user.first_name);
      return NextResponse.json({ ok: true, message: 'Mensaje del bot ignorado' });
    }
    
    console.log('ğŸ’¬ ======== MENSAJE RECIBIDO ========');
    console.log('ğŸ“ Detalles del mensaje:', {
      messageId: message.message_id,
      from: `${user.first_name} (@${user.username || 'sin_username'})`,
      text: message.text ? (message.text.length > 100 ? message.text.substring(0, 100) + '...' : message.text) : 'Sin texto',
      chat: message.chat.id,
      isBot: user.is_bot,
      isCommand: message.text?.startsWith('/') || false
    });

    // Manejar comandos del bot con sistema inteligente
    const commandResponse = await handleBotCommands(message);
    
    if (commandResponse === 'INTELLIGENT_SYSTEM_HANDLED') {
      // El sistema inteligente ya manejÃ³ el envÃ­o
      return NextResponse.json({ 
        ok: true, 
        type: 'command_handled',
        command: message.text,
        responseSent: true,
        intelligentSystem: true
      });
    }
    
    if (commandResponse) {
      // Comando tradicional (sin sistema inteligente)
      const sent = await sendTelegramMessage(message.chat.id, commandResponse);
      console.log(' Mensaje enviado:', sent ? 'âœ… Exitoso' : 'âŒ FallÃ³');
      
      return NextResponse.json({ 
        ok: true, 
        type: 'command_handled',
        command: message.text,
        responseSent: sent,
        intelligentSystem: false
      });
    }

    // SISTEMA LEGACY: Verificar si es una respuesta a una pregunta (mantenemos para compatibilidad)
    if (!message.reply_to_message?.text) {
      console.log('â„¹ï¸  Mensaje ignorado: no es comando ni respuesta a pregunta');
      return NextResponse.json({ ok: true, message: 'No es una respuesta a pregunta' });
    }

    // Extraer informaciÃ³n de la pregunta original
    const originalMessage = message.reply_to_message.text || '';
    const questionId = extractQuestionId(originalMessage);

    if (!questionId) {
      console.log('âš ï¸  No se pudo extraer ID de pregunta del mensaje original');
      return NextResponse.json({ ok: true });
    }

    // Obtener la pregunta de la base de datos para verificar la respuesta
    // AquÃ­ necesitarÃ­as implementar la lÃ³gica para obtener la pregunta
    // Por ahora, simularemos que todas las respuestas son correctas para testing
    const isCorrect = true; // TODO: Implementar verificaciÃ³n real

    // Calcular tiempo de respuesta (en segundos)
    const responseTime = calculateResponseTime(
      message.reply_to_message?.date || message.date,
      message.date
    );

    console.log('ğŸ® Procesando respuesta legacy:', {
      questionId,
      iscorrect: isCorrect,
      responsetime: responseTime,
      telegramuser: `${user.first_name} (@${user.username || 'sin_username'})`
    });

    // Procesar la respuesta con el sistema de gamificaciÃ³n
    const userStats = await GamificationService.processUserResponse({
      telegramUserId: user.id.toString(),
      username: user.username,
      firstName: user.first_name,
      lastName: user.last_name,
      questionId: questionId,
      telegramMsgId: message.message_id.toString(),
      isCorrect: isCorrect,
      responseTime: responseTime
    });

    // Enviar respuesta de confirmaciÃ³n al usuario
    const responseMessage = formatResponseMessage(userStats, isCorrect);
    
    // Generar mensaje de respuesta personalizado  
    console.log('ğŸ’¬ Sistema inteligente: procesando respuesta de quiz...');
    
    // Datos temporales para la respuesta legacy (sistema principal estÃ¡ en poll answers)
    const tempQuestionData = {
      questionid: questionId,
      correctanswerindex: 0,
      createdat: new Date(message.reply_to_message?.date || message.date),
      chatid: message.chat.id
    };
    
    // Usar sistema inteligente para enviar respuesta de quiz
    const quizResult = await NotificationService.sendIntelligentQuizResponse(
      userStats,
      isCorrect,
      tempQuestionData,
      {
        telegramUserId: user.id.toString(),
        firstName: user.first_name,
        username: user.username
      },
      message.chat.id.toString()
    );
    
    console.log('ğŸ“¤ Resultado sistema inteligente quiz:', quizResult.method, '|', quizResult.message);

    console.log('âœ… Respuesta legacy procesada:', {
      telegramuser: user.username || user.first_name,
      questionId,
      iscorrect: isCorrect,
      responsetime: responseTime,
      newStats: userStats
    });

    return NextResponse.json({ 
      ok: true, 
      processed: true,
      userStats 
    });

  } catch (error) {
    console.error('âŒ ============ ERROR EN WEBHOOK ============');
    console.error('ğŸ’¥ Error completo:', error);
    console.error('ğŸ“Š Stack trace:', error instanceof Error ? error.stack : 'No stack trace');
    
    return NextResponse.json({ 
      ok: false, 
      error: 'Error interno del servidor' 
    }, { status: 500 });
  }
}

function formatResponseMessage(stats: any, iscorrect: boolean): string {
  const correctEmoji = iscorrect ? 'âœ…' : 'âŒ';
  const levelEmoji = getLevelEmoji(stats.level);
  
  return `${correctEmoji} ${iscorrect ? 'Correcto' : 'Incorrecto'}!

ğŸ† <b>Tus estadÃ­sticas:</b>
ğŸ“Š Puntos: ${stats.totalpoints}
${levelEmoji} Nivel: ${stats.level}
ğŸ”¥ Racha: ${stats.streak} dÃ­as
ğŸ¯ PrecisiÃ³n: ${stats.accuracy}%
ğŸ“ˆ Ranking: #${stats.rank}

${getMotivationalMessage(stats, iscorrect)}`;
}

function getLevelEmoji(level: number): string {
  if (level <= 2) return 'ğŸ¥‰';
  if (level <= 5) return 'ğŸ¥ˆ';
  if (level <= 10) return 'ğŸ¥‡';
  return 'ğŸ’';
}

function getMotivationalMessage(stats: any, iscorrect: boolean): string {
  const messages = {
    correct: [
      'Â¡Excelente trabajo! ğŸ‰',
      'Â¡Sigue asÃ­! ğŸ’ª',
      'Â¡Imparable! âš¡',
      'Â¡Genial! ğŸŒŸ'
    ],
    incorrect: [
      'Â¡No te rindas! La prÃ³xima serÃ¡ mejor ğŸ’ª',
      'Â¡Cada error es una oportunidad de aprender! ğŸ“š',
      'Â¡Sigue intentando! ğŸ¯',
      'Â¡La prÃ¡ctica hace al maestro! â­'
    ]
  };

  const messageArray = iscorrect ? messages.correct : messages.incorrect;
  return messageArray[Math.floor(Math.random() * messageArray.length)];
}

// FunciÃ³n para manejar comandos del bot con sistema inteligente
export async function handleBotCommands(message: any): Promise<string | null> {
  const text = message.text?.toLowerCase().trim();
  
  if (!text || !text.startsWith('/')) {
    return null;
  }

  const userid = message.from.id.toString();
  const isGroupChat = message.chat.type === 'group' || message.chat.type === 'supergroup';
  const originalCommand = message.text.trim();
  
  // Buscar el usuario en la base de datos para el sistema inteligente
  let telegramuser: { telegramUserId: string; firstname?: string } | null = null;
  try {
    const prismaUser = await prisma.telegramuser.findUnique({
      where: { telegramUserId: userid }
    });
    
    if (prismaUser) {
      telegramuser = {
        telegramUserId: prismaUser.telegramuserid,
        firstname: prismaUser.firstName || undefined
      };
    }
  } catch (error) {
    console.log('âš ï¸ Error buscando usuario para sistema inteligente:', error);
  }
  
  // Si no hay usuario, crear registro bÃ¡sico
  if (!telegramuser) {
    telegramuser = {
      telegramUserId: userid,
      firstname: message.from.first_name || message.from.username || 'Usuario'
    };
  }
  
  // Extraer el comando base (primera palabra)
  const commandBase = text.split(' ')[0];
  
  let commandResponse: string | null = null;

  switch (commandBase) {
    case '/start':
      // Registrar usuario en la base de datos si no existe
      try {
        const existingUser = await prisma.telegramuser.findUnique({
          where: { telegramUserId: userid }
        });

        if (!existingUser) {
          // Crear nuevo usuario en la base de datos con puntos iniciales para duelos
          await prisma.telegramuser.create({
                          data: {
                id: generateId(),
                telegramUserId: userid,
                username: message.from.username,
                firstname: message.from.first_name,
              lastname: message.from.last_name,
              totalpoints: 25, // ğŸ Puntos iniciales para poder participar en duelos
              lastactivity: new Date()
            }
          });
          
          console.log('âœ… Nuevo usuario registrado en BD con puntos iniciales:', {
            telegramUserId: userid,
            username: message.from.username,
            firstname: message.from.first_name,
            initialPoints: 25
          });
        } else {
          console.log('â„¹ï¸ Usuario ya existe en BD:', existingUser.username || existingUser.firstName);
        }
      } catch (error) {
        console.error('âŒ Error registrando usuario en /start:', error);
      }

      return `ğŸ‰ <b>Â¡BIENVENIDO A OPOMELILLA!</b> ğŸ‰

Â¡Hola! Te has registrado exitosamente.

ğŸ <b>REGALO DE BIENVENIDA:</b>
âœ… Has recibido 25 puntos iniciales
âœ… Â¡Ya puedes participar en duelos!

ğŸ¯ <b>Â¿QUÃ‰ PUEDES HACER AHORA?</b>
ğŸ“Š Responder preguntas para ganar puntos
ğŸ† Competir en el ranking general
ğŸ”¥ Mantener rachas diarias de estudio
ğŸ—¡ï¸ Retar a duelos contra otros usuarios (Â¡YA DISPONIBLE!)
ğŸ… Desbloquear logros Ãºnicos

âš¡ <b>CONFIGURACIÃ“N COMPLETADA:</b>
âœ… Perfil creado y listo
âœ… Notificaciones privadas activadas
âœ… Sistema de puntos inicializado (25 pts)
âœ… Â¡Listo para participar en duelos!

ğŸš€ <b>PRIMEROS PASOS:</b>
â€¢ Ve al grupo y responde algunas preguntas
â€¢ Usa <code>/stats</code> para ver tu progreso
â€¢ Usa <code>/ranking</code> para ver la competencia
â€¢ Usa <code>/duelo @usuario</code> para retar a alguien (Â¡ya puedes!)

ğŸ’¡ <b>TIP:</b> A partir de ahora recibirÃ¡s notificaciones privadas detalladas en lugar de mensajes breves en el grupo.

Â¡Buena suerte en tu preparaciÃ³n para obtener tu plaza de PERMANENTE! ğŸ€`;

    case '/ranking':
    case '/leaderboard':
      console.log('ğŸ† RANKING COMMAND - Usuario solicitÃ³ ranking:', {
        userid,
        username: message.from.username,
        firstName: message.from.first_name,
        timestamp: new Date().toISOString()
      });
      
      const leaderboard = await GamificationService.getLeaderboard(10);
      console.log('ğŸ† RANKING RESULT - Datos obtenidos:', {
        totalUsers: leaderboard.length,
        toptelegramuser: leaderboard[0] ? {
          name: leaderboard[0].user.firstName || leaderboard[0].user.username,
          points: leaderboard[0].points
        } : 'No hay usuarios'
      });
      
      commandResponse = formatLeaderboard(leaderboard);
      break;

    case '/ranking_semanal':
      console.log('ğŸ“… RANKING_SEMANAL COMMAND - Usuario solicitÃ³ ranking semanal:', {
        userid,
        username: message.from.username,
        firstName: message.from.first_name,
        timestamp: new Date().toISOString()
      });
      
      const weeklyLeaderboard = await GamificationService.getWeeklyLeaderboard(10);
      console.log('ğŸ“… RANKING_SEMANAL RESULT - Datos obtenidos:', {
        totalUsers: weeklyLeaderboard.length,
        toptelegramuser: weeklyLeaderboard[0] ? {
          name: weeklyLeaderboard[0].user.firstName || weeklyLeaderboard[0].user.username,
          points: weeklyLeaderboard[0].points
        } : 'No hay usuarios'
      });
      
      commandResponse = formatLeaderboard(weeklyLeaderboard, 'RANKING SEMANAL', 'semanal');
      break;

    case '/ranking_mensual':
      console.log('ğŸ“… RANKING_MENSUAL COMMAND - Usuario solicitÃ³ ranking mensual:', {
        userid,
        username: message.from.username,
        firstName: message.from.first_name,
        timestamp: new Date().toISOString()
      });
      
      const monthlyLeaderboard = await GamificationService.getMonthlyLeaderboard(10);
      console.log('ğŸ“… RANKING_MENSUAL RESULT - Datos obtenidos:', {
        totalUsers: monthlyLeaderboard.length,
        toptelegramuser: monthlyLeaderboard[0] ? {
          name: monthlyLeaderboard[0].user.firstName || monthlyLeaderboard[0].user.username,
          points: monthlyLeaderboard[0].points
        } : 'No hay usuarios'
      });
      
      commandResponse = formatLeaderboard(monthlyLeaderboard, 'RANKING MENSUAL', 'mensual');
      break;

    case '/stats':
    case '/mi_stats':
      const userStats = await GamificationService.getUserStats(userid);
      if (!userStats) {
        commandResponse = 'âŒ No tienes estadÃ­sticas aÃºn. Â¡Responde algunas preguntas para empezar!';
      } else {
        commandResponse = formatUserStats(userStats);
      }
      break;

    case '/miprogreso':
      console.log('ğŸ“Š MIPROGRESO COMMAND - Ver progreso personal de graduaciones');
      return await handleMiProgresoCommand(userid, message.from);

    case '/estadisticas':
      console.log('ğŸ“ˆ ESTADISTICAS COMMAND - Ver estadÃ­sticas por materia');
      return await handleEstadisticasCommand(userid, message.from);

    case '/graduadas':
      console.log('ğŸ“ GRADUADAS COMMAND - Ver preguntas graduadas');
      return await handleGraduadasCommand(userid, message.from);

    case '/reiniciar_graduacion':
      console.log('ğŸ”„ REINICIAR_GRADUACION COMMAND - Reset de graduaciones');
      return await handleReiniciarGraduacionCommand(userid, message.from);

    case '/reiniciar_graduacion_confirmar':
      console.log('âœ… REINICIAR_GRADUACION_CONFIRMAR COMMAND - Confirmar reset');
      return await handleReiniciarGraduacionConfirmarCommand(userid, message.from);

    case '/configurar_notificaciones':
      console.log('âš™ï¸ CONFIGURAR_NOTIFICACIONES COMMAND - Configurar sistema de notificaciones');
      return await handleConfigurarNotificacionesCommand(userid, message.from);

    // ==========================================
    // ğŸ”” COMANDOS ESPECÃFICOS DE NOTIFICACIONES
    // ==========================================
    
    case '/notificaciones_graduacion':
      console.log('ğŸ“ NOTIFICACIONES_GRADUACION COMMAND - Configurar notificaciones de graduaciÃ³n');
      return await handleNotificacionesGraduacionCommand(userid, message.from, message.text);

    case '/notificaciones_logros':
      console.log('ğŸ† NOTIFICACIONES_LOGROS COMMAND - Configurar notificaciones de logros');
      return await handleNotificacionesLogrosCommand(userid, message.from, message.text);

    case '/notificaciones_recordatorios':
      console.log('â° NOTIFICACIONES_RECORDATORIOS COMMAND - Configurar recordatorios');
      return await handleNotificacionesRecordatoriosCommand(userid, message.from, message.text);

    case '/notificaciones_semanales':
      console.log('ğŸ“Š NOTIFICACIONES_SEMANALES COMMAND - Configurar reportes semanales');
      return await handleNotificacionesSemanalesCommand(userid, message.from, message.text);

    case '/horario_notificaciones':
      console.log('ğŸ• HORARIO_NOTIFICACIONES COMMAND - Configurar horario');
      return await handleHorarioNotificacionesCommand(userid, message.from, message.text);

    // ==========================================
    // ğŸ“Š COMANDOS DE QUOTAS Y LÃMITES
    // ==========================================
    
    case '/mi_quota':
    case '/cuantas_me_quedan':
    case '/limite_diario':
      console.log('ğŸ“Š MI_QUOTA COMMAND - Ver lÃ­mites y uso actual');
      return await handleMiQuotaCommand(userid, message.from);

    case '/racha':
      const streakStats = await GamificationService.getUserStats(userid);
      if (!streakStats) {
        commandResponse = 'âŒ No tienes estadÃ­sticas aÃºn. Â¡Responde algunas preguntas para empezar!';
      } else {
        commandResponse = formatStreakInfo(streakStats);
      }
      break;

    case '/logros':
    case '/achievements':
      const achievements = await getUserAchievements(userid);
      commandResponse = formatUserAchievements(achievements, userid);
      break;

    case '/prediccion':
    case '/prediction':
      const predictionStats = await GamificationService.getUserStats(userid);
      if (!predictionStats) {
        commandResponse = 'âŒ No tienes estadÃ­sticas aÃºn. Â¡Responde algunas preguntas para empezar!';
      } else {
        commandResponse = formatLevelPrediction(predictionStats);
      }
      break;

    case '/metas':
    case '/goals':
      const userGoals = await getUserGoals(userid);
      commandResponse = formatUserGoals(userGoals, userid);
      break;

    case '/duelo':
    case '/duel':
      return await handleDuelCommand(message.text, userid, message.from, message.chat.id);

    case '/duelos':
    case '/duels':
      const userDuels = await DuelService.getUserDuels(userid);
      commandResponse = formatUserDuels(userDuels, userid);
      break;

    case '/aceptar':
    case '/accept':
      return await handleAcceptDuel(message.text, userid);

    case '/rechazar':
    case '/reject':
      return await handleRejectDuel(message.text, userid);

    case '/notificaciones':
    case '/notifications':
      commandResponse = formatNotificationHelp();
      break;

    case '/privadas':
    case '/private':
      commandResponse = formatPrivateMessageHelp();
      break;

    case '/test':
    case '/prueba':
      return await handleTestCommand(userid, message.from);

    case '/help':
      commandResponse = formatHelpMessage();
      break;

    case '/duelos':
      console.log('ğŸ“Š DUELOS COMMAND - Ver duelos del usuario');
      commandResponse = await handleUserDuels(userid);
      break;

    case '/examen2018':
      console.log('ğŸ¯ EXAMEN2018 COMMAND - Pregunta especÃ­fica del examen oficial 2018');
      return await handleExamen2018Command(userid, message.from);

    case '/examen2018stats':
      console.log('ğŸ“Š EXAMEN2018STATS COMMAND - EstadÃ­sticas del examen oficial');
      return await handleExamen2018StatsCommand(userid, message.from);

    case '/examen2024':
      console.log('ğŸ¯ EXAMEN2024 COMMAND - Pregunta especÃ­fica del examen oficial 2024');
      return await handleExamen2024Command(userid, message.from);

    case '/examen2024stats':
      console.log('ğŸ“Š EXAMEN2024STATS COMMAND - EstadÃ­sticas del examen oficial 2024');
      return await handleExamen2024StatsCommand(userid, message.from);

    case '/simulacro':
      console.log('ğŸ¯ SIMULACRO COMMAND - Iniciar simulacro del examen oficial');
      return await handleSimulacroCommand(userid, message.from);

    case '/simulacro_continuar':
      console.log('â–¶ï¸ SIMULACRO_CONTINUAR COMMAND - Continuar simulacro en progreso');
      return await handleSimulacroResumeCommand(userid, message.from);

    case '/simulacro_abandonar':
      console.log('ğŸšª SIMULACRO_ABANDONAR COMMAND - Abandonar simulacro actual');
      return await handleSimulacroAbandonCommand(userid, message.from);

    case '/simulacro_historial':
      console.log('ğŸ“‹ SIMULACRO_HISTORIAL COMMAND - Ver historial de simulacros');
      return await handleSimulacroHistoryCommand(userid, message.from);

    case '/simulacro2024':
      console.log('ğŸ¯ SIMULACRO2024 COMMAND - Iniciar simulacro del examen oficial 2024');
      return await handleSimulacro2024Command(userid, message.from);

    case '/ranking_oficial2018':
      console.log('ğŸ† RANKING_OFICIAL2018 COMMAND - Ranking especÃ­fico del examen 2018');
      return await handleRankingOficial2018Command(userid, message.from);

    case '/ranking_oficial2024':
      console.log('ğŸ† RANKING_OFICIAL2024 COMMAND - Ranking especÃ­fico del examen 2024');
      return await handleRankingOficial2024Command(userid, message.from);

    case '/comparativa_examenes':
      console.log('ğŸ“Š COMPARATIVA_EXAMENES COMMAND - Comparativa personal entre exÃ¡menes');
      return await handleComparativaExamenesCommand(userid, message.from);

    case '/simulacro_oficial':
      console.log('ğŸ¯ SIMULACRO_OFICIAL COMMAND - Selector de simulacro oficial');
      return await handleSimulacroOficialCommand(userid, message.from);

    case '/torneo':
    case '/tournament':
      console.log('ğŸ† TORNEO COMMAND - GestiÃ³n de torneos');
      return await handleTorneoCommand(userid, message.from, message.text);

    case '/torneos':
    case '/tournaments':
      console.log('ğŸ† TORNEOS COMMAND - Ver torneos disponibles');
      return await handleTorneosListCommand(userid, message.from);

    case '/torneo_unirse':
      console.log('âœ… TORNEO_UNIRSE COMMAND - Unirse a torneo');
      return await handleTorneoJoinCommand(userid, message.from, message.text);

    case '/torneo_salir':
      console.log('âŒ TORNEO_SALIR COMMAND - Salir de torneo');
      return await handleTorneoLeaveCommand(userid, message.from, message.text);

    case '/torneo_historial':
      console.log('ğŸ“Š TORNEO_HISTORIAL COMMAND - Historial de torneos');
      return await handleTorneoHistoryCommand(userid, message.from);

    // ==========================================
    // ğŸ’° COMANDOS DE SUSCRIPCIONES Y PAGOS - ESPAÃ‘A
    // ==========================================
    
    case '/planes':
      console.log('ğŸ’° PLANES COMMAND - Ver planes de suscripciÃ³n disponibles');
      await SubscriptionCommands.handlePlanesCommand(message, createBotInterface(message.chat.id));
      return 'INTELLIGENT_SYSTEM_HANDLED';

    case '/basico':
      console.log('ğŸ¥‰ BASICO COMMAND - Suscribirse al plan BÃ¡sico');
      await SubscriptionCommands.handleBasicoCommand(message, createBotInterface(message.chat.id));
      return 'INTELLIGENT_SYSTEM_HANDLED';

    case '/premium':
      console.log('ğŸ¥ˆ PREMIUM COMMAND - Suscribirse al plan Premium');
      await SubscriptionCommands.handlePremiumCommand(message, createBotInterface(message.chat.id));
      return 'INTELLIGENT_SYSTEM_HANDLED';

    case '/mi_plan':
      console.log('ğŸ‘¤ MI_PLAN COMMAND - Ver estado de suscripciÃ³n actual');
      await SubscriptionCommands.handleMiPlanCommand(message, createBotInterface(message.chat.id));
      return 'INTELLIGENT_SYSTEM_HANDLED';

    case '/cancelar':
      console.log('ğŸš« CANCELAR COMMAND - Proceso de cancelaciÃ³n de suscripciÃ³n');
      await SubscriptionCommands.handleCancelarCommand(message, createBotInterface(message.chat.id));
      return 'INTELLIGENT_SYSTEM_HANDLED';

    case '/facturas':
      console.log('ğŸ“„ FACTURAS COMMAND - Ver historial de transacciones');
      await SubscriptionCommands.handleFacturasCommand(message, createBotInterface(message.chat.id));
      return 'INTELLIGENT_SYSTEM_HANDLED';

    // ==========================================
    // ğŸ’ COMANDOS AVANZADOS DE SUSCRIPCIÃ“N (FASE 2)
    // ==========================================
    
    case '/renovar':
      console.log('ğŸ”„ RENOVAR COMMAND - RenovaciÃ³n manual de suscripciÃ³n');
      const { handleRenovarCommand } = await import('@/services/advancedSubscriptionCommands');
      return await handleRenovarCommand(userid, message.from);

    case '/cambiar_plan':
      console.log('ğŸ”„ CAMBIAR_PLAN COMMAND - Upgrade/downgrade entre planes');
      const { handleCambiarPlanCommand } = await import('@/services/advancedSubscriptionCommands');
      return await handleCambiarPlanCommand(userid, message.from);

    // ==========================================
    // ğŸ–ï¸ COMANDOS DE SIMULACROS MILITARES PREMIUM (FASE 3)
    // ==========================================
    
    case '/simulacro_premium_et':
      console.log('ğŸ–ï¸ SIMULACRO_PREMIUM_ET COMMAND - Simulacro EjÃ©rcito de Tierra Premium');
      const { handleSimulacroEjercitoTierraCommand } = await import('@/services/militarySimulationCommands');
      return await handleSimulacroEjercitoTierraCommand(userid, message.from);

    case '/simulacro_premium_aire':
      console.log('âœˆï¸ SIMULACRO_PREMIUM_AIRE COMMAND - Simulacro EjÃ©rcito del Aire Premium');
      const { handleSimulacroEjercitoAireCommand } = await import('@/services/militarySimulationCommands');
      return await handleSimulacroEjercitoAireCommand(userid, message.from);

    case '/simulacro_premium_armada':
      console.log('âš“ SIMULACRO_PREMIUM_ARMADA COMMAND - Simulacro Armada Premium');
      const { handleSimulacroArmadaCommand } = await import('@/services/militarySimulationCommands');
      return await handleSimulacroArmadaCommand(userid, message.from);

    case '/simulacros_premium':
      console.log('ğŸ–ï¸ SIMULACROS_PREMIUM COMMAND - InformaciÃ³n de simulacros militares');
      const { handleSimulacrosPremiumInfoCommand } = await import('@/services/militarySimulationCommands');
      return await handleSimulacrosPremiumInfoCommand(userid, message.from);

    // ==========================================
    // ğŸ“ COMANDOS DE INTEGRACIÃ“N MOODLE (FASE 4)
    // ==========================================
    
    case '/vincular_moodle':
      console.log('ğŸ”— VINCULAR_MOODLE COMMAND - Generar cÃ³digo de verificaciÃ³n');
      const { handleVincularMoodleCommand } = await import('@/services/moodleGamificationCommands');
      return await handleVincularMoodleCommand(userid, message.from);

    case '/estado_moodle':
      console.log('ğŸ“Š ESTADO_MOODLE COMMAND - Ver estado de vinculaciÃ³n');
      const { handleEstadoMoodleCommand } = await import('@/services/moodleGamificationCommands');
      return await handleEstadoMoodleCommand(userid, message.from);

    case '/estadisticas_unificadas':
      console.log('ğŸ“ˆ ESTADISTICAS_UNIFICADAS COMMAND - Ver estadÃ­sticas Premium unificadas');
      const { handleEstadisticasUnificadasCommand } = await import('@/services/moodleGamificationCommands');
      return await handleEstadisticasUnificadasCommand(userid, message.from);

    case '/codigo_moodle':
      console.log('ğŸ”‘ CODIGO_MOODLE COMMAND - Introducir cÃ³digo generado en Moodle');
      const commandParts = message.text.trim().split(' ');
      const moodleCode = commandParts[1];
      
      if (!moodleCode) {
        return `âŒ **Uso incorrecto del comando**

**ğŸ“‹ Formato correcto:**
\`/codigo_moodle ABC123\`

**ğŸ” DÃ³nde encontrar el cÃ³digo:**
1. Ve a opomelilla.com
2. Accede a: Perfil â†’ Preferencias â†’ IntegraciÃ³n con Telegram   
3. Haz clic en "Generar cÃ³digo"
4. Copia el cÃ³digo de 6 caracteres
5. Ãšsalo aquÃ­: \`/codigo_moodle TU_CODIGO\`

ğŸ’¡ Los cÃ³digos expiran en 15 minutos.`;
      }
      
      const { handleCodigoMoodleCommand } = await import('@/services/moodleGamificationCommands');
      return await handleCodigoMoodleCommand(userid, moodleCode, message.from);

    case '/sincronizar_moodle':
      console.log('ğŸ”„ SINCRONIZAR_MOODLE COMMAND - SincronizaciÃ³n manual de actividades');
      const { handleSincronizarMoodleCommand } = await import('@/services/moodleGamificationCommands');
      return await handleSincronizarMoodleCommand(userid, message.from);

    // ==========================================
    // ğŸ¯ COMANDOS DE SESIONES DE ESTUDIO PRIVADAS
    // ==========================================
    
    case '/stop':
      console.log('ğŸ›‘ STOP COMMAND - Cancelar sesiÃ³n de estudio');
      return await handleStopStudySession(userid, message);

    case '/progreso':
      console.log('ğŸ“Š PROGRESO COMMAND - Ver progreso de sesiÃ³n de estudio');
      return await handleStudyProgress(userid, message);

    // ========================================
    // ğŸ¯ DETECTAR COMANDOS DE ESTUDIO (incluyendo /falladas)
    // ========================================
    default:
      const studyCommand = StudySessionService.parseStudyCommand(commandBase);
      if (studyCommand) {
        console.log(`ğŸ¯ STUDY COMMAND - Materia: ${studyCommand.subject}, Cantidad: ${studyCommand.quantity}, Tipo: ${studyCommand.type || 'normal'}`);
        return await handleStudyCommand(userid, message, studyCommand);
      }
      
      return null;
  }
  
  // Si no hay respuesta, salir
  if (!commandResponse) {
    return null;
  }
  
  console.log(`ğŸ“§ COMANDO INTELIGENTE: ${originalCommand} | Usuario: ${telegramuser?.firstName || 'Usuario'} | Grupo: ${isGroupChat}`);
  
  // Usar el sistema inteligente para enviar la respuesta
  try {
    const userForNotification = {
      telegramUserId: telegramuser!.telegramuserid,
      firstName: telegramuser!.firstName
    };
    
    const result = await NotificationService.sendIntelligentCommandResponse(
      originalCommand,
      commandResponse,
      userForNotification,
      message.chat.id.toString(),
      isGroupChat
    );
    
    console.log(`ğŸ“¨ RESULTADO INTELIGENTE: ${result.method} | Success: ${result.success} | ${result.message}`);
    
    // Si el sistema inteligente manejÃ³ el envÃ­o, devolver indicador especial
    if (result.success) {
      return 'INTELLIGENT_SYSTEM_HANDLED';
    }
    
    // Si fallÃ³ todo, devolver la respuesta normal como fallback
    return commandResponse;
    
  } catch (error) {
    console.log('âš ï¸ Error en sistema inteligente, usando fallback normal:', error);
    return commandResponse;
  }
}

function formatLeaderboard(leaderboard: any[], title: string = 'RANKING GENERAL', type: string = 'general'): string {
  const timestamp = new Date().toLocaleTimeString('es-ES', {
    hour: '2-digit',
    minute: '2-digit',
    second: '2-digit'
  });
  const date = new Date().toLocaleDateString('es-ES');
  
  let message = `ğŸ† <b>${title}</b> ğŸ†\n`;
  message += `ğŸ“… ${date} - ğŸ• ${timestamp}\n\n`;
  
  if (leaderboard.length === 0) {
    message += 'ğŸ“Š <i>No hay usuarios registrados aÃºn</i>\n\n';
    message += 'ğŸ’¡ <b>Â¡SÃ© el primero!</b>\n';
    message += 'Responde preguntas para aparecer en el ranking.';
    return message;
  }
  
  leaderboard.forEach((entry, index) => {
    const medal = index === 0 ? 'ğŸ¥‡' : index === 1 ? 'ğŸ¥ˆ' : index === 2 ? 'ğŸ¥‰' : 'ğŸ”¸';
    const name = entry.user.username || entry.user.firstName || 'Usuario';
    
    message += `${medal} <b>${entry.rank}.</b> ${name}\n`;
    message += `   ğŸ“Š ${entry.points} pts | ${getLevelEmoji(entry.level)} Nv.${entry.level} | ğŸ”¥ ${entry.streak}\n\n`;
  });

  // Mensaje motivacional personalizado segÃºn el tipo
  if (type === 'semanal') {
    message += `\nğŸ’¡ <b>TIP:</b> ğŸ“… Â¡Sigue asÃ­ esta semana para mantener tu posiciÃ³n!`;
  } else if (type === 'mensual') {
    message += `\nğŸ’¡ <b>TIP:</b> ğŸ“… Â¡ContinÃºa estudiando para dominar este mes!`;
  } else {
    message += `\nğŸ’¡ <b>TIP:</b> Usa /stats para ver tus estadÃ­sticas detalladas`;
  }
  
  return message;
}
  
// FunciÃ³n para formatear estadÃ­sticas del usuario
function formatUserStats(telegramuser: any): string {
  const winRate = telegramuser.totalDuels > 0 ? Math.round((telegramuser.wonDuels / telegramuser.totalDuels) * 100) : 0;
  
  return `ğŸ“Š <b>TUS ESTADÃSTICAS</b> ğŸ“Š

ğŸ‘¤ <b>${telegramuser.firstName || telegramuser.username || 'Usuario'}</b>

ğŸ—¡ï¸ <b>DUELOS:</b>
   ğŸ“ˆ Total disputados: ${telegramuser.totalDuels || 0}
   ğŸ† Ganados: ${telegramuser.wonDuels || 0}
   ğŸ˜” Perdidos: ${telegramuser.lostDuels || 0}
   ğŸ“Š Porcentaje victoria: ${winRate}%
   ğŸ”¥ Racha actual: ${telegramuser.currentStreak || 0}

ğŸ’° <b>PUNTOS:</b>
   ğŸ’ Total: ${telegramuser.totalpoints || 0}
   ğŸ“Š Nivel: ${telegramuser.level || 1}
   âš¡ Racha respuestas: ${telegramuser.streak || 0}
   ğŸ… Mejor racha: ${telegramuser.beststreak || 0}

ğŸ¯ <b>ACTIVIDAD:</b>
   ğŸ“… Se uniÃ³: ${telegramuser.joinedAt ? new Date(telegramuser.joinedAt).toLocaleDateString() : 'N/A'}
   ğŸ• Ãšltima actividad: ${telegramuser.lastActivity ? new Date(telegramuser.lastActivity).toLocaleDateString() : 'N/A'}

ğŸ® <b>ACCIONES DISPONIBLES:</b>
â€¢ <code>/duelo @usuario</code> - Retar a duelo
â€¢ <code>/duelos</code> - Ver tus duelos
â€¢ <code>/ranking</code> - Ver clasificaciÃ³n general

âš”ï¸ <b>Â¿Listo para mÃ¡s duelos?</b>`;
}

function formatStreakInfo(stats: any): string {
  const streakEmoji = stats.streak >= 7 ? 'ğŸ”¥ğŸ”¥ğŸ”¥' : stats.streak >= 3 ? 'ğŸ”¥ğŸ”¥' : 'ğŸ”¥';
  
  return `${streakEmoji} <b>INFORMACIÃ“N DE RACHA</b> ${streakEmoji}

ğŸ”¥ Racha actual: <b>${stats.streak} dÃ­as</b>
ğŸ… Mejor racha: <b>${stats.beststreak} dÃ­as</b>
ğŸ“… Ãšltima actividad: ${stats.lastActivity ? new Date(stats.lastActivity).toLocaleDateString() : 'Hoy'}

${getStreakMotivation(stats.streak)}`;
}

function formatHelpMessage(): string {
  return `ğŸ¤– <b>AYUDA - OPOSITIA BOT</b> ğŸ¤–

ğŸ“š <b>COMANDOS BÃSICOS:</b>
â€¢ <code>/help</code> - Ver esta ayuda
â€¢ <code>/stats</code> - Ver tus estadÃ­sticas

ğŸ† <b>SISTEMA DE TORNEOS:</b>
â€¢ <code>/torneo</code> - Ver y unirse a torneos disponibles
â€¢ <code>/torneos</code> - Lista completa de torneos
â€¢ <code>/torneo_unirse [nÃºmero]</code> - Unirse a un torneo especÃ­fico
â€¢ <code>/torneo_salir</code> - Salir del torneo actual
â€¢ <code>/torneo_historial</code> - Ver tu historial de torneos
â€¢ <code>/racha</code> - InformaciÃ³n de tu racha

ğŸ¯ <b>EXÃMENES OFICIALES:</b>
â€¢ <code>/examen2018</code> - Pregunta del examen 2018
â€¢ <code>/examen2024</code> - Pregunta del examen 2024
â€¢ <code>/examen2018stats</code> - EstadÃ­sticas del examen 2018
â€¢ <code>/examen2024stats</code> - EstadÃ­sticas del examen 2024

ğŸ† <b>RANKINGS ESPECÃFICOS:</b>
â€¢ <code>/ranking</code> - Ver el ranking general
â€¢ <code>/ranking_semanal</code> - Ranking de la semana actual  
â€¢ <code>/ranking_mensual</code> - Ranking del mes actual
â€¢ <code>/ranking_oficial2018</code> - Ranking del examen 2018
â€¢ <code>/ranking_oficial2024</code> - Ranking del examen 2024
â€¢ <code>/comparativa_examenes</code> - Comparar tu rendimiento

ğŸ® <b>SIMULACROS:</b>
â€¢ <code>/simulacro_oficial</code> - Selector de simulacros
â€¢ <code>/simulacro</code> - Simulacro examen 2018
â€¢ <code>/simulacro2024</code> - Simulacro examen 2024
â€¢ <code>/simulacro_continuar</code> - Continuar simulacro
â€¢ <code>/simulacro_abandonar</code> - Abandonar simulacro
â€¢ <code>/simulacro_historial</code> - Ver historial

âš”ï¸ <b>DUELOS:</b>
â€¢ <code>/duelo @usuario</code> - Retar a duelo
â€¢ <code>/duelos</code> - Ver tus duelos
â€¢ <code>/aceptar</code> - Aceptar duelo pendiente
â€¢ <code>/rechazar</code> - Rechazar duelo pendiente

ğŸ¯ <b>METAS Y LOGROS:</b>
â€¢ <code>/metas</code> - Ver tus objetivos
â€¢ <code>/logros</code> - Ver tus logros
â€¢ <code>/prediccion</code> - PredicciÃ³n de nivel

ğŸ“Š <b>ESTADÃSTICAS DE ESTUDIO:</b>
â€¢ <code>/miprogreso</code> - Ver preguntas graduadas
â€¢ <code>/estadisticas</code> - PrecisiÃ³n por materia
â€¢ <code>/graduadas</code> - Lista de preguntas graduadas
â€¢ <code>/reiniciar_graduacion</code> - Reset para repaso intensivo

ğŸ”” <b>CONFIGURACIÃ“N:</b>
â€¢ <code>/configurar_notificaciones</code> - Configurar alertas y recordatorios

ğŸ“§ <b>NOTIFICACIONES:</b>
â€¢ <code>/notificaciones</code> - Configurar notificaciones
â€¢ <code>/privadas</code> - Configurar mensajes privados

ğŸ’° <b>SUSCRIPCIONES PREMIUM:</b>
â€¢ <code>/planes</code> - Ver planes disponibles (BÃ¡sico â‚¬4.99, Premium â‚¬9.99)
â€¢ <code>/basico</code> - Suscribirse al plan BÃ¡sico
â€¢ <code>/premium</code> - Suscribirse al plan Premium
â€¢ <code>/mi_plan</code> - Ver tu suscripciÃ³n actual
â€¢ <code>/cancelar</code> - Cancelar suscripciÃ³n
â€¢ <code>/facturas</code> - Ver historial de pagos

ğŸ‡ªğŸ‡¸ <b>PAGO SEGURO ESPAÃ‘A:</b>
âœ… Telegram Payments (Visa, Mastercard)
âœ… PrÃ³ximamente: Bizum + Redsys
âœ… FacturaciÃ³n con IVA incluido

ğŸ’¡ <b>Â¡Responde las preguntas para ganar puntos y subir de nivel!</b>
ğŸ† Compite con otros usuarios en el ranking
ğŸ“ˆ MantÃ©n tu racha diaria para obtener bonificaciones
ğŸ’ <b>Â¡Hazte Premium para funciones avanzadas!</b>`;
}

function formatNotificationHelp(): string {
  return `ğŸ“¬ <b>CONFIGURAR NOTIFICACIONES</b> ğŸ“¬

ğŸ”” <b>Â¿CÃ“MO FUNCIONA?</b>
El bot puede enviarte notificaciones de dos formas:

âœ… <b>PRIVADAS (RECOMENDADO)</b>
â€¢ Mensajes detallados solo para ti
â€¢ Incluyen botones y comandos
â€¢ No molestan al grupo
â€¢ MÃ¡s informaciÃ³n y opciones

ğŸ“¢ <b>EN GRUPO (FALLBACK)</b>
â€¢ Mensajes muy breves en el grupo
â€¢ Solo cuando falla la privada
â€¢ MÃ¡ximo 50 caracteres

ğŸ”§ <b>CÃ“MO CONFIGURAR PRIVADAS:</b>
1. Haz clic aquÃ­: @OpoMelillaBot
2. EnvÃ­a <code>/start</code> al bot
3. Â¡Configurado! Ya recibirÃ¡s notificaciones privadas

ğŸ’¡ <b>Â¿QUÃ‰ NOTIFICACIONES RECIBES?</b>
ğŸ—¡ï¸ Duelos recibidos
ğŸ… Logros desbloqueados
ğŸ¯ Metas completadas
ğŸ“Š Actualizaciones importantes

âš¡ <b>Â¡Es sÃºper fÃ¡cil!</b> Solo tienes que hablar una vez con el bot privadamente.`;
}

function formatPrivateMessageHelp(): string {
  return `ğŸ’¬ <b>MENSAJES PRIVADOS CON EL BOT</b> ğŸ’¬

ğŸ¤” <b>Â¿NO SABES CÃ“MO HABLAR CON UN BOT PRIVADAMENTE?</b>
Â¡No te preocupes! Te explicamos paso a paso:

ğŸ“± <b>MÃ‰TODO 1: DESDE TELEGRAM</b>
1. Abre Telegram
2. Toca en el Ã­cono de bÃºsqueda ğŸ”
3. Escribe: <code>@OpoMelillaBot</code>
4. Selecciona el bot de la lista
5. EnvÃ­a <code>/start</code>
6. Â¡Listo! ğŸ‰

ğŸ”— <b>MÃ‰TODO 2: DESDE EL GRUPO</b>
1. Toca el nombre del bot: @OpoMelillaBot
2. Esto abrirÃ¡ su perfil
3. Toca "Enviar mensaje"
4. EnvÃ­a <code>/start</code>
5. Â¡Configurado! âœ…

ğŸ¯ <b>BENEFICIOS DE LOS MENSAJES PRIVADOS:</b>
â€¢ Notificaciones detalladas de duelos
â€¢ InformaciÃ³n completa de logros
â€¢ No spam en el grupo principal
â€¢ Comandos y botones interactivos
â€¢ ConfiguraciÃ³n personalizada

â“ <b>Â¿DUDAS?</b>
Â¡Es exactamente igual que chatear con un amigo, pero el amigo es un robot! ğŸ¤–

ğŸ’ª Una vez que lo pruebes, Â¡verÃ¡s que es sÃºper fÃ¡cil!`;
}

function getProgressMessage(stats: any): string {
  const nextLevelPoints = GamificationService.calculateLevel(stats.totalpoints + 1) > stats.level ? 
    getPointsForLevel(stats.level + 1) - stats.totalpoints : 0;
  
  if (nextLevelPoints > 0) {
    return `ğŸ¯ Te faltan ${nextLevelPoints} puntos para el siguiente nivel!`;
  }
  
  return 'ğŸŒŸ Â¡Has alcanzado un nivel alto! Â¡Sigue asÃ­!';
}

function getPointsForLevel(level: number): number {
  const levelThresholds = [0, 100, 300, 600, 1000, 1500, 2100, 2800, 3600, 4500, 5500];
  if (level <= 10) {
    return levelThresholds[level] || 5500 + (level - 10) * 1000;
  }
  return 5500 + (level - 10) * 1000;
}

function getStreakMotivation(streak: number): string {
  if (streak === 0) {
    return 'ğŸ’ª Â¡Empieza tu racha respondiendo una pregunta hoy!';
  } else if (streak < 3) {
    return 'ğŸ¯ Â¡Sigue asÃ­! Cada dÃ­a cuenta para tu racha.';
  } else if (streak < 7) {
    return 'ğŸ”¥ Â¡Excelente! EstÃ¡s construyendo una gran racha.';
  } else if (streak < 30) {
    return 'ğŸŒŸ Â¡IncreÃ­ble! Tu dedicaciÃ³n es admirable.';
  } else {
    return 'ğŸ‘‘ Â¡LEYENDA! Tu racha es Ã©pica. Â¡Eres imparable!';
  }
}

// FunciÃ³n para obtener logros del usuario
async function getUserAchievements(telegramUserId: string) {
  try {
    const userAchievements = await prisma.userachievement.findMany({
      where: {
        userid: telegramuserid
      },
      orderBy: {
        unlockedat: 'desc'
      }
    });
    
    return userAchievements;
  } catch (error) {
    console.error('Error obteniendo logros del usuario:', error);
    return [];
  }
}

// FunciÃ³n para formatear los logros del usuario
function formatUserAchievements(achievements: any[], userid: string): string {
  if (achievements.length === 0) {
    return `ğŸ† <b>TUS LOGROS</b> ğŸ†

âŒ AÃºn no has desbloqueado ningÃºn logro.

ğŸ’¡ <b>CÃ“MO OBTENER LOGROS:</b>
ğŸ¯ Responde preguntas para ganar puntos
ğŸ”¥ MantÃ©n rachas diarias 
âš¡ Responde rÃ¡pidamente
ğŸ¯ Mejora tu precisiÃ³n

Â¡Empieza respondiendo preguntas! ğŸš€`;
  }

  let message = `ğŸ† <b>TUS LOGROS</b> ğŸ†\n\n`;
  message += `ğŸ–ï¸ <b>Tienes ${achievements.length} logro${achievements.length === 1 ? '' : 's'} desbloqueado${achievements.length === 1 ? '' : 's'}:</b>\n\n`;
  
  achievements.forEach((userAchievement, index) => {
    const achievement = userAchievement.achievement;
    const rarityEmoji = getRarityEmoji(achievement.rarity);
    const date = new Date(userAchievement.unlockedat).toLocaleDateString();
    
    message += `${achievement.icon} <b>${achievement.name}</b> ${rarityEmoji}\n`;
    message += `   ${achievement.description}\n`;
    message += `   ğŸ’° +${achievement.points} pts | ğŸ“… ${date}\n\n`;
  });
  
  // Calcular puntos totales de logros
  const totalAchievementPoints = achievements.reduce((sum, ua) => sum + ua.achievement.points, 0);
  message += `ğŸ’ <b>Puntos totales por logros:</b> ${totalAchievementPoints}\n\n`;
  
  message += `ğŸ¯ <b>Â¡Sigue jugando para desbloquear mÃ¡s logros!</b>`;
  
  return message;
}

// FunciÃ³n para obtener emoji de rareza
function getRarityEmoji(rarity: string): string {
  switch (rarity.toLowerCase()) {
    case 'common': return 'âšª';
    case 'uncommon': return 'ğŸŸ¢';
    case 'rare': return 'ğŸ”µ';
    case 'epic': return 'ğŸŸ£';
    case 'legendary': return 'ğŸŸ¡';
    default: return 'â­';
  }
}

// FunciÃ³n para formatear predicciÃ³n de nivel
function formatLevelPrediction(stats: any): string {
  const currentLevel = stats.level;
  const currentPoints = stats.totalpoints;
  const nextLevel = currentLevel + 1;
  
  // Calcular puntos necesarios para el siguiente nivel
  const pointsForNextLevel = getPointsForLevel(nextLevel);
  const pointsNeeded = pointsForNextLevel - currentPoints;
  
  // Calcular puntos para el nivel despuÃ©s del siguiente
  const levelAfterNext = nextLevel + 1;
  const pointsForLevelAfterNext = getPointsForLevel(levelAfterNext);
  const pointsNeededForLevelAfterNext = pointsForLevelAfterNext - currentPoints;
  
  // Calcular progreso actual
  const pointsForCurrentLevel = currentLevel === 1 ? 0 : getPointsForLevel(currentLevel);
  const progressInCurrentLevel = currentPoints - pointsForCurrentLevel;
  const totalPointsForNextLevel = pointsForNextLevel - pointsForCurrentLevel;
  const progressPercentage = Math.max(0, Math.min(100, Math.round((progressInCurrentLevel / totalPointsForNextLevel) * 100)));
  
  // Calcular preguntas necesarias (promedio de 15 puntos por pregunta correcta)
  const avgPointsPerQuestion = 15;
  const questionsNeeded = Math.max(1, Math.ceil(pointsNeeded / avgPointsPerQuestion));
  
  // EstimaciÃ³n de tiempo basada en actividad (asumiendo 1 pregunta por dÃ­a)
  const daysEstimated = questionsNeeded;
  
  // Calcular barra de progreso de forma segura
  const progressBars = Math.max(0, Math.min(10, Math.floor(progressPercentage / 10)));
  const emptyBars = Math.max(0, 10 - progressBars);
  
  return `ğŸ”® <b>PREDICCIÃ“N DE NIVEL</b> ğŸ”®

${getLevelEmoji(currentLevel)} <b>Nivel actual:</b> ${currentLevel}
ğŸ“Š <b>Puntos actuales:</b> ${currentPoints}

ğŸ¯ <b>PRÃ“XIMO NIVEL (${nextLevel}):</b>
â€¢ ğŸ¯ Puntos necesarios: <b>${Math.max(0, pointsNeeded)}</b>
â€¢ ğŸ“ Preguntas estimadas: <b>~${questionsNeeded}</b>
â€¢ â° Tiempo estimado: <b>~${daysEstimated} dÃ­as</b>
â€¢ ğŸ“ˆ Progreso: <b>${progressPercentage}%</b>

${'â–ˆ'.repeat(progressBars)}${'â–‘'.repeat(emptyBars)} ${progressPercentage}%

ğŸš€ <b>NIVEL ${levelAfterNext}:</b>
â€¢ ğŸ¯ Puntos necesarios: <b>${Math.max(0, pointsNeededForLevelAfterNext)}</b>
â€¢ ğŸ“ Preguntas estimadas: <b>~${Math.ceil(Math.max(0, pointsNeededForLevelAfterNext) / avgPointsPerQuestion)}</b>

ğŸ’¡ <b>CONSEJOS PARA SUBIR MÃS RÃPIDO:</b>
â€¢ âš¡ Responde rÃ¡pido (+5-10 pts extra)
â€¢ ğŸ”¥ MantÃ©n tu racha diaria
â€¢ ğŸ¯ Mejora tu precisiÃ³n
â€¢ ğŸ† Desbloquea logros (+pts bonus)

${getLevelPredictionMotivation(Math.max(0, pointsNeeded), questionsNeeded)}`;
}

// FunciÃ³n para obtener mensaje motivacional de predicciÃ³n
function getLevelPredictionMotivation(pointsNeeded: number, questionsNeeded: number): string {
  if (pointsNeeded <= 50) {
    return 'ğŸ”¥ Â¡EstÃ¡s sÃºper cerca! Â¡Solo unas pocas preguntas mÃ¡s!';
  } else if (pointsNeeded <= 100) {
    return 'ğŸ’ª Â¡Casi ahÃ­! Con un poco de esfuerzo llegarÃ¡s pronto.';
  } else if (questionsNeeded <= 10) {
    return 'ğŸ¯ Â¡El siguiente nivel estÃ¡ al alcance! Â¡Sigue asÃ­!';
  } else if (questionsNeeded <= 20) {
    return 'ğŸŒŸ Con constancia, pronto subirÃ¡s de nivel. Â¡TÃº puedes!';
  } else {
    return 'ğŸš€ El camino es largo pero cada pregunta te acerca. Â¡No te rindas!';
  }
}

// FunciÃ³n para obtener metas del usuario
async function getUserGoals(telegramUserId: string) {
  try {
    const userGoals = await prisma.usergoal.findMany({
      where: {
        userid: telegramuserid
      },
      orderBy: [
        { completed: 'asc' },
        { deadline: 'asc' }
      ]
    });
    
    return userGoals;
  } catch (error) {
    console.error('Error obteniendo metas del usuario:', error);
    return [];
  }
}

// FunciÃ³n para formatear las metas del usuario
function formatUserGoals(goals: any[], userid: string): string {
  const activeGoals = goals.filter(g => !g.completed);
  const completedGoals = goals.filter(g => g.completed);
  
  if (goals.length === 0) {
    return `ğŸ¯ <b>TUS METAS</b> ğŸ¯

âŒ No tienes metas establecidas aÃºn.

ğŸ’¡ <b>Â¿QUÃ‰ SON LAS METAS?</b>
Las metas te ayudan a enfocarte en objetivos especÃ­ficos y ganar recompensas extra.

ğŸ¯ <b>EJEMPLOS DE METAS:</b>
â€¢ ğŸ“Š Ganar 200 puntos esta semana
â€¢ ğŸ”¥ Mantener racha de 5 dÃ­as
â€¢ ğŸ“ Responder 20 preguntas este mes
â€¢ ğŸ¯ Alcanzar 95% de precisiÃ³n

ğŸš€ <b>PRÃ“XIMAMENTE:</b>
Â¡PodrÃ¡s crear tus propias metas personalizadas!

Â¡Mientras tanto, sigue respondiendo preguntas! ğŸ’ª`;
  }

  let message = `ğŸ¯ <b>TUS METAS</b> ğŸ¯\n\n`;

  // Metas activas
  if (activeGoals.length > 0) {
    message += `ğŸ”„ <b>METAS ACTIVAS (${activeGoals.length}):</b>\n\n`;
    
    activeGoals.forEach((goal, index) => {
      const progressPercentage = Math.round((goal.current / goal.target) * 100);
      const daysLeft = Math.ceil((new Date(goal.deadline).getTime() - Date.now()) / (1000 * 60 * 60 * 24));
      const isUrgent = daysLeft <= 1;
      const typeEmoji = getGoalTypeEmoji(goal.type);
      
      // Calcular barra de progreso de forma segura
      const progressBars = Math.max(0, Math.min(10, Math.floor(progressPercentage / 10)));
      const emptyBars = Math.max(0, 10 - progressBars);
      
      message += `${typeEmoji} <b>${getGoalTypeName(goal.type)}</b>\n`;
      message += `ğŸ“ˆ Progreso: ${goal.current}/${goal.target} (${progressPercentage}%)\n`;
      message += `${'â–ˆ'.repeat(progressBars)}${'â–‘'.repeat(emptyBars)} ${progressPercentage}%\n`;
      message += `ğŸ’° Recompensa: +${goal.reward} pts\n`;
      message += `â° ${isUrgent ? 'ğŸš¨' : ''} ${daysLeft > 0 ? `${daysLeft} dÃ­a${daysLeft === 1 ? '' : 's'} restante${daysLeft === 1 ? '' : 's'}` : 'VENCIDA'}\n\n`;
    });
  }

  // Metas completadas (Ãºltimas 3)
  if (completedGoals.length > 0) {
    const recentCompleted = completedGoals.slice(-3);
    message += `âœ… <b>METAS COMPLETADAS RECIENTES:</b>\n\n`;
    
    recentCompleted.forEach((goal, index) => {
      const typeEmoji = getGoalTypeEmoji(goal.type);
      const completedDate = new Date(goal.deadline).toLocaleDateString();
      
      message += `${typeEmoji} <b>${getGoalTypeName(goal.type)}</b> âœ…\n`;
      message += `ğŸ† ${goal.current}/${goal.target} - ${completedDate}\n`;
      message += `ğŸ’° +${goal.reward} pts obtenidos\n\n`;
    });
    
    if (completedGoals.length > 3) {
      message += `<i>...y ${completedGoals.length - 3} mÃ¡s completadas</i>\n\n`;
    }
  }

  // EstadÃ­sticas generales
  const totalRewardsEarned = completedGoals.reduce((sum, goal) => sum + goal.reward, 0);
  message += `ğŸ“Š <b>ESTADÃSTICAS DE METAS:</b>\n`;
  message += `ğŸ† Completadas: ${completedGoals.length}\n`;
  message += `ğŸ”„ Activas: ${activeGoals.length}\n`;
  message += `ğŸ’ Puntos ganados: ${totalRewardsEarned}\n\n`;

  message += `ğŸš€ <b>Â¡Sigue trabajando en tus metas!</b>`;
  
  return message;
}

// FunciÃ³n para obtener emoji del tipo de meta
function getGoalTypeEmoji(type: string): string {
  switch (type.toLowerCase()) {
    case 'daily': return 'ğŸ“…';
    case 'weekly': return 'ğŸ“ˆ';
    case 'monthly': return 'ğŸ—“ï¸';
    case 'custom': return 'ğŸ¯';
    default: return 'â­';
  }
}

// FunciÃ³n para obtener nombre del tipo de meta
function getGoalTypeName(type: string): string {
  switch (type.toLowerCase()) {
    case 'daily': return 'Meta Diaria';
    case 'weekly': return 'Meta Semanal';
    case 'monthly': return 'Meta Mensual';
    case 'custom': return 'Meta Personalizada';
    default: return 'Meta';
  }
}

// Nueva funciÃ³n para manejar respuestas de polls
async function handlePollAnswer(pollAnswer: any) {
  try {
    console.log('ğŸ—³ï¸  ============ POLL ANSWER RECIBIDO ============');
    console.log('ğŸ“¥ Datos completos del poll_answer:', JSON.stringify(pollAnswer, null, 2));
    console.log('ğŸ‘¤ Usuario que responde:', {
      telegramId: pollAnswer.user.id,
      username: pollAnswer.user.username || 'SIN_USERNAME',
      firstName: pollAnswer.user.first_name || 'SIN_NOMBRE',
      lastName: pollAnswer.user.last_name || 'SIN_APELLIDO',
      isBot: pollAnswer.user.is_bot
    });
    console.log('ğŸ—³ï¸  Poll details:', {
      pollid: pollAnswer.poll_id,
      selectedOptions: pollAnswer.option_ids,
      optionCount: pollAnswer.option_ids.length
    });

    const user = pollAnswer.user;
    const pollid = pollAnswer.poll_id;
    const selectedOptionIds = pollAnswer.option_ids;
    
    // Un usuario solo puede seleccionar una opciÃ³n en un quiz
    if (selectedOptionIds.length !== 1) {
      console.log('âš ï¸  Poll answer ignorado: mÃºltiples opciones seleccionadas');
      console.log('âŒ RAZÃ“N: Usuario seleccionÃ³', selectedOptionIds.length, 'opciones');
      return NextResponse.json({ ok: true, message: 'Poll answer ignorado' });
    }
    
    const selectedOptionId = selectedOptionIds[0];
    console.log('âœ… OpciÃ³n seleccionada vÃ¡lida:', selectedOptionId);
    
    // ğŸ”¥ NUEVA FUNCIONALIDAD: VERIFICAR SI ES UNA RESPUESTA DE DUELO
    console.log('ğŸ—¡ï¸  ======== VERIFICANDO SI ES RESPUESTA DE DUELO ========');
    
    // Intentar procesar como respuesta de duelo PRIMERO
    try {
      const duelProcessed = await DuelManager.processDuelResponse(
        pollid,
        user.id.toString(),  // âœ… CORREGIDO: user.id ES el telegramUserId de Telegram
        selectedOptionId,
        undefined // Tiempo de respuesta se calcula internamente
      );
      
      if (duelProcessed) {
        console.log('âš”ï¸  RESPUESTA DE DUELO PROCESADA EXITOSAMENTE');
        
        return NextResponse.json({ 
          ok: true, 
          type: 'duel_answer_processed',
          processed: true,
          duelResponse: true,
          debug: {
            pollid,
            userid: user.id,
            username: user.username,
            selectedoption: selectedOptionId,
            isDuelResponse: true
          }
        });
      } else {
        console.log('â„¹ï¸  No es respuesta de duelo, continuando con procesamiento normal...');
      }
      
    } catch (duelError) {
      console.log('âš ï¸  Error procesando como duelo (continuando con proceso normal):', duelError);
    }
    
    // ğŸ¯ NUEVA FUNCIONALIDAD: VERIFICAR SI ES UNA RESPUESTA DE SESIÃ“N DE ESTUDIO
    console.log('ğŸ¯ ======== VERIFICANDO SI ES RESPUESTA DE SESIÃ“N DE ESTUDIO ========');
    
    // Verificar si existe un mapping de sesiÃ³n de estudio (primero en memoria, luego en BD)
    let studyMapping: { questionid: string; subject: string; timestamp: number } | null = null;
    let isStudyResponse = false;
    
    // 1. Buscar en memoria (legacy)
    if (global.studyPollMappings && global.studyPollMappings.has(pollid)) {
      studyMapping = global.studyPollMappings.get(pollid);
      isStudyResponse = true;
      console.log('ğŸ¯ Â¡RESPUESTA DE SESIÃ“N DE ESTUDIO DETECTADA EN MEMORIA!', studyMapping);
    } 
    // 2. Buscar en base de datos (nuevo sistema persistente)
    else {
      try {
        const dbMapping = await prisma.telegrampollmapping.findUnique({
          where: { pollid: pollid }
        });
        
        if (dbMapping) {
          studyMapping = {
            questionid: dbMapping.questionid,
            subject: dbMapping.subject,
            timestamp: dbMapping.createdat.getTime() // Convertir a timestamp para compatibilidad
          };
          isStudyResponse = true;
          console.log('ğŸ¯ Â¡RESPUESTA DE SESIÃ“N DE ESTUDIO DETECTADA EN BD!', studyMapping);
        }
      } catch (dbError) {
        console.log('âš ï¸ Error buscando mapping en BD:', dbError);
      }
    }
    
    if (isStudyResponse && studyMapping) {
      
      try {
        // Calcular tiempo de respuesta (desde cuando se enviÃ³ el poll)
        const responseTime = Math.floor((Date.now() - studyMapping!.timestamp) / 1000);
        
        // Procesar respuesta de estudio usando el servicio
        console.log('ğŸ¯ Procesando respuesta de sesiÃ³n de estudio...');
        
        // Usar el mÃ©todo processPollAnswer del StudySessionService
        await studySessionService.processPollAnswer(
          pollid,
          user.id.toString(),
          selectedOptionId // Solo una opciÃ³n seleccionada (Telegram quiz)
        );
        
        // Limpiar mapping despuÃ©s del procesamiento
        if (global.studyPollMappings && global.studyPollMappings.has(pollid)) {
          global.studyPollMappings.delete(pollid);
        } else {
          // Limpiar de la base de datos
          try {
            await prisma.telegrampollmapping.delete({
              where: { pollid: pollid }
            });
            console.log('ğŸ§¹ Mapping eliminado de la base de datos');
          } catch (deleteError) {
            console.log('âš ï¸ Error eliminando mapping de BD:', deleteError);
          }
        }
        
        console.log('âœ… Respuesta de estudio procesada exitosamente');
        
        return NextResponse.json({ 
          ok: true, 
          type: 'study_answer_processed',
          processed: true,
          debug: {
            pollid,
            userid: user.id,
            username: user.username,
            selectedoption: selectedOptionId,
            isStudyResponse: true,
            responseTime
          }
        });
        
      } catch (studyError) {
        console.error('âŒ Error procesando sesiÃ³n de estudio:', studyError);
        // Continuar con procesamiento normal si falla
      }
    }
    
    // ğŸ¯ NUEVA FUNCIONALIDAD: VERIFICAR SI ES UNA RESPUESTA DE SIMULACRO
    console.log('ğŸ¯ ======== VERIFICANDO SI ES RESPUESTA DE SIMULACRO ========');
    console.log('ğŸ¯ DEBUG - Poll ID recibido:', pollid);
    console.log('ğŸ¯ DEBUG - Usuario que responde:', user.id.toString());
    
    // Buscar si es una pregunta de simulacro
    const simulacroQuestionData = await findQuestionByPollId(pollid);
    console.log('ğŸ¯ DEBUG - Datos encontrados para poll:', simulacroQuestionData);
    
    // Detectar simulacros 2018, 2024 y MILITARES PREMIUM
    const isSimulacro2018 = simulacroQuestionData && simulacroQuestionData.sourcemodel === 'simulacro';
    const isSimulacro2024 = simulacroQuestionData && simulacroQuestionData.sourcemodel === 'simulacro2024';
    const isSimulacroMilitar = simulacroQuestionData && (
      simulacroQuestionData.sourcemodel === 'simulacro_premium_et' ||
      simulacroQuestionData.sourcemodel === 'simulacro_premium_aire' ||
      simulacroQuestionData.sourcemodel === 'simulacro_premium_armada'
    );
    
    if (isSimulacro2018 || isSimulacro2024 || isSimulacroMilitar) {
      const simulacroType = isSimulacroMilitar ? 'MILITAR' : (isSimulacro2024 ? '2024' : '2018');
      console.log(`ğŸ¯ Â¡RESPUESTA DE SIMULACRO ${simulacroType} DETECTADA!`);
      console.log('ğŸ“Š Datos de la pregunta de simulacro:', {
        questionid: simulacroQuestionData.questionid,
        sourcemodel: simulacroQuestionData.sourcemodel,
        pollid: pollid,
        type: simulacroType
      });
      
      try {
        if (isSimulacro2024) {
          // Procesar simulacro 2024 de manera simple
          console.log('ğŸ¯ Procesando simulacro 2024...');
          
          // Buscar usuario
          const userFound = await prisma.telegramuser.findUnique({
            where: { telegramUserId: user.id.toString() }
          });
          
          if (!userFound) {
            console.error('âŒ Usuario no encontrado');
            throw new Error('Usuario no encontrado');
          }
          
          // Buscar simulacro activo del usuario
          const activeSimulacro = await prisma.simulacro.findFirst({
            where: {
              userid: userFound.id,
              status: 'in_progress'
            }
          });
          
          if (!activeSimulacro) {
            console.error('âŒ No se encontrÃ³ simulacro activo');
            throw new Error('Simulacro activo no encontrado');
          }
          
          // Buscar la pregunta del examen 2024
          const question = await (prisma as any).examenOficial2024.findUnique({
            where: { id: simulacroQuestionData.questionid }
          });
          
          if (!question) {
            console.error('âŒ Pregunta del examen 2024 no encontrada');
            throw new Error('Pregunta no encontrada');
          }
          
          // Verificar si es correcta
          const isCorrect = selectedOptionId === question.correctanswerindex;
          const responseTime = Math.floor((Date.now() - simulacroQuestionData.createdat.getTime()) / 1000);
          
          // Buscar la respuesta del simulacro
          const simulacroResponse = await prisma.simulacroresponse.findFirst({
            where: {
              simulacroid: activeSimulacro.id,
              questionid: simulacroQuestionData.questionid
            }
          });
          
          if (simulacroResponse) {
            // Actualizar la respuesta
            await prisma.simulacroresponse.update({
              where: { id: simulacroResponse.id },
              data: {
                selectedoption: selectedOptionId,
                iscorrect: isCorrect,
                responsetime: responseTime,
                answeredat: new Date()
              }
            });
          }
          
          // Calcular tiempo restante
          const timeElapsed = Math.floor((Date.now() - activeSimulacro.startedat.getTime()) / 1000);
          const timeRemaining = Math.max(0, 10800 - timeElapsed);
          const hoursRemaining = Math.floor(timeRemaining / 3600);
          const minutesRemaining = Math.floor((timeRemaining % 3600) / 60);
          
          // Buscar siguiente pregunta sin responder
          const nextResponse = await prisma.simulacroresponse.findFirst({
            where: {
              simulacroid: activeSimulacro.id,
              answeredat: null
            },
            orderBy: { questionnumber: 'asc' }
          });
          
          const feedbackMessage = isCorrect ? 'âœ… Â¡Correcto!' : 'âŒ Incorrecto';
          let responseMessage = `ğŸ¯ <b>SIMULACRO 2024 - Pregunta ${question.questionnumber}/100</b>\n\n${feedbackMessage}`;
          
          if (nextResponse) {
            // Hay mÃ¡s preguntas
            const nextQuestion = await (prisma as any).examenOficial2024.findUnique({
              where: { id: nextResponse.questionid }
            });
            
            if (nextQuestion) {
              responseMessage += '\n\nâ³ Enviando siguiente pregunta...';
              await sendTelegramMessage(userFound.telegramuserid, responseMessage);
              
              // Enviar la siguiente pregunta
              const header = `ğŸ¯ SIMULACRO EXAMEN 2024 - Pregunta ${nextQuestion.questionnumber}/100\nâ° Tiempo restante: ${hoursRemaining}h ${minutesRemaining}m\n\n`;
              const pollQuestion = truncatePollQuestion(header, nextQuestion.question);
              
              const nextPollSent = await sendTelegramPoll(
                userFound.telegramuserid,
                pollQuestion,
                nextQuestion.options,
                nextQuestion.correctanswerindex,
                nextQuestion.id,
                'simulacro2024'
              );
              
              if (nextPollSent) {
                console.log(`âœ… Siguiente pregunta 2024 enviada: ${nextQuestion.questionnumber}/100`);
              } else {
                console.error('âŒ Error enviando siguiente pregunta del simulacro 2024');
                await sendTelegramMessage(userFound.telegramuserid, 'âŒ Error enviando siguiente pregunta. Usa /simulacro_continuar');
              }
            }
          } else {
            // Simulacro completado
            responseMessage += '\n\nğŸ‰ <b>Â¡SIMULACRO 2024 COMPLETADO!</b>\n\nğŸ“‹ <code>/simulacro_historial</code> - Ver resultados';
            
            // Marcar simulacro como completado
            await prisma.simulacro.update({
              where: { id: activeSimulacro.id },
              data: {
                status: 'completed',
                completedat: new Date()
              }
            });
            
            await sendTelegramMessage(userFound.telegramuserid, responseMessage);
            console.log('ğŸ‰ Simulacro 2024 completado');
          }
          
        } else if (isSimulacroMilitar) {
          // =========================================
          // ğŸ–ï¸ PROCESAR SIMULACRO PERMANENCIA PREMIUM
          // =========================================
          console.log('ğŸ–ï¸ Procesando simulacro militar premium...');
          
          // Buscar usuario
          const userFound = await prisma.telegramuser.findUnique({
            where: { telegramUserId: user.id.toString() }
          });
          
          if (!userFound) {
            console.error('âŒ Usuario no encontrado');
            throw new Error('Usuario no encontrado');
          }
          
          // Buscar simulacro militar activo del usuario
          const activeSimulacro = await prisma.simulacro.findFirst({
            where: {
              userid: userFound.id,
              status: 'in_progress',
              examtype: {
                in: ['simulacro_premium_et', 'simulacro_premium_aire', 'simulacro_premium_armada']
              }
            }
          });
          
          if (!activeSimulacro) {
            console.error('âŒ No se encontrÃ³ simulacro militar activo');
            throw new Error('Simulacro militar activo no encontrado');
          }
          
          console.log('âœ… Simulacro militar activo encontrado:', {
            simulacroid: activeSimulacro.id,
            examtype: activeSimulacro.examtype,
            startedAt: activeSimulacro.startedat
          });
          
          // Verificar si es correcta (usando metadata del simulacro)
          const isCorrect = selectedOptionId === simulacroQuestionData.correctanswerindex;
          const responseTime = Math.floor((Date.now() - simulacroQuestionData.createdat.getTime()) / 1000);
          
          // Buscar la respuesta del simulacro
          const simulacroResponse = await prisma.simulacroresponse.findFirst({
            where: {
              simulacroid: activeSimulacro.id,
              questionid: simulacroQuestionData.questionid
            }
          });
          
          if (simulacroResponse) {
            // Actualizar la respuesta
            await prisma.simulacroresponse.update({
              where: { id: simulacroResponse.id },
              data: {
                selectedoption: selectedOptionId,
                iscorrect: isCorrect,
                responsetime: responseTime,
                answeredat: new Date()
              }
            });
          }
          
          // Verificar cuÃ¡ntas preguntas se han respondido
          const responsesAnswered = await prisma.simulacroresponse.count({
            where: {
              simulacroid: activeSimulacro.id,
              answeredat: { not: null }
            }
          });
          
          console.log('ğŸ“Š Estado del simulacro militar:', {
            responsesAnswered,
            totalQuestions: 100,
            isCompleted: responsesAnswered >= 100
          });
          
          // Calcular tiempo transcurrido
          const timeElapsed = Math.floor((Date.now() - activeSimulacro.startedat.getTime()) / 1000);
          const timeRemaining = Math.max(0, (105 * 60) - timeElapsed); // 105 minutos
          const hoursRemaining = Math.floor(timeRemaining / 3600);
          const minutesRemaining = Math.floor((timeRemaining % 3600) / 60);
          
          const feedbackMessage = isCorrect ? 'âœ… Â¡Correcto!' : 'âŒ Incorrecto';
          const currentQuestionNumber = responsesAnswered;
          
          if (responsesAnswered >= 100) {
            // =========================================
            // ğŸ† SIMULACRO PERMANENCIA COMPLETADO
            // =========================================
            console.log('ğŸ† Â¡SIMULACRO PERMANENCIA COMPLETADO!');
            
            // Procesar finalizaciÃ³n con sistema especializado
            const { MilitarySimulationCompletion } = await import('../../../../services/militarySimulationCompletion');
            
            const completionResult = await MilitarySimulationCompletion.processCompletion(activeSimulacro.id);
            
            if (completionResult) {
              // Generar mensaje de finalizaciÃ³n militar especializado
              const completionMessage = MilitarySimulationCompletion.generateCompletionMessage(completionResult);
              
              // Enviar mensaje de feedback seguido del resultado final
              const briefFeedback = `ğŸ–ï¸ <b>SIMULACRO PERMANENCIA - Pregunta 100/100</b>\n\n${feedbackMessage}\n\nâ³ Procesando resultados finales...`;
              await sendTelegramMessage(userFound.telegramuserid, briefFeedback);
              
              // Esperar un momento antes de enviar el resultado completo
              setTimeout(async () => {
                await sendTelegramMessage(userFound.telegramuserid, completionMessage);
              }, 2000);
              
              console.log('ğŸ‰ Simulacro permanencia completado y mensaje enviado');
            } else {
              // Fallback si falla el procesamiento especializado
              const fallbackMessage = `ğŸ–ï¸ <b>SIMULACRO PERMANENCIA COMPLETADO</b>\n\n${feedbackMessage}\n\nğŸ‰ Â¡Has completado las 100 preguntas!\n\nğŸ“‹ /simulacros_premium - Ver informaciÃ³n de simulacros`;
              await sendTelegramMessage(userFound.telegramuserid, fallbackMessage);
              
              console.log('âš ï¸ Simulacro permanencia completado con mensaje fallback');
            }
            
          } else {
            // =========================================
            // ğŸ“ CONTINUAR CON SIGUIENTE PREGUNTA
            // =========================================
            
            // Buscar siguiente pregunta sin responder
            const nextResponse = await prisma.simulacroresponse.findFirst({
              where: {
                simulacroid: activeSimulacro.id,
                answeredat: null
              },
              orderBy: { questionnumber: 'asc' }
            });
            
            if (nextResponse) {
              // Hay mÃ¡s preguntas - continuar simulacro
              const nextQuestionNumber = responsesAnswered + 1;
              
              let responseMessage = `ğŸ–ï¸ <b>SIMULACRO PERMANENCIA - Pregunta ${currentQuestionNumber}/100</b>\n\n${feedbackMessage}`;
              responseMessage += '\n\nâ³ Enviando siguiente pregunta...';
              
              await sendTelegramMessage(userFound.telegramuserid, responseMessage);
              
              // AquÃ­ irÃ­a la lÃ³gica para enviar la siguiente pregunta militar
              // Por simplicidad, enviaremos un mensaje indicando que use /simulacro_continuar
              setTimeout(async () => {
                const nextMessage = `ğŸ–ï¸ <b>PREGUNTA ${nextQuestionNumber}/100</b>\nâ° Tiempo restante: ${hoursRemaining}h ${minutesRemaining}m\n\nğŸ”„ Usa /simulacro_continuar para continuar`;
                await sendTelegramMessage(userFound.telegramuserid, nextMessage);
              }, 1000);
              
              console.log(`âœ… Procesado simulacro militar: ${currentQuestionNumber}/100`);
              
            } else {
              // No hay mÃ¡s preguntas pero no llegamos a 100 - estado inesperado
              console.error('âš ï¸ Estado inesperado: No hay mÃ¡s preguntas pero simulacro no completado');
              const errorMessage = `ğŸ–ï¸ <b>SIMULACRO PERMANENCIA - Estado inesperado</b>\n\n${feedbackMessage}\n\nâš ï¸ Error en el simulacro. Usa /simulacros_premium`;
              await sendTelegramMessage(userFound.telegramuserid, errorMessage);
            }
          }
          
        } else {
          // Procesar simulacro 2018 (cÃ³digo existente)
          // Extraer simulacroId y questionNumber del questionId
          // Formato esperado: "simulacro-{simulacroId}-{questionNumber}"
          const match = simulacroQuestionData.questionid.match(/^simulacro-([a-f0-9-]+)-(\d+)$/);
          
          if (!match) {
            console.error('âŒ Formato de questionId de simulacro invÃ¡lido:', simulacroQuestionData.questionid);
            throw new Error('Formato de questionId invÃ¡lido para simulacro');
          }
          
          const simulacroId = match[1];
          const questionNumber = parseInt(match[2]);
          
          console.log('ğŸ¯ ExtraÃ­dos datos del simulacro 2018:', {
            simulacroId,
            questionNumber,
            selectedoption: selectedOptionId
          });
          
          // Verificar que el usuario tiene este simulacro activo
          const activeSimulacro = await prisma.simulacro.findFirst({
            where: {
              id: simulacroId,
              status: 'in_progress',
              userid: user.id.toString()
            }
          });
          
          if (!activeSimulacro) {
            console.error('âŒ No se encontrÃ³ simulacro activo para este usuario');
            throw new Error('Simulacro no encontrado o no activo');
          }
          
          console.log('âœ… Simulacro activo verificado');
          
          // Procesar la respuesta del simulacro
          const { SimulacroService } = await import('../../../../services/simulacroService');
          
          const responseTime = Math.floor((Date.now() - simulacroQuestionData.createdat.getTime()) / 1000);
          
          console.log('ğŸ”„ Procesando respuesta de simulacro...');
          const result = await SimulacroService.processAnswer(
            simulacroId,
            questionNumber,
            selectedOptionId,
            responseTime
          );
          
          console.log('âœ… Respuesta de simulacro procesada:', {
            iscorrect: result.isCorrect,
            isCompleted: result.isCompleted,
            hasNextQuestion: !!result.nextQuestion
          });
          
          // Enviar mensaje de feedback al usuario
          const feedbackMessage = result.isCorrect ? 
            'âœ… Â¡Correcto!' : 
            'âŒ Incorrecto';
          
          let responseMessage = `ğŸ¯ <b>SIMULACRO - Pregunta ${questionNumber}/100</b>\n\n${feedbackMessage}`;
          
          if (result.isCompleted) {
            // Simulacro completado
            responseMessage += '\n\nğŸ‰ <b>Â¡SIMULACRO COMPLETADO!</b>\n\nğŸ“‹ <code>/simulacro_historial</code> - Ver resultados';
            
            await sendTelegramMessage(user.id, responseMessage);
            
            console.log('ğŸ‰ Simulacro completado, mensaje enviado');
          } else if (result.nextQuestion) {
            // Enviar siguiente pregunta
            responseMessage += '\n\nâ³ Enviando siguiente pregunta...';
            
            await sendTelegramMessage(user.id, responseMessage);
            
            // Enviar la siguiente pregunta
            const timeElapsed = Math.floor((Date.now() - activeSimulacro.startedat.getTime()) / 1000);
            const timeRemaining = Math.max(0, 10800 - timeElapsed);
            const hoursRemaining = Math.floor(timeRemaining / 3600);
            const minutesRemaining = Math.floor((timeRemaining % 3600) / 60);
            
            const header = `ğŸ¯ SIMULACRO ${result.nextQuestion.questionnumber}/100 â±ï¸${hoursRemaining}h${minutesRemaining}m\n\n`;
            const pollQuestion = truncatePollQuestion(header, result.nextQuestion.question);
            
            const nextPollSent = await sendTelegramPoll(
              user.id,
              pollQuestion,
              result.nextQuestion.options,
              result.nextQuestion.correctAnswerIndex,
              `simulacro-${simulacroId}-${result.nextQuestion.questionNumber}`,
              'simulacro'
            );
            
            if (nextPollSent) {
              console.log(`âœ… Siguiente pregunta enviada: ${result.nextQuestion.questionNumber}/100`);
            } else {
              console.error('âŒ Error enviando siguiente pregunta del simulacro');
              await sendTelegramMessage(user.id, 'âŒ Error enviando siguiente pregunta. Usa /simulacro_continuar');
            }
          } else {
            // Caso inesperado: ni completado ni hay siguiente pregunta
            console.error('âš ï¸ CASO INESPERADO: Simulacro no estÃ¡ completado pero no hay siguiente pregunta');
            responseMessage += '\n\nâš ï¸ Estado del simulacro inesperado. Usa <code>/simulacro_continuar</code>';
            await sendTelegramMessage(user.id, responseMessage);
          }
        }
      } catch (simulacroError) {
        console.error('âŒ Error procesando respuesta de simulacro:', simulacroError);
        
        // Enviar mensaje de error al usuario
        await sendTelegramMessage(user.id, 
          'âŒ <b>Error procesando respuesta de simulacro</b>\n\nUsa <code>/simulacro_continuar</code> para continuar.'
        );
        
        return NextResponse.json({ 
          ok: false, 
          error: 'Error procesando respuesta de simulacro',
          details: simulacroError instanceof Error ? simulacroError.message : 'Unknown error'
        }, { status: 500 });
      }
    }
    
    // Si no es duelo ni simulacro, continuar con procesamiento normal de pregunta regular
    console.log('ğŸ“š ======== PROCESANDO COMO PREGUNTA REGULAR ========');
    
    // Buscar la pregunta relacionada con este poll
    console.log('ğŸ” Buscando informaciÃ³n de la pregunta...');
    const questionData = await findQuestionByPollId(pollid);
    
    if (!questionData) {
      console.log('âŒ ERROR CRÃTICO: No se encontrÃ³ pregunta para poll ID:', pollid);
      console.log('ğŸ” Este puede ser el problema principal');
      return NextResponse.json({ ok: true, message: 'Pregunta no encontrada' });
    }
    
    console.log('âœ… Pregunta encontrada:', {
      questionid: questionData.questionid,
      correctanswerindex: questionData.correctanswerindex,
      createdat: questionData.createdat,
      chatid: questionData.chatid,
      sourcemodel: questionData.sourcemodel
    });
    
    // Determinar si la respuesta es correcta
    const isCorrect = selectedOptionId === questionData.correctanswerindex;
    
    console.log('ğŸ“Š Evaluando respuesta:', {
      questionid: questionData.questionid,
      selectedoption: selectedOptionId,
      correctOption: questionData.correctanswerindex,
      iscorrect: isCorrect ? 'âœ… CORRECTA' : 'âŒ INCORRECTA'
    });
    
    // Calcular tiempo de respuesta (diferencia entre envÃ­o del poll y respuesta)
    const responseTime = Math.floor((Date.now() - questionData.createdat.getTime()) / 1000);
    console.log('â±ï¸  Tiempo de respuesta:', responseTime, 'segundos');
    
    // Preparar datos para GamificationService
    const gamificationData = {
      telegramUserId: user.id.toString(),
      username: user.username,
      firstName: user.first_name,
      lastName: user.last_name,
      questionId: questionData.questionid,
      telegramMsgId: pollid, // Usamos pollid como identificador
      isCorrect: isCorrect,
      responseTime: responseTime
    };
    
    console.log('ğŸ® Enviando datos a GamificationService:', gamificationData);
    
    // Procesar respuesta con sistema de gamificaciÃ³n
    const userStats = await GamificationService.processUserResponse(gamificationData);
    
    console.log('âœ… GamificationService procesÃ³ la respuesta:', {
      telegramUserId: userStats.telegramUserId,
      username: userStats.username,
      firstName: userStats.firstName,
      totalPoints: userStats.totalPoints,
      level: userStats.level,
      streak: userStats.streak,
      accuracy: userStats.accuracy,
      rank: userStats.rank
    });

    // ğŸ¯ NUEVA FUNCIONALIDAD: FEEDBACK INMEDIATO CON PUNTOS GANADOS
    const pointsEarned = calculatePointsEarned(isCorrect, responseTime);
    const feedbackMessage = generateImmediateFeedback(userStats, isCorrect, pointsEarned, responseTime);
    
    // ğŸš¨ DESHABILITADO: Ya no enviamos mensajes privados porque el quiz de Telegram muestra automÃ¡ticamente si es correcto
    // Enviar feedback inmediato al usuario
    // await sendTelegramMessage(user.id, feedbackMessage);
    console.log('ğŸ“¤ Feedback NO enviado (quiz automÃ¡tico):', feedbackMessage.substring(0, 100) + '...');

    // Generar mensaje de respuesta personalizado  
    console.log('ğŸ’¬ Sistema inteligente: procesando respuesta de quiz...');
    
    // Datos temporales para la respuesta legacy (sistema principal estÃ¡ en poll answers)
    const tempQuestionData = {
      questionid: questionData.questionid,
      correctanswerindex: questionData.correctanswerindex,
      createdat: questionData.createdat,
      chatid: questionData.chatid
    };
    
    // ğŸš¨ DESHABILITADO: Ya no enviamos mensajes inteligentes porque el quiz es automÃ¡tico
    // Usar sistema inteligente para enviar respuesta de quiz
    /* const quizResult = await NotificationService.sendIntelligentQuizResponse(
      userStats,
      iscorrect: isCorrect,
      tempQuestionData,
      {
        telegramUserId: user.id.toString(),
        firstName: user.first_name,
        username: user.username
      },
      questionData.chatid.toString()
    ); */
    
    const quizResult = { method: 'none', message: 'Quiz automÃ¡tico - no se envÃ­an mensajes adicionales' };
    
    console.log('ğŸ“¤ Resultado sistema inteligente quiz:', quizResult.method, '|', quizResult.message);

    console.log('ğŸ‰ ============ POLL ANSWER PROCESADO EXITOSAMENTE ============');
    console.log('ğŸ“ˆ Resumen final:', {
      usuario: `${user.first_name} (@${user.username || 'sin_username'})`,
      telegramId: user.id,
      questionid: questionData.questionid,
      respuestaCorrecta: isCorrect,
      tiempoRespuesta: responseTime,
      puntosNuevos: userStats.totalPoints,
      nivel: userStats.level,
      mensajeEnviado: quizResult.method === 'private'
    });

    return NextResponse.json({ 
      ok: true, 
      type: 'poll_answer_processed',
      processed: true,
      userStats,
      debug: {
        pollid,
        userid: user.id,
        username: user.username,
        iscorrect: isCorrect,
        responsetime: responseTime,
        messageSent: quizResult.method === 'private',
        isDuelResponse: false
      }
    });

  } catch (error) {
    console.error('âŒ ============ ERROR EN POLL ANSWER ============');
    console.error('ğŸ’¥ Error completo:', error);
    console.error('ğŸ“Š Stack trace:', error instanceof Error ? error.stack : 'No stack trace');
    console.error('ğŸ“¥ Poll answer data:', JSON.stringify(pollAnswer, null, 2));
    
    return NextResponse.json({ 
      ok: false, 
      error: 'Error procesando poll answer',
      details: error instanceof Error ? error.message : 'Unknown error'
    }, { status: 500 });
  }
}

// FunciÃ³n para buscar pregunta por Poll ID
async function findQuestionByPollId(pollid: string) {
  try {
    console.log('ğŸ” Buscando pregunta para poll ID:', pollid);
    
    // Buscar primero en la tabla de mapeo de polls normales
    const pollMapping = await prisma.telegrampoll.findUnique({
      where: { pollid: pollid }
    });
    
    if (pollMapping) {
      console.log('âœ… Mapeo encontrado en TelegramPoll:', {
        questionid: pollMapping.questionid,
        correctanswerindex: pollMapping.correctanswerindex,
        sourcemodel: pollMapping.sourcemodel,
        chatid: pollMapping.chatid,
        createdat: pollMapping.createdat
      });
      
      return {
        questionid: pollMapping.questionid,
        correctanswerindex: pollMapping.correctanswerindex,
        sourcemodel: pollMapping.sourcemodel,
        chatid: pollMapping.chatid,
        createdat: pollMapping.createdat,
        subject: 'general' // Default para polls normales
      };
    }
    
    // Si no se encuentra, buscar en la tabla de mapeo de sesiones de estudio
    const studyMapping = await prisma.telegrampollmapping.findUnique({
      where: { pollid: pollid }
    });
    
    if (studyMapping) {
      console.log('âœ… Mapeo encontrado en TelegramPollMapping:', {
        questionid: studyMapping.questionid,
        subject: studyMapping.subject,
        createdat: studyMapping.createdat
      });
      
      return {
        questionid: studyMapping.questionid,
        subject: studyMapping.subject,
        createdat: studyMapping.createdat,
        correctanswerindex: 0, // Default
        sourcemodel: 'study_session',
        chatid: '0' // Default para sesiones de estudio
      };
    }
    
    console.log('âŒ No se encontrÃ³ mapeo para poll ID:', pollid);
    return null;
    
  } catch (error) {
    console.error('âŒ Error buscando pregunta por poll ID:', error);
    return null;
  }
}

// FunciÃ³n para formatear respuesta personalizada de poll
function formatPollResponseMessage(stats: any, iscorrect: boolean, questionData: any): string {
  const correctEmoji = isCorrect ? 'âœ…' : 'âŒ';
  const levelEmoji = getLevelEmoji(stats.level);
  
  const baseMessage = `${correctEmoji} ${isCorrect ? 'Â¡Correcto!' : 'Incorrecto'}

ğŸ† <b>Tus estadÃ­sticas actualizadas:</b>
ğŸ“Š Puntos: ${stats.totalpoints}
${levelEmoji} Nivel: ${stats.level}
ğŸ”¥ Racha: ${stats.streak} dÃ­as
ğŸ¯ PrecisiÃ³n: ${stats.accuracy}%
ğŸ“ˆ Ranking: #${stats.rank}

${getMotivationalMessage(stats, isCorrect)}`;

  return baseMessage;
}

// FunciÃ³n para manejar comando de duelo
async function handleDuelCommand(command: string, userid: string, fromtelegramuser: any, chatid: number): Promise<string | null> {
  try {
    console.log('ğŸ—¡ï¸ DUELO COMMAND - Iniciando:', {
      command,
      userid,
      fromtelegramuser: fromtelegramuser.first_name || fromtelegramuser.username
    });
    
    const parts = command.trim().split(' ');
    console.log('ğŸ—¡ï¸ DUELO COMMAND - Partes del comando:', parts);
    
    if (parts.length < 2) {
      console.log('ğŸ—¡ï¸ DUELO COMMAND - Formato incorrecto, devolviendo ayuda');
      return `ğŸ—¡ï¸ <b>COMANDO DUELO</b> ğŸ—¡ï¸

âŒ Formato incorrecto. Uso:
<code>/duelo @usuario</code>
<code>/duelo nombre</code>

ğŸ¯ <b>EJEMPLOS:</b>
<code>/duelo @juan_estudiante</code>
<code>/duelo Carlos</code>
<code>/duelo Luis</code>

ğŸ® <b>TIPOS DE DUELO:</b>
ğŸ—¡ï¸ <b>EstÃ¡ndar</b> - 5 preguntas, 5 min
âš¡ <b>Velocidad</b> - 3 preguntas, 2 min  
ğŸ¯ <b>PrecisiÃ³n</b> - 7 preguntas, 10 min

Â¡Reta a tus amigos y demuestra quiÃ©n sabe mÃ¡s! ğŸ’ª`;
    }
    
    const targetIdentifier = parts.slice(1).join(' ');
    console.log('ğŸ—¡ï¸ DUELO COMMAND - Buscando usuario:', targetIdentifier);
    
    // Buscar usuario objetivo
    const targetUser = await DuelService.findUserByIdentifier(targetIdentifier);
    console.log('ğŸ—¡ï¸ DUELO COMMAND - Usuario encontrado:', targetUser ? 'SÃ­' : 'No', targetUser);
    
    if (!targetUser) {
      console.log('ğŸ—¡ï¸ DUELO COMMAND - Usuario no encontrado, devolviendo error');
      return `âŒ <b>Usuario no encontrado</b>

ğŸ” <b>No se encontrÃ³ ningÃºn usuario con:</b>
"<i>${targetIdentifier}</i>"

ğŸ’¡ <b>POSIBLES CAUSAS:</b>
ğŸ¤– El usuario no ha iniciado el bot con <code>/start</code>
ğŸ“ El @username no es exacto
ğŸ”¤ El nombre no coincide

ğŸ”§ <b>SOLUCIONES:</b>
1ï¸âƒ£ Pide al usuario que busque <code>@OpoMelillaBot</code> y haga <code>/start</code>
2ï¸âƒ£ Verifica el @username exacto en su perfil
3ï¸âƒ£ Prueba con su nombre de pila

ğŸ¯ <b>EJEMPLO CORRECTO:</b>
<code>/duelo @juan_estudiante</code>
<code>/duelo Carlos</code>

âš ï¸ <b>IMPORTANTE:</b> Todos los usuarios deben iniciar el bot antes de poder participar en duelos.`;
    }
    
    if (targetUser.telegramuserid === userid) {
      console.log('ğŸ—¡ï¸ DUELO COMMAND - Usuario se retÃ³ a sÃ­ mismo');
      return `ğŸ¤” <b>Â¡No puedes retarte a ti mismo!</b>

ğŸ˜… Eso serÃ­a un poco extraÃ±o, Â¿no crees?

ğŸ¯ <b>En su lugar, puedes:</b>
â€¢ Retar a un amigo: <code>/duelo @amigo</code>
â€¢ Ver el ranking: <code>/ranking</code>
â€¢ Practicar solo respondiendo preguntas normales

Â¡Busca un oponente digno! ğŸ—¡ï¸`;
    }
    
    console.log('ğŸ—¡ï¸ DUELO COMMAND - Creando duelo...');
    // Crear duelo
    const duel = await DuelService.createDuel({
      challengerTelegramId: userid,
      challengedTelegramId: targetUser.telegramuserid,
      type: 'standard' // Por defecto estÃ¡ndar
    });
    
    console.log('ğŸ—¡ï¸ DUELO COMMAND - Duelo creado:', duel ? 'SÃ­' : 'No', duel?.id);
    
    if (!duel) {
      console.log('ğŸ—¡ï¸ DUELO COMMAND - No se pudo crear duelo');
      
      // Verificar especÃ­ficamente si el usuario retado existe en la base de datos
      const challengedUserExists = await prisma.telegramuser.findUnique({
        where: { telegramUserId: targetUser.telegramuserid }
      });
      
      if (!challengedUserExists) {
        // El usuario retado no ha hecho /start con el bot
        return `âŒ <b>No se puede crear el duelo</b>

ğŸ¤– <b>PROBLEMA:</b> <b>${targetUser.firstName || targetUser.username || 'El usuario'}</b> aÃºn no ha iniciado el bot

ğŸ”§ <b>SOLUCIÃ“N:</b>
@${targetUser.username || targetUser.firstName || 'usuario'}, necesitas:

1ï¸âƒ£ Buscar <code>@OpoMelillaBot</code> en Telegram
2ï¸âƒ£ Hacer clic en <b>INICIAR</b> o enviar <code>/start</code>
3ï¸âƒ£ Â¡Listo! Ya podrÃ¡s participar en duelos

ğŸ’¡ <b>Â¿Por quÃ© es necesario?</b>
â€¢ Para recibir preguntas por privado (sin spam al grupo)
â€¢ Para gestionar tu puntuaciÃ³n y estadÃ­sticas
â€¢ Para enviar/recibir notificaciones de duelos

âš¡ Una vez hecho esto, el duelo se podrÃ¡ crear normalmente.`;
      }
      
      // Otros errores posibles
      return `âŒ <b>No se pudo crear el duelo</b>

ğŸ” <b>Posibles causas:</b>
â€¢ Ya hay un duelo pendiente entre ustedes
â€¢ El usuario retado no tiene puntos suficientes
â€¢ El usuario no ha iniciado el bot con /start
â€¢ Error temporal del sistema

ğŸ”§ <b>Soluciones:</b>
â€¢ Espera a que termine el duelo actual
â€¢ Verifica que ambos tengan puntos suficientes
â€¢ Pide al usuario que busque @OpoMelillaBot y haga /start
â€¢ IntÃ©ntalo de nuevo en unos minutos

ğŸ“± Usa <code>/duelos</code> para ver duelos pendientes`;
    }
    
    // Enviar notificaciÃ³n inteligente al usuario retado
    const targetName = targetUser.firstName || targetUser.username || 'Usuario';
    const challengerName = fromtelegramuser.first_name || fromtelegramuser.username || 'Retador';
    
    console.log('ğŸ—¡ï¸ DUELO COMMAND - Enviando notificaciÃ³n inteligente para:', targetName);
    
    // Datos para la notificaciÃ³n
    const notificationData = {
      id: duel.id,
      challenger: {
        firstName: challengerName,
        telegramUserId: userid
      },
      challenged: {
        firstName: targetName,
        telegramUserId: targetUser.telegramuserid
      },
      type: 'EstÃ¡ndar',
      questionsCount: duel.questionsCount,
      timelimit: duel.timeLimit,
      stake: duel.stake,
      expiresAt: duel.expiresAt
    };
    
    // Usar sistema inteligente de notificaciones
    const notificationResult = await NotificationService.sendIntelligentNotification(
      'duel',
      {
        telegramUserId: targetUser.telegramuserid,
        username: targetUser.username,
        firstName: targetUser.firstName
      },
      notificationData,
      chatId.toString()
    );
    
    console.log('ğŸ—¡ï¸ DUELO COMMAND - Resultado notificaciÃ³n:', notificationResult.method);
    
    // Preparar respuesta basada en el resultado de la notificaciÃ³n
    let responseMessage = `ğŸ—¡ï¸ <b>Â¡DUELO ENVIADO!</b> âš”ï¸

ğŸ¯ Has retado a <b>${targetName}</b> a un duelo

ğŸ“‹ <b>DETALLES:</b>
ğŸ—¡ï¸ Tipo: EstÃ¡ndar  
ğŸ“ Preguntas: ${duel.questionsCount}
â±ï¸ Tiempo: ${Math.floor(duel.timeLimit / 60)} min
ğŸ’° En juego: ${duel.stake} pts
â° Expira: ${duel.expiresAt.toLocaleTimeString()}

`;

    // Mensaje adaptado segÃºn el mÃ©todo de notificaciÃ³n
    if (notificationResult.method === 'private') {
      responseMessage += `âœ… <b>NOTIFICACIÃ“N PRIVADA ENVIADA</b>
${targetName} ha recibido una notificaciÃ³n privada detallada del bot.

â³ <b>Ahora hay que esperar...</b>
El duelo expira en 30 minutos si no es aceptado.`;
    } 
    else if (notificationResult.method === 'group') {
      responseMessage += `ğŸ“¢ <b>NOTIFICACIÃ“N EN GRUPO</b>
Se enviÃ³ una notificaciÃ³n breve en el grupo.

ğŸ’¡ <b>TIP PARA ${targetName}:</b>
Para recibir notificaciones privadas detalladas:
1. Busca <code>@OpoMelillaBot</code> en Telegram
2. EnvÃ­a <code>/start</code> al bot
3. Â¡Listo! Futuras notificaciones serÃ¡n privadas

â³ El duelo expira en 30 minutos si no es aceptado.`;
    }
    else {
      responseMessage += `âš ï¸ <b>NOTIFICACIÃ“N NO ENVIADA</b>
No se pudo notificar automÃ¡ticamente a ${targetName}.

ğŸ“£ <b>AVÃSALE MANUALMENTE:</b>
"Â¡Te he retado a un duelo! Usa <code>/duelos</code> para verlo"

ğŸ’¡ <b>TIP PARA ${targetName}:</b>
Para recibir notificaciones automÃ¡ticas:
1. Busca <code>@OpoMelillaBot</code> en Telegram  
2. EnvÃ­a <code>/start</code> al bot
3. Â¡Configurado!

â³ El duelo expira en 30 minutos si no es aceptado.`;
    }
    
    responseMessage += `

ğŸ® Usa <code>/duelos</code> para ver el estado`;

    console.log('ğŸ—¡ï¸ DUELO COMMAND - Respuesta preparada');
    return responseMessage;
    
  } catch (error) {
    console.error('ğŸ—¡ï¸ DUELO COMMAND - Error general:', error);
    return `âŒ <b>Error inesperado</b>

Hubo un problema al procesar tu duelo. 
IntÃ©ntalo de nuevo en unos minutos.`;
  }
}

// FunciÃ³n para manejar aceptar duelo
async function handleAcceptDuel(command: string, userid: string): Promise<string | null> {
  try {
    const parts = command.trim().split(' ');
    
    if (parts.length < 2) {
      const pendingDuels = await DuelService.getPendingDuels(userid);
      
      if (pendingDuels.length === 0) {
        return `âœ… <b>ACEPTAR DUELO</b>

âŒ No tienes duelos pendientes para aceptar.

ğŸ¯ <b>Â¿QUÃ‰ PUEDES HACER?</b>
â€¢ Retar a alguien: <code>/duelo @usuario</code>
â€¢ Ver tus duelos: <code>/duelos</code>
â€¢ Esperar a que te reten

ğŸ—¡ï¸ Â¡Los duelos estÃ¡n esperÃ¡ndote!`;
      }
      
      let message = `âœ… <b>ACEPTAR DUELO</b>

ğŸ¯ <b>Tienes ${pendingDuels.length} duelo${pendingDuels.length === 1 ? '' : 's'} pendiente${pendingDuels.length === 1 ? '' : 's'}:</b>

`;
      
      pendingDuels.slice(0, 3).forEach((duel, index) => {
        const challenger = duel.challenger.firstName || duel.challenger.username || 'Usuario';
        message += `ğŸ—¡ï¸ <b>${index + 1}.</b> ${challenger} te retÃ³\n`;
        message += `   ğŸ“ ${duel.questionsCount} preguntas | â±ï¸ ${Math.floor(duel.timeLimit / 60)} min\n`;
        message += `   ğŸ’° ${duel.stake} pts | ğŸ†” ${duel.id}\n\n`;
      });
      
      if (pendingDuels.length > 3) {
        message += `<i>...y ${pendingDuels.length - 3} mÃ¡s</i>\n\n`;
      }
      
      message += `âš¡ <b>USAR:</b>
<code>/aceptar ${pendingDuels[0].id}</code> - Aceptar duelo especÃ­fico
<code>/rechazar ${pendingDuels[0].id}</code> - Rechazar duelo especÃ­fico

ğŸ’¡ <b>TIP:</b> Usa el ID del duelo que quieres aceptar/rechazar`;
      
      return message;
    }
    
    const duelId = parts[1];
    const result = await DuelService.acceptDuel(duelId, userid);
    
    if (!result) {
      return `âŒ <b>No se pudo aceptar el duelo</b>

ğŸ” <b>Posibles causas:</b>
â€¢ El ID del duelo es incorrecto
â€¢ El duelo ya no estÃ¡ pendiente
â€¢ Ha expirado (30 min lÃ­mite)
â€¢ Solo el retado puede aceptar

Usa <code>/duelos</code> para ver tus duelos actuales.`;
    }
    
    return `âš”ï¸ <b>Â¡DUELO ACEPTADO!</b> âš”ï¸

ğŸ¯ Has aceptado el duelo de <b>${result.challenger.firstName}</b>

ğŸ® <b>Â¡QUE COMIENCE LA BATALLA!</b>
El duelo iniciarÃ¡ en breve...

ğŸ“Š <b>DETALLES:</b>
ğŸ—¡ï¸ Tipo: ${result.type}
ğŸ“ Preguntas: ${result.questionsCount}
â±ï¸ Tiempo: ${Math.floor(result.timeLimit / 60)} min
ğŸ’° En juego: ${result.stake} pts

ğŸ”¥ Â¡Buena suerte!`;
    
  } catch (error) {
    console.error('Error manejando aceptar duelo:', error);
    return `âŒ <b>Error inesperado</b>

Hubo un problema al aceptar el duelo.
IntÃ©ntalo de nuevo en unos minutos.`;
  }
}

// FunciÃ³n para manejar rechazar duelo
async function handleRejectDuel(command: string, userid: string): Promise<string | null> {
  try {
    const parts = command.trim().split(' ');
    
    if (parts.length < 2) {
      const pendingDuels = await DuelService.getPendingDuels(userid);
      
      if (pendingDuels.length === 0) {
        return `âŒ <b>RECHAZAR DUELO</b>

âŒ No tienes duelos pendientes para rechazar.

ğŸ¯ <b>Â¿QUÃ‰ PUEDES HACER?</b>
â€¢ Retar a alguien: <code>/duelo @usuario</code>
â€¢ Ver tus duelos: <code>/duelos</code>
â€¢ Esperar a que te reten

ğŸ—¡ï¸ Â¡Los duelos estÃ¡n esperÃ¡ndote!`;
      }
      
      let message = `âŒ <b>RECHAZAR DUELO</b>

ğŸ¯ <b>Tienes ${pendingDuels.length} duelo${pendingDuels.length === 1 ? '' : 's'} pendiente${pendingDuels.length === 1 ? '' : 's'}:</b>

`;
      
      pendingDuels.slice(0, 3).forEach((duel, index) => {
        const challenger = duel.challenger.firstName || duel.challenger.username || 'Usuario';
        message += `ğŸ—¡ï¸ <b>${index + 1}.</b> ${challenger} te retÃ³\n`;
        message += `   ğŸ“ ${duel.questionsCount} preguntas | â±ï¸ ${Math.floor(duel.timeLimit / 60)} min\n`;
        message += `   ğŸ’° ${duel.stake} pts | ğŸ†” ${duel.id}\n\n`;
      });
      
      if (pendingDuels.length > 3) {
        message += `<i>...y ${pendingDuels.length - 3} mÃ¡s</i>\n\n`;
      }
      
      message += `âš¡ <b>USAR:</b>
<code>/rechazar ${pendingDuels[0].id}</code> - Rechazar duelo especÃ­fico
<code>/aceptar ${pendingDuels[0].id}</code> - Aceptar duelo especÃ­fico

ğŸ’¡ <b>TIP:</b> Usa el ID del duelo que quieres rechazar`;
      
      return message;
    }
    
    const duelId = parts[1];
    const success = await DuelService.rejectDuel(duelId, userid);
    
    if (!success) {
      return `âŒ <b>No se pudo rechazar el duelo</b>

ğŸ” <b>Posibles causas:</b>
â€¢ El ID del duelo es incorrecto
â€¢ El duelo ya no estÃ¡ pendiente
â€¢ Ha expirado
â€¢ Solo el retado puede rechazar

Usa <code>/duelos</code> para ver tus duelos actuales.`;
    }
    
    // Para obtener informaciÃ³n del duelo rechazado, buscamos en los duelos del usuario
    const userDuels = await DuelService.getUserDuels(userid);
    const rejectedDuel = userDuels.find(d => d.id === duelId);
    const challengerName = rejectedDuel?.challenger?.firstName || 'Usuario';
    
    return `âŒ <b>DUELO RECHAZADO</b>

Has rechazado el duelo de <b>${challengerName}</b>

ğŸ’­ <b>DecisiÃ³n respetada</b>
No todos los duelos deben ser aceptados.

ğŸ¯ <b>ALTERNATIVAS:</b>
â€¢ Practica con preguntas normales
â€¢ Reta tÃº a otros usuarios: <code>/duelo @usuario</code>
â€¢ Ve el ranking: <code>/ranking</code>

Â¡Siempre habrÃ¡ mÃ¡s oportunidades! ğŸ’ª`;
    
  } catch (error) {
    console.error('Error manejando rechazar duelo:', error);
    return `âŒ <b>Error inesperado</b>

Hubo un problema al rechazar el duelo.
IntÃ©ntalo de nuevo en unos minutos.`;
  }
}

// FunciÃ³n para formatear duelos del usuario
function formatUserDuels(duels: any[], userid: string): string {
  if (duels.length === 0) {
    return `ğŸ—¡ï¸ <b>TUS DUELOS</b> ğŸ—¡ï¸

âŒ No tienes duelos activos.

ğŸ¯ <b>Â¿QUIERES ACCIÃ“N?</b>
â€¢ Reta a alguien: <code>/duelo @usuario</code>
â€¢ Ve el ranking: <code>/ranking</code>
â€¢ Practica con preguntas normales

Â¡Los duelos te estÃ¡n esperando! âš”ï¸`;
  }

  const pending = duels.filter(d => d.status === 'pending');
  const active = duels.filter(d => d.status === 'active');
  const completed = duels.filter(d => d.status === 'completed');

  let message = `ğŸ—¡ï¸ <b>TUS DUELOS</b> ğŸ—¡ï¸\n\n`;

  // Duelos pendientes
  if (pending.length > 0) {
    message += `â³ <b>PENDIENTES (${pending.length}):</b>\n\n`;
    pending.slice(0, 3).forEach((duel, index) => {
      const opponent = duel.challengerTelegramId === userid ? 
        (duel.challenged.firstName || duel.challenged.username) :
        (duel.challenger.firstName || duel.challenger.username);
      const isChallenger = duel.challengerTelegramId === userid;
      
      message += `ğŸ—¡ï¸ <b>${index + 1}.</b> ${isChallenger ? 'Retaste a' : 'Te retÃ³'} ${opponent}\n`;
      message += `   ğŸ“ ${duel.questionsCount} preguntas | â±ï¸ ${Math.floor(duel.timeLimit / 60)} min\n`;
      message += `   ğŸ’° ${duel.stake} pts | ğŸ†” ${duel.id}\n`;
      
      if (!isChallenger) {
        message += `   âš¡ <code>/aceptar ${duel.id}</code> | <code>/rechazar ${duel.id}</code>\n`;
      }
      message += '\n';
    });
  }

  // Duelos activos
  if (active.length > 0) {
    message += `ğŸ”¥ <b>ACTIVOS (${active.length}):</b>\n\n`;
    active.slice(0, 2).forEach((duel, index) => {
      const opponent = duel.challengerTelegramId === userid ? 
        (duel.challenged.firstName || duel.challenged.username) :
        (duel.challenger.firstName || duel.challenger.username);
      
      message += `âš”ï¸ <b>${index + 1}.</b> VS ${opponent}\n`;
      message += `   ğŸ¯ En progreso...\n`;
      message += `   ğŸ’° ${duel.stake} pts en juego\n\n`;
    });
  }

  // Duelos recientes completados
  if (completed.length > 0) {
    message += `âœ… <b>RECIENTES (${Math.min(completed.length, 2)}):</b>\n\n`;
    completed.slice(-2).forEach((duel, index) => {
      const opponent = duel.challengerTelegramId === userid ? 
        (duel.challenged.firstName || duel.challenged.username) :
        (duel.challenger.firstName || duel.challenger.username);
      const won = duel.winnerId === userid;
      
      message += `${won ? 'ğŸ†' : 'ğŸ’€'} VS ${opponent} - ${won ? 'GANASTE' : 'PERDISTE'}\n`;
      message += `   ğŸ’° ${won ? '+' : '-'}${duel.stake} pts\n\n`;
    });
  }

  // EstadÃ­sticas generales
  const wins = completed.filter(d => d.winnerId === userid).length;
  const losses = completed.filter(d => d.winnerId && d.winnerId !== userid).length;
  const winRate = completed.length > 0 ? Math.round((wins / completed.length) * 100) : 0;

  message += `ğŸ“Š <b>ESTADÃSTICAS:</b>\n`;
  message += `ğŸ† Ganados: ${wins} | ğŸ’€ Perdidos: ${losses}\n`;
  message += `ğŸ“ˆ Tasa de victoria: ${winRate}%\n\n`;

  message += `ğŸ® <code>/duelo @usuario</code> para retar`;

  return message;
}

// FunciÃ³n para manejar comando de prueba
async function handleTestCommand(userid: string, fromtelegramuser: any): Promise<string | null> {
  try {
    console.log('ğŸ§ª TEST COMMAND - Iniciando para:', fromtelegramuser.first_name);
    
    // Verificar si el usuario puede recibir mensajes privados
    const canReceivePrivate = await NotificationService.canReceivePrivateMessages(userid);
    
    console.log('ğŸ§ª TEST COMMAND - Puede recibir privados:', canReceivePrivate);
    
    if (canReceivePrivate) {
      // Enviar mensaje de prueba privado
      const testMessage = `ğŸ§ª <b>Â¡PRUEBA EXITOSA!</b> âœ…

ğŸ‰ <b>Â¡Perfecto!</b> Tu configuraciÃ³n estÃ¡ correcta.

ğŸ“± <b>YA PUEDES RECIBIR:</b>
ğŸ—¡ï¸ Notificaciones de duelos
ğŸ… Alertas de logros  
ğŸ¯ Actualizaciones de metas
ğŸ“Š Respuestas detalladas de comandos

ğŸ”¥ <b>Â¡TODO FUNCIONANDO!</b>
A partir de ahora recibirÃ¡s notificaciones privadas ricas en lugar de mensajes breves en el grupo.

âš¡ Usa cualquier comando como <code>/stats</code> para probarlo`;

      const privateSent = await sendTelegramMessage(userid, testMessage);
      
      if (privateSent) {
        return `âœ… <b>Â¡PRUEBA EXITOSA!</b> ğŸ‰

ğŸ“± Te he enviado un mensaje privado detallado.

ğŸ”¥ <b>CONFIGURACIÃ“N PERFECTA:</b>
Tu bot estÃ¡ listo para notificaciones privadas.

ğŸ¯ <b>PRÃ“XIMOS PASOS:</b>
â€¢ Prueba comandos como <code>/stats</code>
â€¢ Los duelos llegaran por privado
â€¢ Respuestas de quiz tambiÃ©n

Â¡Ya no habrÃ¡ mÃ¡s spam en el grupo! ğŸ’ª`;
      }
    }
    
    // Fallback si no puede recibir privadas
    return `âŒ <b>CONFIGURACIÃ“N PENDIENTE</b> ğŸ”§

ğŸ” <b>PROBLEMA DETECTADO:</b>
No puedes recibir mensajes privados del bot.

âœ… <b>SOLUCIÃ“N (sÃºper fÃ¡cil):</b>
1. Busca <code>@OpoMelillaBot</code> en Telegram
2. Toca "Enviar mensaje"  
3. EnvÃ­a <code>/start</code> al bot
4. Vuelve aquÃ­ y usa <code>/test</code> otra vez

ğŸ’¡ <b>Â¿POR QUÃ‰ ES IMPORTANTE?</b>
Sin esto, solo recibirÃ¡s mensajes breves en el grupo.
Con esto, recibirÃ¡s notificaciones detalladas y privadas.

ğŸ¯ <b>Â¡Vale la pena configurarlo!</b> Solo toma 30 segundos.`;
    
  } catch (error) {
    console.error('Error en comando test:', error);
    return `âŒ <b>Error en la prueba</b>

Hubo un problema tÃ©cnico.
IntÃ©ntalo de nuevo en unos minutos.`;
  }
}

// FunciÃ³n para manejar duelos del usuario
async function handleUserDuels(userid: string): Promise<string | null> {
  try {
    const userDuels = await DuelService.getUserDuels(userid);
    return formatUserDuels(userDuels, userid);
  } catch (error) {
    console.error('Error obteniendo duelos del usuario:', error);
    return `âŒ <b>Error al obtener duelos</b>

Hubo un problema al obtener tus duelos. IntÃ©ntalo de nuevo en unos minutos.`;
  }
}

// FunciÃ³n para manejar estadÃ­sticas de duelos
async function handleDuelStats(userid: string): Promise<string | null> {
  try {
    // Obtener datos del usuario
    const user = await prisma.telegramuser.findUnique({
      where: { telegramUserId: userid }
    });
    
    if (!user) {
      return `âŒ <b>Usuario no encontrado</b>

Parece que aÃºn no has iniciado el bot. Usa <code>/start</code> para comenzar.`;
    }
    
    // Obtener estadÃ­sticas de duelos
    const duelStats = await DuelService.getDuelStatistics(userid);
    
    if (!duelStats) {
      return `ğŸ“Š <b>TUS ESTADÃSTICAS</b> ğŸ“Š

ğŸ‘¤ <b>${user.firstName || user.username || 'Usuario'}</b>

ğŸ—¡ï¸ <b>DUELOS:</b>
   ğŸ“ˆ Total disputados: 0
   ğŸ† Ganados: 0
   ğŸ˜” Perdidos: 0
   ğŸ“Š Porcentaje victoria: 0%
   ğŸ”¥ Racha actual: 0

ğŸ’° <b>PUNTOS:</b>
   ğŸ’ Total: ${user.totalpoints || 0}
   ğŸ“Š Nivel: ${user.level || 1}
   âš¡ Racha respuestas: ${user.streak || 0}
   ğŸ… Mejor racha: ${user.beststreak || 0}

ğŸ® <b>Â¡COMIENZA TU PRIMER DUELO!</b>
â€¢ <code>/duelo @usuario</code> - Retar a alguien
â€¢ <code>/ranking</code> - Ver clasificaciÃ³n

âš”ï¸ Â¡Es hora de demostrar tus conocimientos!`;
    }
    
    // Combinar datos del usuario con estadÃ­sticas de duelos
    const combinedStats = {
      ...user,
      totalDuels: duelStats.totalDuels,
      wonDuels: duelStats.wonDuels,
      lostDuels: duelStats.lostDuels,
      currentStreak: duelStats.currentStreak
    };
    
    return formatUserStats(combinedStats);
    
  } catch (error) {
    console.error('Error obteniendo estadÃ­sticas de duelos:', error);
    return `âŒ <b>Error al obtener estadÃ­sticas</b>

Hubo un problema al obtener tus estadÃ­sticas de duelos. IntÃ©ntalo de nuevo en unos minutos.`;
  }
}

// FunciÃ³n para manejar comando /examen2018 - Pregunta especÃ­fica del examen oficial
async function handleExamen2018Command(userid: string, fromtelegramuser: any): Promise<string | null> {
  try {
    console.log('ğŸ¯ EXAMEN2018 - Obteniendo pregunta para usuario:', fromtelegramuser.first_name);
    
    // Obtener una pregunta aleatoria del examen oficial 2018
    const randomQuestion = await prisma.examenoficial2018.findFirst({
      where: {
        isactive: true
      },
      orderBy: {
        sendcount: 'asc' // Priorizar preguntas menos enviadas para rotaciÃ³n equitativa
      },
      skip: Math.floor(Math.random() * 10) // PequeÃ±a aleatoriedad dentro de las menos enviadas
    });
    
    if (!randomQuestion) {
      return `âŒ <b>Sin preguntas disponibles</b>

ğŸ”§ El sistema de preguntas del Examen Oficial 2018 no tiene preguntas activas.
Contacta con los administradores.`;
    }
    
    // Incrementar el contador de envÃ­os
    await prisma.examenoficial2018.update({
      where: { id: randomQuestion.id },
      data: { 
        sendcount: { increment: 1 },
        lastsuccessfulsendat: new Date()
      }
    });
    
    // Intentar enviar como poll interactivo primero
    const canReceivePrivate = await NotificationService.canReceivePrivateMessages(userid);
    
    if (canReceivePrivate) {
      // Crear poll interactivo
      const pollSent = await sendTelegramPoll(
        userid,
        `ğŸ¯ EXAMEN OFICIAL PERMANENCIA 2018 ğŸ¯\n\nğŸ“ Pregunta ${randomQuestion.questionnumber}/100:\n\n${randomQuestion.question}`,
        randomQuestion.options,
        randomQuestion.correctanswerindex,
        randomQuestion.id,
        'examenOficial2018'
      );
      
      if (pollSent) {
        console.log('âœ… Poll examen2018 enviado por privado exitosamente');
        return `ğŸ¯ <b>Â¡Quiz Examen 2018 enviado!</b> âœ…

ğŸ“± Te he enviado un quiz interactivo del Examen Oficial de Permanencia 2018 por mensaje privado.

ğŸ­ <b>Pregunta ${randomQuestion.questionnumber}/100</b>
ğŸ·ï¸ CategorÃ­a: ${randomQuestion.category}

ğŸ’¡ <b>Responde el quiz y recibirÃ¡s:</b>
âœ… Resultado inmediato (correcto/incorrecto)
ğŸ’¡ ExplicaciÃ³n detallada
ğŸ“Š Puntos y estadÃ­sticas actualizadas

ğŸ”„ <code>/examen2018</code> - Otra pregunta`;
      }
    }
    
    // Fallback: enviar mensaje de configuraciÃ³n
    return `ğŸ“ <b>Â¡QUIZ EXAMEN 2018 LISTO!</b> ğŸ¯

ğŸ” <b>PROBLEMA:</b> No puedo enviarte el quiz interactivo por aquÃ­ (evitar spam en grupo).

âœ… <b>SOLUCIÃ“N RÃPIDA:</b>
1. Busca <code>@OpoMelillaBot</code> en Telegram
2. EnvÃ­a <code>/start</code> al bot
3. Vuelve aquÃ­ y usa <code>/examen2018</code> otra vez

ğŸ’¡ <b>Â¿QUÃ‰ GANAS?</b>
ğŸ® Quiz interactivo del Examen Oficial 2018
âœ… Respuestas instantÃ¡neas con explicaciones
ğŸ“Š Seguimiento de tu progreso
ğŸ¯ 100 preguntas reales de permanencia

âš¡ Solo toma 30 segundos configurarlo y recibirÃ¡s los quiz completos!`;
    
  } catch (error) {
    console.error('âŒ Error en comando /examen2018:', error);
    return `âŒ <b>Error obteniendo pregunta</b>

Hubo un problema al obtener la pregunta del Examen Oficial 2018.
IntÃ©ntalo de nuevo en unos minutos.`;
  }
}

// FunciÃ³n para enviar polls/quiz interactivos a Telegram
async function sendTelegramPoll(
  chatid: number | string, 
  question: string, 
  options: string[], 
  correctanswerindex: number, 
  questionid: string,
  sourcemodel: string = 'validQuestion'
): Promise<boolean> {
  try {
    console.log('ğŸ—³ï¸ Enviando poll a Telegram:', { 
      chatId, 
      questionLength: question.length,
      optionCount: options.length,
      sourceModel 
    });
    
    const response = await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/sendPoll`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        chat_id: chatid,
        question: question,
        options: options,
        type: 'quiz', // Quiz tipo con respuesta correcta
        correct_option_id: correctAnswerIndex,
        is_anonymous: false, // Permitir ver quiÃ©n responde
        allows_multiple_answers: false,
        explanation: `ğŸ’¡ ExplicaciÃ³n disponible despuÃ©s de responder.`,
        explanation_parse_mode: 'HTML'
      }),
    });

    const result = await response.json();
    console.log('ğŸ—³ï¸ Respuesta de Telegram sendPoll:', result);
    
    if (!result.ok) {
      console.error('âŒ Error enviando poll a Telegram:', result.description);
      return false;
    }

    // Registrar el poll en la base de datos para tracking
    try {
      await prisma.telegrampoll.create({
        data: {
          pollid: result.result.poll.id,
          questionid: questionId,
          chatid: chatId.toString(),
          correctanswerindex: correctAnswerIndex,
          options: options, // AÃ±adir las opciones del poll
          sourcemodel: sourceModel,
          createdat: new Date()
        }
      });
      console.log('âœ… Poll registrado en BD con ID:', result.result.poll.id);
    } catch (dbError) {
      console.error('âš ï¸ Error registrando poll en BD:', dbError);
      // No fallar el envÃ­o por error de BD
    }

    console.log('âœ… Poll enviado exitosamente a Telegram');
    return true;
  } catch (error) {
    console.error('âŒ Error en sendTelegramPoll:', error);
    return false;
  }
}

// FunciÃ³n para manejar comando /examen2018stats - EstadÃ­sticas avanzadas del examen oficial
async function handleExamen2018StatsCommand(userid: string, fromtelegramuser: any): Promise<string | null> {
  try {
    console.log('ğŸ“Š EXAMEN2018STATS - Generando estadÃ­sticas para usuario:', fromtelegramuser.first_name);
    
    // Obtener todas las respuestas del usuario a preguntas del examen2018
    // CORREGIDO: Usar la estructura correcta de las tablas
    const userResponses = await prisma.$queryRaw`
      SELECT 
        tr."iscorrect",
        tr."responseTime",
        tr.points,
        tr."answeredAt",
        tp."questionid",
        eo."questionNumber",
        eo.category,
        eo.difficulty
      FROM "TelegramResponse" tr
      JOIN "TelegramPoll" tp ON tr."questionid" = tp."pollid"
      JOIN "ExamenOficial2018" eo ON tp."questionid" = eo.id
      JOIN "TelegramUser" tu ON tr."userid" = tu.id
      WHERE tu."telegramUserId" = ${userid}
      AND tp."sourceModel" = 'examenOficial2018'
      ORDER BY tr."answeredAt" DESC
    ` as any[];

    // Calcular estadÃ­sticas generales
    const totalQuestionsAnswered = userResponses.length;
    const correctAnswers = userResponses.filter(r => r.iscorrect).length;
    const totalQuestions = await prisma.examenoficial2018.count();
    const accuracy = totalQuestionsAnswered > 0 ? Math.round((correctAnswers / totalQuestionsAnswered) * 100) : 0;
    
    // EstadÃ­sticas por categorÃ­a
    const categoryStats = new Map();
    userResponses.forEach(response => {
      const category = response.category;
      if (!categoryStats.has(category)) {
        categoryStats.set(category, { total: 0, correct: 0 });
      }
      const stats = categoryStats.get(category);
      stats.total++;
      if (response.iscorrect) stats.correct++;
    });

    // Preguntas Ãºnicas respondidas
    const uniqueQuestions = new Set(userResponses.map(r => r.questionnumber));
    const questionsAnswered = uniqueQuestions.size;
    const progress = Math.round((questionsAnswered / totalQuestions) * 100);

    // Tiempo promedio de respuesta (solo respuestas con tiempo vÃ¡lido)
    const responsesWithTime = userResponses.filter(r => r.responseTime && r.responseTime > 0);
    const avgResponseTime = responsesWithTime.length > 0 
      ? Math.round(responsesWithTime.reduce((sum, r) => sum + r.responseTime, 0) / responsesWithTime.length)
      : 0;

    // Puntos totales del examen
    const totalPoints = userResponses.reduce((sum, r) => sum + (r.points || 0), 0);

    // Racha actual y mejor racha
    let currentStreak = 0;
    let bestStreak = 0;
    let tempStreak = 0;
    
    // Analizar racha (respuestas ordenadas por fecha descendente)
    for (let i = 0; i < userResponses.length; i++) {
      if (userResponses[i].iscorrect) {
        tempStreak++;
        if (i === 0) currentStreak = tempStreak; // La mÃ¡s reciente
        bestStreak = Math.max(bestStreak, tempStreak);
      } else {
        if (i === 0) currentStreak = 0; // La mÃ¡s reciente fue incorrecta
        tempStreak = 0;
      }
    }

    // Obtener Ãºltimas 5 respuestas para mostrar historial reciente
    const recentResponses = userResponses.slice(0, 5);

    // Construir mensaje de estadÃ­sticas
    let statsMessage = `ğŸ“Š <b>ESTADÃSTICAS EXAMEN OFICIAL 2018</b> ğŸ¯\n\n`;
    
    // Progreso general
    statsMessage += `ğŸ¯ <b>PROGRESO GENERAL:</b>\n`;
    statsMessage += `   ğŸ“ Preguntas respondidas: ${questionsAnswered}/${totalQuestions} (${progress}%)\n`;
    statsMessage += `   ğŸ”„ Total intentos: ${totalQuestionsAnswered}\n`;
    statsMessage += `   âœ… Respuestas correctas: ${correctAnswers}\n`;
    statsMessage += `   ğŸ“ˆ PrecisiÃ³n: ${accuracy}%\n`;
    statsMessage += `   ğŸ’ Puntos obtenidos: ${totalPoints}\n\n`;

    // Rendimiento
    statsMessage += `âš¡ <b>RENDIMIENTO:</b>\n`;
    statsMessage += `   ğŸ”¥ Racha actual: ${currentStreak} aciertos\n`;
    statsMessage += `   ğŸ† Mejor racha: ${bestStreak} aciertos\n`;
    if (avgResponseTime > 0) {
      statsMessage += `   â±ï¸ Tiempo promedio: ${avgResponseTime}s\n`;
    }
    statsMessage += `\n`;

    // EstadÃ­sticas por categorÃ­a
    if (categoryStats.size > 0) {
      statsMessage += `ğŸ“š <b>RENDIMIENTO POR CATEGORÃA:</b>\n`;
      Array.from(categoryStats.entries())
        .sort((a, b) => (b[1].correct / b[1].total) - (a[1].correct / a[1].total))
        .forEach(([category, stats]) => {
          const categoryAccuracy = Math.round((stats.correct / stats.total) * 100);
          const categoryEmoji = categoryAccuracy >= 80 ? 'ğŸŸ¢' : categoryAccuracy >= 60 ? 'ğŸŸ¡' : 'ğŸ”´';
          statsMessage += `   ${categoryEmoji} ${category}: ${stats.correct}/${stats.total} (${categoryAccuracy}%)\n`;
        });
      statsMessage += `\n`;
    }

    // Historial reciente
    if (recentResponses.length > 0) {
      statsMessage += `ğŸ“‹ <b>ÃšLTIMAS RESPUESTAS:</b>\n`;
      recentResponses.forEach((response, index) => {
        const resultEmoji = response.iscorrect ? 'âœ…' : 'âŒ';
        const date = new Date(response.answeredAt).toLocaleDateString('es-ES');
        const points = response.points || 0;
        statsMessage += `   ${resultEmoji} P${response.questionnumber} - ${response.category} (+${points}pts) - ${date}\n`;
      });
      statsMessage += `\n`;
    }

    // Objetivos y motivaciÃ³n
    if (progress < 100) {
      const questionsRemaining = totalQuestions - questionsAnswered;
      statsMessage += `ğŸ¯ <b>PRÃ“XIMO OBJETIVO:</b>\n`;
      if (progress < 25) {
        statsMessage += `   ğŸš€ Completa 25 preguntas (faltan ${25 - questionsAnswered})\n`;
      } else if (progress < 50) {
        statsMessage += `   ğŸª Alcanza el 50% del examen (faltan ${questionsRemaining} preguntas)\n`;
      } else if (progress < 75) {
        statsMessage += `   ğŸ­ Â¡Supera el 75%! (faltan ${questionsRemaining} preguntas)\n`;
      } else {
        statsMessage += `   ğŸ† Â¡Completa el examen! (faltan ${questionsRemaining} preguntas)\n`;
      }
      statsMessage += `\n`;
    } else {
      statsMessage += `ğŸ‰ <b>Â¡EXAMEN COMPLETADO!</b>\n`;
      statsMessage += `   ğŸ† Has respondido todas las preguntas oficiales\n`;
      statsMessage += `   ğŸ’ª Â¡Sigue practicando para mejorar tu precisiÃ³n!\n\n`;
    }

    // Comandos Ãºtiles
    statsMessage += `ğŸ”§ <b>COMANDOS ÃšTILES:</b>\n`;
    statsMessage += `   ğŸ“ <code>/examen2018</code> - Nueva pregunta\n`;
    statsMessage += `   ğŸ“Š <code>/stats</code> - EstadÃ­sticas generales\n`;
    statsMessage += `   ğŸ† <code>/ranking</code> - Ver clasificaciÃ³n\n`;

    return statsMessage;

  } catch (error) {
    console.error('âŒ Error en comando /examen2018stats:', error);
    return `âŒ <b>Error obteniendo estadÃ­sticas</b>

Hubo un problema al generar tus estadÃ­sticas del Examen Oficial 2018.
IntÃ©ntalo de nuevo en unos minutos.`;
  }
}

// FunciÃ³n para manejar comando /simulacro - Iniciar simulacro del examen oficial
async function handleSimulacroCommand(userid: string, fromtelegramuser: any): Promise<string | null> {
  try {
    console.log('ğŸ¯ SIMULACRO - Verificando si puede iniciar simulacro para usuario:', fromtelegramuser.first_name);
    
    // Verificar si el usuario puede recibir mensajes privados
    const canReceivePrivate = await NotificationService.canReceivePrivateMessages(userid);
    
    if (!canReceivePrivate) {
      return `âš ï¸ <b>CONFIGURACIÃ“N REQUERIDA</b> ğŸ”§

ğŸ¯ <b>MODO SIMULACRO</b> requiere mensajes privados para funcionar correctamente.

âœ… <b>CONFIGURACIÃ“N (30 segundos):</b>
1. Busca <code>@OpoMelillaBot</code> en Telegram
2. EnvÃ­a <code>/start</code> al bot
3. Vuelve aquÃ­ y usa <code>/simulacro</code> otra vez

ğŸ’¡ <b>Â¿POR QUÃ‰ ES NECESARIO?</b>
ğŸ¯ El simulacro son 100 preguntas (3 horas)
ğŸ“± Se envÃ­an quiz interactivos por privado
â° Evita spam en el grupo durante 3 horas
ğŸ® Experiencia completa como el examen real

ğŸš€ <b>Â¡Vale la pena configurarlo! Solo toma 30 segundos.</b>`;
    }
    
    // Verificar si ya tiene un simulacro activo
    const activeSimulacro = await prisma.$queryRaw`
      SELECT s.id, s."startedAt", s."timeElapsed", s."currentQuestionIndex", s."totalQuestions"
      FROM "Simulacro" s
      JOIN "TelegramUser" tu ON s."userid" = tu.id
      WHERE tu."telegramUserId" = ${userid}
      AND s.status = 'in_progress'
      LIMIT 1
    ` as any[];
    
    if (activeSimulacro.length > 0) {
      const simulacro = activeSimulacro[0];
      const timeElapsed = Math.floor((Date.now() - new Date(simulacro.startedat).getTime()) / 1000);
      const timeRemaining = Math.max(0, 10800 - timeElapsed); // 3 horas lÃ­mite
      const hoursRemaining = Math.floor(timeRemaining / 3600);
      const minutesRemaining = Math.floor((timeRemaining % 3600) / 60);
      
      return `ğŸ¯ <b>SIMULACRO EN PROGRESO</b> â³

Ya tienes un simulacro del Examen Oficial 2018 en curso.

ğŸ“Š <b>PROGRESO ACTUAL:</b>
ğŸ“ Pregunta: ${simulacro.currentQuestionIndex}/${simulacro.totalQuestions}
â° Tiempo restante: ${hoursRemaining}h ${minutesRemaining}m
ğŸ—“ï¸ Iniciado: ${new Date(simulacro.startedat).toLocaleString()}

ğŸ® <b>OPCIONES:</b>
â–¶ï¸ <code>/simulacro_continuar</code> - Continuar examen
ğŸšª <code>/simulacro_abandonar</code> - Abandonar (perderÃ¡s progreso)
ğŸ“Š <code>/simulacro_historial</code> - Ver historial

ğŸ’¡ <b>TIP:</b> Solo puedes tener un simulacro activo a la vez para mantener la concentraciÃ³n.`;
    }
    
    // Verificar que hay suficientes preguntas
    const questionCount = await prisma.examenoficial2018.count({
      where: { isactive: true }
    });
    
    if (questionCount < 100) {
      return `âŒ <b>Sistema no disponible</b>

ğŸ”§ No hay suficientes preguntas del Examen Oficial 2018.
ğŸ“ Contacta con los administradores.`;
    }
    
    // Iniciar nuevo simulacro
    const user = await prisma.telegramuser.findUnique({
      where: { telegramUserId: userid }
    });
    
    if (!user) {
      return `âŒ <b>Usuario no registrado</b>

Usa <code>/start</code> para registrarte primero.`;
    }
    
    // Crear simulacro
    const simulacro = await prisma.simulacro.create({
      data: {
        userid: user.id,
        status: 'in_progress',
        timelimit: 10800,
        totalQuestions: 100
      }
    });
    
    // Obtener todas las preguntas y crear las respuestas
    const questions = await prisma.examenoficial2018.findMany({
      where: { isactive: true },
      orderBy: { questionnumber: 'asc' },
      take: 100
    });
    
    // Crear respuestas del simulacro usando tambiÃ©n ORM
    const simulacroResponses = questions.map(question => ({
      simulacroid: simulacro.id,
      questionid: question.id,
      questionnumber: question.questionnumber,
      questionCategory: question.category,
      questionDifficulty: question.difficulty,
      answeredat: null,
      selectedoption: null,
      iscorrect: null,
      responseTime: null,
      skipped: false
    }));
    
    await prisma.simulacroresponse.createMany({
      data: simulacroResponses
    });
    
    // Enviar primera pregunta
    const firstQuestion = questions[0];
    const firstHeader = `ğŸ¯ SIMULACRO 1/100 â±ï¸3h\n\n`;
    const firstPollQuestion = truncatePollQuestion(firstHeader, firstQuestion.question);
    
    const pollSent = await sendTelegramPoll(
      userid,
      firstPollQuestion,
      firstQuestion.options,
      firstQuestion.correctanswerindex,
      `simulacro-${simulacro.id}-${firstQuestion.questionnumber}`,
      'simulacro'
    );
    
    if (pollSent) {
      return `ğŸ¯ <b>Â¡SIMULACRO INICIADO!</b> ğŸš€

âœ… Te he enviado la primera pregunta por mensaje privado.

ğŸ“‹ <b>INSTRUCCIONES IMPORTANTES:</b>
â° <b>Tiempo lÃ­mite:</b> 3 horas (180 minutos)
ğŸ“ <b>Preguntas:</b> 100 del examen oficial
ğŸš« <b>Sin pausas:</b> Una vez iniciado, debe completarse
ğŸ“Š <b>Aprobado:</b> 50% o mÃ¡s (â‰¥50 correctas)

ğŸ® <b>COMANDOS DURANTE EL EXAMEN:</b>
â–¶ï¸ <code>/simulacro_continuar</code> - Si se interrumpe
ğŸšª <code>/simulacro_abandonar</code> - Abandonar examen

ğŸ€ <b>Â¡BUENA SUERTE!</b> Responde con calma y concentraciÃ³n.

ğŸ’¡ <b>TIP:</b> Este es un simulacro del examen real de permanencia 2018.`;
    } else {
      return `âŒ <b>Error enviando pregunta</b>

No se pudo enviar la primera pregunta. IntÃ©ntalo de nuevo.`;
    }
    
  } catch (error) {
    console.error('âŒ Error en comando /simulacro:', error);
    return `âŒ <b>Error iniciando simulacro</b>

Hubo un problema al iniciar el simulacro del Examen Oficial 2018.
IntÃ©ntalo de nuevo en unos minutos.`;
  }
}

// FunciÃ³n para manejar comando /simulacro_continuar - Continuar simulacro en progreso
async function handleSimulacroResumeCommand(userid: string, fromtelegramuser: any): Promise<string | null> {
  try {
    console.log('â–¶ï¸ SIMULACRO_CONTINUAR - Para usuario:', fromtelegramuser.first_name);
    
    // Buscar simulacro 2024 activo primero
    const activeSimulacro2024 = await Simulacro2024Service.getActiveSimulacro(userid);
    
    if (activeSimulacro2024) {
      console.log('ğŸ¯ SIMULACRO 2024 activo encontrado, continuando...');
      
      // Obtener la siguiente pregunta del simulacro 2024
      const nextQuestion = await Simulacro2024Service.getCurrentQuestion(activeSimulacro2024.id);
      
      if (!nextQuestion) {
        return `âœ… <b>SIMULACRO COMPLETADO</b>

Â¡Has completado todas las preguntas!

ğŸ“‹ <code>/simulacro_historial</code> - Ver resultados`;
      }
      
      // Calcular tiempo restante
      const timeElapsed = Math.floor((Date.now() - new Date(activeSimulacro2024.startedat).getTime()) / 1000);
      const timeRemaining = Math.max(0, 10800 - timeElapsed);
      const hoursRemaining = Math.floor(timeRemaining / 3600);
      const minutesRemaining = Math.floor((timeRemaining % 3600) / 60);
      
      // Enviar pregunta actual
      const pollSent = await sendTelegramPoll(
        userid,
        `ğŸ¯ SIMULACRO EXAMEN 2024 - Pregunta ${nextQuestion.questionnumber}/100\nâ° Tiempo restante: ${hoursRemaining}h ${minutesRemaining}m\n\n${nextQuestion.question}`,
        nextQuestion.options,
        nextQuestion.correctanswerindex,
        nextQuestion.id,
        'simulacro2024'
      );
      
      if (pollSent) {
        return `â–¶ï¸ <b>SIMULACRO 2024 CONTINUADO</b> âœ…

Te he enviado la pregunta actual por mensaje privado.

ğŸ“Š <b>PROGRESO:</b>
ğŸ“ Pregunta: ${nextQuestion.questionnumber}/100
â° Tiempo restante: ${hoursRemaining}h ${minutesRemaining}m

ğŸ’ª Â¡Sigue adelante con el Examen 2024!`;
      } else {
        return `âŒ <b>Error enviando pregunta</b>

No se pudo enviar la pregunta. IntÃ©ntalo de nuevo.`;
      }
    }
    
    // Si no hay simulacro 2024 activo, buscar simulacro 2018 activo
    const activeSimulacro = await prisma.$queryRaw`
      SELECT s.id, s."startedAt", s."timeElapsed", s."currentQuestionIndex", s."totalQuestions"
      FROM "Simulacro" s
      JOIN "TelegramUser" tu ON s."userid" = tu.id
      WHERE tu."telegramUserId" = ${userid}
      AND s.status = 'in_progress'
      LIMIT 1
    ` as any[];
    
    if (activeSimulacro.length === 0) {
      return `âŒ <b>No hay simulacro activo</b>

No tienes ningÃºn simulacro en progreso.

ğŸ¯ <b>OPCIONES:</b>
ğŸš€ <code>/simulacro</code> - Iniciar simulacro 2018
ğŸš€ <code>/simulacro2024</code> - Iniciar simulacro 2024
ğŸ“‹ <code>/simulacro_historial</code> - Ver historial`;
    }
    
    const simulacro = activeSimulacro[0];
    const timeElapsed = Math.floor((Date.now() - new Date(simulacro.startedat).getTime()) / 1000);
    
    // Verificar si ha expirado
    if (timeElapsed >= 10800) {
      // Marcar como expirado
      await prisma.$queryRaw`
        UPDATE "Simulacro" 
        SET status = 'expired', "completedAt" = CURRENT_TIMESTAMP
        WHERE id = ${simulacro.id}
      `;
      
      return `â° <b>SIMULACRO EXPIRADO</b>

Tu simulacro ha expirado (lÃ­mite de 3 horas).

ğŸ“Š <b>PROGRESO FINAL:</b>
ğŸ“ Pregunta alcanzada: ${simulacro.currentQuestionIndex}/${simulacro.totalQuestions}
â° Tiempo transcurrido: 3h 0m

ğŸš€ <b>SIGUIENTE PASO:</b>
<code>/simulacro</code> - Iniciar nuevo simulacro`;
    }
    
    // Obtener siguiente pregunta sin responder
    const nextQuestion = await prisma.$queryRaw`
      SELECT sr."questionNumber", eo.question, eo.options, eo."correctAnswerIndex"
      FROM "SimulacroResponse" sr
      JOIN "ExamenOficial2018" eo ON sr."questionid" = eo.id
      WHERE sr."simulacroId" = ${simulacro.id}
      AND sr."answeredAt" IS NULL
      AND sr.skipped = false
      ORDER BY sr."questionNumber" ASC
      LIMIT 1
    ` as any[];
    
    if (nextQuestion.length === 0) {
      return `âœ… <b>SIMULACRO COMPLETADO</b>

Â¡Has completado todas las preguntas!

ğŸ“‹ <code>/simulacro_historial</code> - Ver resultados`;
    }
    
    const question = nextQuestion[0];
    const timeRemaining = Math.max(0, 10800 - timeElapsed);
    const hoursRemaining = Math.floor(timeRemaining / 3600);
    const minutesRemaining = Math.floor((timeRemaining % 3600) / 60);
    
    // Enviar pregunta actual
    const pollSent = await sendTelegramPoll(
      userid,
      `ğŸ¯ SIMULACRO ${question.questionnumber}/100 â±ï¸${hoursRemaining}h${minutesRemaining}m\n\n${question.question}`,
      question.options,
      question.correctanswerindex,
      `simulacro-${simulacro.id}-${question.questionnumber}`,
      'simulacro'
    );
    
    if (pollSent) {
      return `â–¶ï¸ <b>SIMULACRO CONTINUADO</b> âœ…

Te he enviado la pregunta actual por mensaje privado.

ğŸ“Š <b>PROGRESO:</b>
ğŸ“ Pregunta: ${question.questionnumber}/100
â° Tiempo restante: ${hoursRemaining}h ${minutesRemaining}m

ğŸ’ª Â¡Sigue adelante!`;
    } else {
      return `âŒ <b>Error enviando pregunta</b>

No se pudo enviar la pregunta. IntÃ©ntalo de nuevo.`;
    }
    
  } catch (error) {
    console.error('âŒ Error en simulacro_continuar:', error);
    return `âŒ <b>Error continuando simulacro</b>

IntÃ©ntalo de nuevo en unos minutos.`;
  }
}

// FunciÃ³n para manejar comando /simulacro_abandonar - Abandonar simulacro actual
async function handleSimulacroAbandonCommand(userid: string, fromtelegramuser: any): Promise<string | null> {
  try {
    console.log('ğŸšª SIMULACRO_ABANDONAR - Para usuario:', fromtelegramuser.first_name);
    
    // Buscar simulacro activo
    const activeSimulacro = await prisma.$queryRaw`
      SELECT s.id, s."startedAt", s."currentQuestionIndex", s."totalQuestions"
      FROM "Simulacro" s
      JOIN "TelegramUser" tu ON s."userid" = tu.id
      WHERE tu."telegramUserId" = ${userid}
      AND s.status = 'in_progress'
      LIMIT 1
    ` as any[];
    
    if (activeSimulacro.length === 0) {
      return `âŒ <b>No hay simulacro activo</b>

No tienes ningÃºn simulacro en progreso para abandonar.

ğŸ¯ <code>/simulacro</code> - Iniciar nuevo simulacro`;
    }
    
    const simulacro = activeSimulacro[0];
    
    // Marcar como abandonado
    await prisma.$queryRaw`
      UPDATE "Simulacro" 
      SET status = 'abandoned', "completedAt" = CURRENT_TIMESTAMP
      WHERE id = ${simulacro.id}
    `;
    
    const timeElapsed = Math.floor((Date.now() - new Date(simulacro.startedat).getTime()) / 1000);
    const hoursElapsed = Math.floor(timeElapsed / 3600);
    const minutesElapsed = Math.floor((timeElapsed % 3600) / 60);
    
    return `ğŸšª <b>SIMULACRO ABANDONADO</b> 

Has abandonado el simulacro del Examen Oficial 2018.

ğŸ“Š <b>PROGRESO AL ABANDONAR:</b>
ğŸ“ Pregunta alcanzada: ${simulacro.currentQuestionIndex}/${simulacro.totalQuestions}
â° Tiempo transcurrido: ${hoursElapsed}h ${minutesElapsed}m
ğŸ“… Iniciado: ${new Date(simulacro.startedat).toLocaleString()}

ğŸ’¡ <b>IMPORTANTE:</b>
El progreso no se guarda al abandonar.

ğŸš€ <b>PRÃ“XIMO PASO:</b>
<code>/simulacro</code> - Iniciar nuevo simulacro cuando estÃ©s listo

ğŸ¯ Â¡No te desanimes! Los simulacros son para practicar.`;
    
  } catch (error) {
    console.error('âŒ Error en simulacro_abandonar:', error);
    return `âŒ <b>Error abandonando simulacro</b>

IntÃ©ntalo de nuevo en unos minutos.`;
  }
}

// FunciÃ³n para manejar comando /simulacro_historial - Ver historial de simulacros
async function handleSimulacroHistoryCommand(userid: string, fromtelegramuser: any): Promise<string | null> {
  try {
    console.log('ğŸ“‹ SIMULACRO_HISTORIAL - Para usuario:', fromtelegramuser.first_name);
    
    // Obtener historial de simulacros
    const simulacros = await prisma.$queryRaw`
      SELECT s.id, s.status, s."startedAt", s."completedAt", s."timeElapsed",
             s."finalScore", s."finalPercentage", s.passed, s."totalQuestions",
             s."averageResponseTime"
      FROM "Simulacro" s
      JOIN "TelegramUser" tu ON s."userid" = tu.id
      WHERE tu."telegramUserId" = ${userid}
      ORDER BY s."startedAt" DESC
      LIMIT 10
    ` as any[];
    
    if (simulacros.length === 0) {
      return `ğŸ“‹ <b>HISTORIAL DE SIMULACROS</b>

âŒ AÃºn no has realizado ningÃºn simulacro.

ğŸ¯ <b>Â¿QUÃ‰ ES UN SIMULACRO?</b>
ğŸ“ Examen completo de 100 preguntas del oficial 2018
â° Tiempo lÃ­mite: 3 horas (como el real)
ğŸ“Š PuntuaciÃ³n oficial: â‰¥50% para aprobar
ğŸ† PrÃ¡ctica en condiciones reales

ğŸš€ <b>INICIAR PRIMER SIMULACRO:</b>
<code>/simulacro</code> - Â¡Ponte a prueba!

ğŸ’¡ <b>TIP:</b> Es la mejor forma de prepararse para el examen real.`;
    }
    
    let message = `ğŸ“‹ <b>HISTORIAL DE SIMULACROS</b>\n\n`;
    message += `ğŸ¯ <b>Total realizados:</b> ${simulacros.length}\n\n`;
    
    // EstadÃ­sticas generales
    const completed = simulacros.filter(s => s.status === 'completed');
    const passed = completed.filter(s => s.passed);
    const avgScore = completed.length > 0 
      ? Math.round(completed.reduce((sum, s) => sum + s.finalScore, 0) / completed.length)
      : 0;
    
    if (completed.length > 0) {
      message += `ğŸ“Š <b>ESTADÃSTICAS GENERALES:</b>\n`;
      message += `âœ… Completados: ${completed.length}\n`;
      message += `ğŸ† Aprobados: ${passed.length} (${Math.round((passed.length / completed.length) * 100)}%)\n`;
      message += `ğŸ“ˆ PuntuaciÃ³n promedio: ${avgScore}/100\n\n`;
    }
    
    message += `ğŸ“‹ <b>ÃšLTIMOS SIMULACROS:</b>\n\n`;
    
    simulacros.slice(0, 5).forEach((sim, index) => {
      const date = new Date(sim.startedat).toLocaleDateString();
      const statusEmoji = {
        'completed': sim.passed ? 'ğŸ†' : 'ğŸ“',
        'abandoned': 'ğŸšª',
        'expired': 'â°',
        'in_progress': 'â–¶ï¸'
      }[sim.status] || 'ğŸ“„';
      
      const statusText = {
        'completed': sim.passed ? `APROBADO (${sim.finalScore}/100)` : `SUSPENDIDO (${sim.finalScore}/100)`,
        'abandoned': 'ABANDONADO',
        'expired': 'EXPIRADO',
        'in_progress': 'EN PROGRESO'
      }[sim.status] || 'UNKNOWN';
      
      message += `${statusEmoji} <b>${index + 1}.</b> ${statusText}\n`;
      message += `   ğŸ“… ${date}`;
      
      if (sim.status === 'completed') {
        const percentage = Math.round(sim.finalPercentage);
        const timeInMinutes = Math.round(sim.timeElapsed / 60);
        const avgTime = sim.averageResponseTime ? Math.round(sim.averageResponseTime) : 0;
        message += ` | ğŸ“Š ${percentage}% | â±ï¸ ${timeInMinutes}min`;
        if (avgTime > 0) {
          message += ` | ğŸ• ${avgTime}s/preg`;
        }
      }
      
      message += `\n\n`;
    });
    
    if (simulacros.length > 5) {
      message += `<i>...y ${simulacros.length - 5} mÃ¡s</i>\n\n`;
    }
    
    // Simulacro activo
    const activeSimulacro = simulacros.find(s => s.status === 'in_progress');
    if (activeSimulacro) {
      message += `â–¶ï¸ <b>SIMULACRO ACTIVO:</b>\n`;
      message += `<code>/simulacro_continuar</code> - Continuar examen\n\n`;
    } else {
      message += `ğŸš€ <b>SIGUIENTE PASO:</b>\n`;
      message += `<code>/simulacro</code> - Nuevo simulacro\n\n`;
    }
    
    message += `ğŸ’¡ <b>TIP:</b> Practica regularmente para mejorar tu puntuaciÃ³n.`;
    
    return message;
    
  } catch (error) {
    console.error('âŒ Error en simulacro_historial:', error);
    return `âŒ <b>Error obteniendo historial</b>

IntÃ©ntalo de nuevo en unos minutos.`;
  }
}

// Helper function to truncate poll question if it exceeds Telegram's 300 char limit
function truncatePollQuestion(header: string, question: string, maxLength: number = 300): string {
  const fullText = `${header}${question}`;
  
  if (fullText.length <= maxLength) {
    return fullText;
  }
  
  // Calculate how much space we have for the question after the header
  const availableSpace = maxLength - header.length - 3; // -3 for "..."
  
  if (availableSpace < 50) {
    // If header is too long, truncate it too
    const shortHeader = header.substring(0, Math.floor(maxLength * 0.3));
    const questionSpace = maxLength - shortHeader.length - 3;
    return `${shortHeader}${question.substring(0, questionSpace)}...`;
  }
  
  // Truncate question and add ellipsis
  return `${header}${question.substring(0, availableSpace)}...`;
}

// Helper function to calculate current streak of correct answers
function calculateCurrentStreak(responses: boolean[]): number {
  let streak = 0;
  for (const isCorrect of responses) {
    if (isCorrect) {
      streak++;
    } else {
      break;
    }
  }
  return streak;
}

// ======== FUNCIONES PARA EXAMEN 2024 ========

// FunciÃ³n para manejar comando /examen2024 - Pregunta del examen oficial 2024
async function handleExamen2024Command(userid: string, fromtelegramuser: any): Promise<string | null> {
  try {
    console.log('ğŸ¯ EXAMEN2024 - Para usuario:', fromtelegramuser.first_name);
    
    // Obtener pregunta aleatoria del examen 2024
    const questions = await (prisma as any).examenOficial2024.findMany({
      where: { isactive: true },
      orderBy: { questionnumber: 'asc' }
    });
    
    if (questions.length === 0) {
      return `âŒ <b>NO HAY PREGUNTAS DISPONIBLES</b>\n\nEl Examen Oficial 2024 no estÃ¡ disponible en este momento.\nContacta al administrador.`;
    }
    
    // Seleccionar pregunta aleatoria
    const randomIndex = Math.floor(Math.random() * questions.length);
    const randomQuestion = questions[randomIndex];
    
    // Incrementar contador de envÃ­os
    await (prisma as any).examenOficial2024.update({
      where: { id: randomQuestion.id },
      data: { sendcount: { increment: 1 }, lastsuccessfulsendat: new Date() }
    });
    
    // Preparar header con informaciÃ³n
    const header = `ğŸ¯ <b>EXAMEN OFICIAL 2024 - Pregunta ${randomQuestion.questionnumber}/100</b>\n\n`;
    const pollQuestion = truncatePollQuestion(header, randomQuestion.question);
    
    // Enviar poll de Telegram
    const pollSent = await sendTelegramPoll(
      userid,
      pollQuestion,
      randomQuestion.options,
      randomQuestion.correctanswerindex,
      randomQuestion.id,
      'examenOficial2024'
    );
    
    if (pollSent) {
      console.log('âœ… EXAMEN2024 - Poll enviado exitosamente');
      return null; // Poll enviado, no necesitamos texto adicional
    } else {
      console.error('âŒ EXAMEN2024 - Error enviando poll');
      return `âŒ <b>ERROR ENVIANDO PREGUNTA</b>\n\nHubo un problema tÃ©cnico.\nIntenta nuevamente en unos momentos.`;
    }
    
  } catch (error) {
    console.error('âŒ Error en handleExamen2024Command:', error);
    return `âŒ <b>ERROR INTERNO</b>\n\nHubo un problema procesando tu solicitud.\nContacta al administrador si persiste.`;
  }
}

// FunciÃ³n para manejar comando /examen2024stats - EstadÃ­sticas del examen oficial 2024
async function handleExamen2024StatsCommand(userid: string, fromtelegramuser: any): Promise<string | null> {
  try {
    console.log('ğŸ“Š EXAMEN2024STATS - Para usuario:', fromtelegramuser.first_name);
    
    // Obtener estadÃ­sticas usando query directo para evitar problemas de tipos
    const userResponses = await prisma.$queryRaw`
      SELECT 
        tr."iscorrect",
        tr."responseTime",
        tr.points,
        tr."answeredAt",
        tp."questionid",
        eo."questionNumber",
        eo.category,
        eo.difficulty
      FROM "TelegramResponse" tr
      JOIN "TelegramPoll" tp ON tr."questionid" = tp."pollid"
      JOIN "ExamenOficial2024" eo ON tp."questionid" = eo."id"
      WHERE tr."telegramUserId" = ${userid}
        AND tp."sourceModel" = 'examenOficial2024'
      ORDER BY tr."answeredAt" DESC
    ` as any[];
    
    if (userResponses.length === 0) {
      return `ğŸ“Š <b>ESTADÃSTICAS EXAMEN 2024</b>\n\nâ“ AÃºn no has respondido ninguna pregunta del examen oficial 2024.\n\nğŸ¯ Usa <code>/examen2024</code> para empezar a practicar.`;
    }
    
    // Calcular estadÃ­sticas
    const totalAnswered = userResponses.length;
    const correctAnswers = userResponses.filter((r: any) => r.iscorrect === true).length;
    const accuracy = totalAnswered > 0 ? (correctAnswers / totalAnswered * 100) : 0;
    
    // DistribuciÃ³n por categorÃ­as
    const categoryStats: { [key: string]: { total: number; correct: number } } = {};
    userResponses.forEach((response: any) => {
      const category = response.category || 'Sin categorÃ­a';
      if (!categoryStats[category]) {
        categoryStats[category] = { total: 0, correct: 0 };
      }
      categoryStats[category].total++;
      if (response.iscorrect) {
        categoryStats[category].correct++;
      }
    });
    
    // Tiempo promedio de respuesta
    const responsesWithTime = userResponses.filter((r: any) => r.responseTime && r.responseTime > 0);
    const avgResponseTime = responsesWithTime.length > 0 ? 
      responsesWithTime.reduce((sum: number, r: any) => sum + r.responseTime, 0) / responsesWithTime.length : 0;
    
    // Preguntas Ãºnicas respondidas
    const uniqueQuestions = new Set(userResponses.map((r: any) => r.questionnumber)).size;
    
    // Crear mensaje de respuesta
    let statsMessage = `ğŸ“Š <b>ESTADÃSTICAS EXAMEN OFICIAL 2024</b>\n\n`;
    statsMessage += `ğŸ“ˆ <b>RENDIMIENTO GENERAL:</b>\n`;
    statsMessage += `â€¢ Preguntas respondidas: ${totalAnswered}\n`;
    statsMessage += `â€¢ Preguntas Ãºnicas: ${uniqueQuestions}/100\n`;
    statsMessage += `â€¢ Respuestas correctas: ${correctAnswers}/${totalAnswered}\n`;
    statsMessage += `â€¢ PrecisiÃ³n: ${accuracy.toFixed(1)}%\n`;
    
    if (avgResponseTime > 0) {
      statsMessage += `â€¢ Tiempo promedio: ${avgResponseTime.toFixed(1)}s\n`;
    }
    
    // Mostrar estadÃ­sticas por categorÃ­a (las primeras 3)
    const categoryEntries = Object.entries(categoryStats)
      .sort(([,a], [,b]) => b.total - a.total)
      .slice(0, 3);
    
    if (categoryEntries.length > 0) {
      statsMessage += `\nğŸ“š <b>POR CATEGORÃAS (TOP 3):</b>\n`;
      categoryEntries.forEach(([category, stats]) => {
        const categoryAccuracy = stats.total > 0 ? (stats.correct / stats.total * 100) : 0;
        statsMessage += `â€¢ ${category}: ${stats.correct}/${stats.total} (${categoryAccuracy.toFixed(1)}%)\n`;
      });
    }
    
    // Racha actual (Ãºltimas 10 respuestas)
    const recent10 = userResponses.slice(0, 10);
    const currentStreak = calculateCurrentStreak(recent10.map((r: any) => r.iscorrect));
    
    if (currentStreak > 0) {
      statsMessage += `\nğŸ”¥ <b>RACHA ACTUAL:</b> ${currentStreak} respuestas correctas`;
    }
    
    statsMessage += `\n\nğŸ¯ <code>/examen2024</code> - Practicar mÃ¡s\nğŸ“Š <code>/ranking</code> - Ver ranking general`;
    
    return statsMessage;
    
  } catch (error) {
    console.error('âŒ Error en handleExamen2024StatsCommand:', error);
    return `âŒ <b>ERROR OBTENIENDO ESTADÃSTICAS</b>\n\nHubo un problema procesando tus estadÃ­sticas del examen 2024.\nContacta al administrador si persiste.`;
  }
}

// FunciÃ³n para manejar comando /simulacro2024 - Iniciar simulacro del examen oficial 2024
async function handleSimulacro2024Command(userid: string, fromtelegramuser: any): Promise<string | null> {
  try {
    console.log('ğŸ¯ SIMULACRO2024 - Para usuario:', fromtelegramuser.first_name);
    
    // Verificar si puede iniciar simulacro
    const canStart = await Simulacro2024Service.canStartSimulacro(userid);
    if (!canStart.canStart) {
      const reason = canStart.reason || 'No se puede iniciar el simulacro';
      return `âŒ <b>NO PUEDES INICIAR SIMULACRO 2024</b>

${reason}

ğŸ’¡ <b>OPCIONES DISPONIBLES:</b>
${reason.includes('progreso') ? 
  'â–¶ï¸ <code>/simulacro_continuar</code> - Continuar simulacro actual\nğŸšª <code>/simulacro_abandonar</code> - Abandonar simulacro actual' : 
  'ğŸ¯ <code>/examen2024</code> - Preguntas individuales del 2024\nğŸ¯ <code>/examen2018</code> - Preguntas del examen 2018'
}`;
    }
    
    // Iniciar simulacro
    const result = await Simulacro2024Service.startSimulacro(userid);
    if (!result) {
      return `âŒ <b>ERROR INICIANDO SIMULACRO 2024</b>

No se pudo iniciar el simulacro. IntÃ©ntalo de nuevo en unos minutos.`;
    }
    
    const { simulacro, firstQuestion } = result;
    
    console.log('ğŸ¯ SIMULACRO2024 INICIADO:', {
      simulacroid: simulacro.id,
      firstquestionnumber: firstQuestion.questionnumber
    });
    
    // Enviar primera pregunta
    const pollHeader = `ğŸ¯ SIMULACRO EXAMEN 2024 - Pregunta ${firstQuestion.questionnumber}/100\nâ° Tiempo lÃ­mite: 3 horas\n\n`;
    const pollQuestion = truncatePollQuestion(pollHeader, firstQuestion.question);
    
    const success = await sendTelegramPoll(
      fromtelegramuser.id,
      pollQuestion,
      firstQuestion.options,
      firstQuestion.correctanswerindex,
      firstQuestion.id,
      'simulacro2024'
    );
    
    if (!success) {
      // Si falla el envÃ­o, marcar simulacro como abandonado
      await prisma.simulacro.update({
        where: { id: simulacro.id },
        data: { status: 'abandoned' }
      });
      
      return `âŒ <b>ERROR ENVIANDO PREGUNTA</b>

No se pudo enviar la primera pregunta del simulacro. IntÃ©ntalo de nuevo.`;
    }
    
    return `ğŸ¯ <b>SIMULACRO EXAMEN 2024 INICIADO</b>

ğŸ“‹ <b>INFORMACIÃ“N DEL SIMULACRO:</b>
ğŸ“ Preguntas: 100 (del examen oficial 2024)
â° Tiempo lÃ­mite: 3 horas
ğŸ¯ Para aprobar: â‰¥50 respuestas correctas

ğŸ“Š <b>PRIMERA PREGUNTA ENVIADA</b>
Responde el poll que acabas de recibir.

ğŸ’¡ <b>COMANDOS ÃšTILES:</b>
â–¶ï¸ <code>/simulacro_continuar</code> - Si pierdes el hilo
ğŸšª <code>/simulacro_abandonar</code> - Para abandonar

ğŸ€ <b>Â¡Buena suerte con el Examen 2024!</b>`;
    
  } catch (error) {
    console.error('âŒ Error en simulacro2024:', error);
    return `âŒ <b>Error iniciando simulacro 2024</b>

Ha ocurrido un error. IntÃ©ntalo de nuevo en unos minutos.`;
  }
}

// FunciÃ³n para manejar comando /ranking_oficial2018 - Ranking especÃ­fico del examen 2018
async function handleRankingOficial2018Command(userid: string, fromtelegramuser: any): Promise<string | null> {
  try {
    console.log('ğŸ† RANKING_OFICIAL2018 COMMAND - Ranking especÃ­fico del examen 2018');
    
    // Obtener ranking especÃ­fico del examen 2018
    const ranking = await ExamRankingService.getExam2018Ranking(10);
    
    if (!ranking || ranking.length === 0) {
      return `âŒ <b>No hay datos disponibles</b>

ğŸ“Š El ranking del examen oficial 2018 no tiene datos suficientes aÃºn.

ğŸ’¡ <b>Para aparecer en el ranking:</b>
â€¢ Usa <code>/simulacro</code> para practicar
â€¢ Responde preguntas del examen 2018

ğŸ¯ <code>/examen2018</code> - Practicar mÃ¡s`;
    }
    
    return formatExamRanking(ranking, '2018');
    
  } catch (error) {
    console.error('âŒ Error en ranking_oficial2018:', error);
    return `âŒ <b>Error obteniendo ranking</b>

Hubo un problema al obtener el ranking especÃ­fico del examen 2018. IntÃ©ntalo de nuevo en unos minutos.`;
  }
}

// FunciÃ³n para manejar comando /ranking_oficial2024 - Ranking especÃ­fico del examen 2024
async function handleRankingOficial2024Command(userid: string, fromtelegramuser: any): Promise<string | null> {
  try {
    console.log('ğŸ† RANKING_OFICIAL2024 COMMAND - Ranking especÃ­fico del examen 2024');
    
    // Obtener ranking especÃ­fico del examen 2024
    const ranking = await ExamRankingService.getExam2024Ranking(10);
    
    if (!ranking || ranking.length === 0) {
      return `âŒ <b>No hay datos disponibles</b>

ğŸ“Š El ranking del examen oficial 2024 no tiene datos suficientes aÃºn.

ğŸ’¡ <b>Para aparecer en el ranking:</b>
â€¢ Usa <code>/simulacro2024</code> para practicar
â€¢ Responde preguntas del examen 2024

ğŸ¯ <code>/examen2024</code> - Practicar mÃ¡s`;
    }
    
    return formatExamRanking(ranking, '2024');
    
  } catch (error) {
    console.error('âŒ Error en ranking_oficial2024:', error);
    return `âŒ <b>Error obteniendo ranking</b>

Hubo un problema al obtener el ranking especÃ­fico del examen 2024. IntÃ©ntalo de nuevo en unos minutos.`;
  }
}

// FunciÃ³n para manejar comando /comparativa_examenes - Comparativa personal entre exÃ¡menes
async function handleComparativaExamenesCommand(userid: string, fromtelegramuser: any): Promise<string | null> {
  try {
    console.log('ğŸ“Š COMPARATIVA_EXAMENES COMMAND - Comparativa personal entre exÃ¡menes');
    
    // Obtener comparativa personal de ambos exÃ¡menes
    const comparison = await ExamRankingService.getUserExamComparison(userid);
    
    if (!comparison) {
      return `âŒ <b>Error obteniendo comparaciÃ³n</b>

Hubo un problema al obtener la comparaciÃ³n entre los exÃ¡menes. IntÃ©ntalo de nuevo en unos minutos.`;
    }
    
    return formatExamComparison(comparison, fromtelegramuser.first_name || fromtelegramuser.username || 'Usuario');
    
  } catch (error) {
    console.error('âŒ Error en comparativa_examenes:', error);
    return `âŒ <b>Error obteniendo comparaciÃ³n</b>

Hubo un problema al obtener la comparaciÃ³n entre los exÃ¡menes. IntÃ©ntalo de nuevo en unos minutos.`;
  }
}

// FunciÃ³n para manejar comando /simulacro_oficial - Selector de simulacro oficial
async function handleSimulacroOficialCommand(userid: string, fromtelegramuser: any): Promise<string | null> {
  try {
    console.log('ğŸ¯ SIMULACRO_OFICIAL COMMAND - Selector de simulacro oficial');
    
    return `ğŸ¯ <b>SELECCIONA TU SIMULACRO OFICIAL</b> ğŸ¯

ğŸ“‹ <b>ExÃ¡menes oficiales disponibles:</b>

ğŸ¥‡ <b>EXAMEN 2018</b>
â€¢ 100 preguntas del examen oficial
â€¢ Tiempo: 3 horas (180 minutos)
â€¢ Comando: <code>/simulacro</code>

ğŸ¥ˆ <b>EXAMEN 2024</b>
â€¢ 100 preguntas del examen oficial
â€¢ Tiempo: 3 horas (180 minutos)
â€¢ Comando: <code>/simulacro2024</code>

ğŸ“Š <b>COMPARAR TUS RESULTADOS:</b>
â€¢ <code>/comparativa_examenes</code> - Tu rendimiento en ambos

ğŸ† <b>VER RANKINGS:</b>
â€¢ <code>/ranking_oficial2018</code> - Mejores del 2018
â€¢ <code>/ranking_oficial2024</code> - Mejores del 2024

ğŸ’¡ <b>Â¿CuÃ¡l prefieres practicar?</b>`;
    
  } catch (error) {
    console.error('âŒ Error en simulacro_oficial:', error);
    return `âŒ <b>Error obteniendo selector</b>

Hubo un problema al obtener el selector de simulacro oficial. IntÃ©ntalo de nuevo en unos minutos.`;
  }
}

// FunciÃ³n para formatear ranking especÃ­fico de exÃ¡men
function formatExamRanking(ranking: any[], examYear: string): string {
  let message = `ğŸ† <b>RANKING OFICIAL ${examYear}</b> ğŸ†\n\n`;
  
  ranking.forEach((entry, index) => {
    const medal = index === 0 ? 'ğŸ¥‡' : index === 1 ? 'ğŸ¥ˆ' : index === 2 ? 'ğŸ¥‰' : 'ğŸ”¸';
    const name = entry.user.username || entry.user.firstName || 'Usuario';
    
    message += `${medal} <b>${entry.rank}.</b> ${name}\n`;
    message += `   ğŸ“Š ${entry.correctanswers}/${entry.totalQuestions} correctas (${Math.round(entry.accuracy)}%)\n`;
    message += `   â±ï¸ Tiempo promedio: ${Math.round(entry.averageTime)}s\n`;
    message += `   ğŸ“… Ãšltimo intento: ${entry.lastAttempt.toLocaleDateString()}\n\n`;
  });

  message += `ğŸ¯ <b>Â¡Usa /simulacro${examYear === '2024' ? '2024' : ''} para mejorar tu posiciÃ³n!</b>`;

  return message;
}

// FunciÃ³n para formatear comparativa de exÃ¡menes
function formatExamComparison(comparison: any, userName: string): string {
  let message = `ğŸ“Š <b>COMPARATIVA DE EXÃMENES</b>\n`;
  message += `ğŸ‘¤ ${userName}\n\n`;
  
  // Examen 2018
  message += `ğŸ¥‡ <b>EXAMEN 2018:</b>\n`;
  if (comparison.exam2018.attempted) {
    message += `   ğŸ“Š ${comparison.exam2018.correctanswers}/${comparison.exam2018.totalQuestions} correctas (${Math.round(comparison.exam2018.accuracy)}%)\n`;
    message += `   â±ï¸ Tiempo promedio: ${Math.round(comparison.exam2018.averageTime)}s\n`;
    if (comparison.exam2018.rank) {
      message += `   ğŸ† PosiciÃ³n en ranking: #${comparison.exam2018.rank}\n`;
    }
    message += `   ğŸ“… Ãšltimo intento: ${comparison.exam2018.lastAttempt?.toLocaleDateString() || 'N/A'}\n`;
  } else {
    message += `   âŒ No has intentado este examen\n`;
  }
  
  message += `\nğŸ¥ˆ <b>EXAMEN 2024:</b>\n`;
  if (comparison.exam2024.attempted) {
    message += `   ğŸ“Š ${comparison.exam2024.correctanswers}/${comparison.exam2024.totalQuestions} correctas (${Math.round(comparison.exam2024.accuracy)}%)\n`;
    message += `   â±ï¸ Tiempo promedio: ${Math.round(comparison.exam2024.averageTime)}s\n`;
    if (comparison.exam2024.rank) {
      message += `   ğŸ† PosiciÃ³n en ranking: #${comparison.exam2024.rank}\n`;
    }
    message += `   ğŸ“… Ãšltimo intento: ${comparison.exam2024.lastAttempt?.toLocaleDateString() || 'N/A'}\n`;
  } else {
    message += `   âŒ No has intentado este examen\n`;
  }
  
  // Resumen general
  message += `\nğŸ“ˆ <b>RESUMEN GENERAL:</b>\n`;
  message += `   ğŸ¯ Total preguntas: ${comparison.overall.totalQuestions}\n`;
  message += `   ğŸ“Š PrecisiÃ³n global: ${Math.round(comparison.overall.globalAccuracy)}%\n`;
  
  if (comparison.overall.strongerExam !== 'equal') {
    const stronger = comparison.overall.strongerExam === '2024' ? 'EXAMEN 2024' : 'EXAMEN 2018';
    const icon = comparison.overall.strongerExam === '2024' ? 'ğŸš€' : 'ğŸ“ˆ';
    message += `   ${icon} Tu fuerte: ${stronger}\n`;
  }
  
  if (Math.abs(comparison.overall.improvement) > 1) {
    const icon = comparison.overall.improvement > 0 ? 'ğŸ“ˆ' : 'ğŸ“‰';
    const direction = comparison.overall.improvement > 0 ? 'mejora' : 'disminuciÃ³n';
    message += `   ${icon} ${direction}: ${Math.abs(Math.round(comparison.overall.improvement))}%\n`;
  }
  
  message += `\nğŸ’¡ <b>Comandos Ãºtiles:</b>\n`;
  message += `â€¢ <code>/simulacro</code> - Practicar 2018\n`;
  message += `â€¢ <code>/simulacro2024</code> - Practicar 2024\n`;
  message += `â€¢ <code>/ranking_oficial2018</code> - Ver ranking 2018\n`;
  message += `â€¢ <code>/ranking_oficial2024</code> - Ver ranking 2024`;
  
  return message;
}

// ğŸ†• NUEVO: FunciÃ³n para manejar nuevos miembros
async function handleNewChatMembers(message: any): Promise<NextResponse> {
  try {
    const chatId = message.chat.id;
    const chatType = message.chat.type;
    const newMembers = message.new_chat_members;

    // Solo procesar en grupos/supergrupos
    if (chatType !== 'group' && chatType !== 'supergroup') {
      console.log('ğŸ‘‹ NUEVOS MIEMBROS - Ignorado: no es un grupo');
      return NextResponse.json({ ok: true, message: 'No es grupo' });
    }

    console.log('ğŸ‘‹ NUEVOS MIEMBROS - Procesando:', {
      chatId,
      chatType,
      memberCount: newMembers.length,
      members: newMembers.map((member: any) => ({
        id: member.id,
        firstName: member.first_name,
        username: member.username,
        isBot: member.is_bot
      }))
    });

    // Filtrar solo usuarios humanos (no bots)
    const humanMembers = newMembers.filter((member: any) => !member.is_bot);

    if (humanMembers.length === 0) {
      console.log('ğŸ‘‹ NUEVOS MIEMBROS - Solo bots detectados, ignorando');
      return NextResponse.json({ ok: true, message: 'Solo bots' });
    }

    // Crear mensaje de bienvenida personalizado
    const memberNames = humanMembers.map((member: any) => 
      member.first_name || member.username || 'Usuario'
    ).join(', ');

    const welcomeMessage = `ğŸ‰ Â¡Bienvenid${humanMembers.length > 1 ? 'os' : 'o'} al sistema de gamificaciÃ³n OpoMelilla!

ğŸ‘‹ Â¡Hola ${memberNames}!

ğŸ¯ <b>PASOS IMPORTANTES PARA EMPEZAR:</b>

1ï¸âƒ£ <b>Configura el bot privado:</b>
   â€¢ Busca <code>@OpoMelillaBot</code> en Telegram
   â€¢ EnvÃ­a <code>/start</code> al bot
   â€¢ Â¡Solo toma 30 segundos!

2ï¸âƒ£ <b>Â¿Por quÃ© es necesario?</b>
   â€¢ Para recibir notificaciones privadas
   â€¢ Para participar en duelos
   â€¢ Para quiz interactivos sin spam en grupo
   â€¢ Para gestionar tu perfil y estadÃ­sticas

ğŸ® <b>COMANDOS PRINCIPALES:</b>
â€¢ <code>/ranking</code> - Ver clasificaciÃ³n general
â€¢ <code>/stats</code> - Consultar tus estadÃ­sticas
â€¢ <code>/duelo @usuario</code> - Retar a duelos
â€¢ <code>/examen2024</code> - Quiz del examen oficial
â€¢ <code>/simulacro</code> - Simulacro completo

âš ï¸ <b>IMPORTANTE:</b> 
Primero debes interactuar con <code>@OpoMelillaBot</code> en privado para que funcionen todos los comandos del grupo.

ğŸ† <b>SISTEMA DE PUNTOS:</b>
â€¢ âœ… Respuesta correcta: 10 puntos
â€¢ âŒ Respuesta incorrecta: Resta puntos dependiendo el nivel  
â€¢ ğŸ”¥ Bonus velocidad: +5 pts (&lt; 30s)
â€¢ âš¡ Bonus ultra rÃ¡pido: +10 pts (&lt; 10s)

ğŸ’¡ <b>Â¡Responde preguntas, mantÃ©n rachas diarias y compite por el primer lugar!</b>

ğŸš€ Â¡Que comience la diversiÃ³n!`;

    // Enviar mensaje de bienvenida
    const result = await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/sendMessage`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        chat_id: chatid,
        text: welcomeMessage,
        parse_mode: 'HTML',
        disable_web_page_preview: true
      }),
    });

    const responseData = await result.json();

    if (responseData.ok) {
      console.log('âœ… NUEVOS MIEMBROS - Mensaje de bienvenida enviado exitosamente');
      
      // Opcional: Programar borrado del mensaje despuÃ©s de 5 minutos para evitar spam
      setTimeout(async () => {
        try {
          await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/deleteMessage`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              chat_id: chatid,
              message_id: responseData.result.message_id
            })
          });
          console.log('ğŸ—‘ï¸ Mensaje de bienvenida eliminado despuÃ©s de 5 minutos');
        } catch (error) {
          console.log('âš ï¸ No se pudo eliminar el mensaje de bienvenida:', error);
        }
      }, 5 * 60 * 1000); // 5 minutos

    } else {
      console.error('âŒ NUEVOS MIEMBROS - Error enviando mensaje:', responseData);
    }

    return NextResponse.json({ 
      ok: true, 
      message: 'Nuevos miembros procesados',
      membersWelcomed: humanMembers.length
    });

  } catch (error) {
    console.error('âŒ NUEVOS MIEMBROS - Error general:', error);
    return NextResponse.json({ 
      ok: false, 
      error: 'Error procesando nuevos miembros' 
    });
  }
}

// ğŸ† SISTEMA DE TORNEOS - FUNCIONES DE MANEJO
// ===============================================

async function handleTorneoCommand(userid: string, fromtelegramuser: any, messageText: string): Promise<string | null> {
  try {
    console.log('ğŸ† TORNEO COMMAND - Procesando:', { userid, messageText });

    // Verificar si el usuario existe en la base de datos
    const user = await prisma.telegramuser.findUnique({
      where: { telegramUserId: userid }
    });

    if (!user) {
      return `âŒ <b>Usuario no registrado</b>\n\nğŸ”§ <b>SoluciÃ³n:</b>\n1. EnvÃ­a <code>/start</code> al bot privado\n2. Luego usa <code>/torneo</code> nuevamente\n\nğŸ’¡ <b>Tip:</b> Necesitas estar registrado para participar en torneos.`;
    }

    // Verificar puntos mÃ­nimos para participar (10 puntos)
    if ((user.totalpoints || 0) < 10) {
      return `âš ï¸ <b>Puntos insuficientes para torneos</b>\n\nğŸ’° <b>Tu situaciÃ³n:</b>\nâ€¢ Puntos actuales: ${user.totalpoints || 0}\nâ€¢ Puntos requeridos: 10\n\nğŸ¯ <b>Â¿CÃ³mo conseguir puntos?</b>\nâ€¢ <code>/examen2024</code> - Quiz oficial (+10 pts)\nâ€¢ <code>/simulacro</code> - Simulacro completo (+50 pts)\nâ€¢ Responder preguntas en el grupo (+10 pts)\n\nğŸ’¡ <b>Â¡Gana puntos y vuelve a intentarlo!</b>`;
    }

    await TournamentService.getInstance().ensureTournamentManagerRunning();
    
    // Obtener todos los torneos desde la base de datos
    const allTournaments = await TournamentService.getInstance().getTournamentList(user.id);

    if (allTournaments.length === 0) {
      return `ğŸ† <b>SISTEMA DE TORNEOS</b>\n\n` +
             `âš ï¸ <b>No hay torneos disponibles ahora mismo</b>\n\n` +
             `ğŸ• Los torneos se crean automÃ¡ticamente cada hora\n` +
             `ğŸ“… PrÃ³ximo torneo: Consulta en unos minutos\n\n` +
             `ğŸ’¡ <b>Comandos Ãºtiles:</b>\n` +
             `â€¢ <code>/torneos</code> - Ver lista completa\n` +
             `â€¢ <code>/torneo_historial</code> - Tu historial`;
    }

    // ğŸ“… FILTRAR SOLO TORNEOS DE LA SEMANA ACTUAL
    const now = new Date();
    const startOfWeek = new Date(now);
    startOfWeek.setDate(now.getDate() - now.getDay()); // Inicio de la semana (domingo)
    startOfWeek.setHours(0, 0, 0, 0);
    
    const endOfWeek = new Date(startOfWeek);
    endOfWeek.setDate(startOfWeek.getDate() + 6); // Final de la semana (sÃ¡bado)
    endOfWeek.setHours(23, 59, 59, 999);

    // Filtrar torneos de esta semana que estÃ©n programados o en progreso
    const availableTournaments = allTournaments.filter(tournament => {
      const tournamentDate = new Date(tournament.scheduleddate);
      const isInWeek = tournamentDate >= startOfWeek && tournamentDate <= endOfWeek;
      const isAvailable = tournament.status === 'SCHEDULED' || tournament.status === 'IN_PROGRESS';
      return isInWeek && isAvailable;
    });

    if (availableTournaments.length === 0) {
      return `ğŸ† <b>TORNEOS DISPONIBLES</b>\n\n` +
             `ğŸ“… <b>No hay torneos disponibles esta semana</b>\n\n` +
             `ğŸ”® <b>PrÃ³ximos torneos:</b>\n` +
             `â€¢ Los torneos se crean automÃ¡ticamente\n` +
             `â€¢ Nuevos horarios: 10:30, 16:00, 20:00\n` +
             `â€¢ Martes, Jueves, SÃ¡bados y Domingos\n\n` +
             `ğŸ’¡ <b>Comandos Ãºtiles:</b>\n` +
             `â€¢ <code>/torneos</code> - Ver lista completa de la semana\n` +
             `â€¢ <code>/torneo_historial</code> - Tu historial\n\n` +
             `â„¹ï¸ <i>Solo se muestran torneos disponibles de esta semana</i>`;
    }

    let message = `ğŸ† <b>TORNEOS DISPONIBLES</b>\n`;
    message += `ğŸ“… ${startOfWeek.toLocaleDateString('es-ES')} - ${endOfWeek.toLocaleDateString('es-ES')}\n\n`;
    
    availableTournaments.forEach((tournament, index) => {
      const date = new Date(tournament.scheduleddate);
      const timeStr = date.toLocaleTimeString('es-ES', { hour: '2-digit', minute: '2-digit' });
      const status = tournament.status === 'SCHEDULED' ? 'â° Programado' : 'ğŸ”¥ En curso';
      
      message += `${index + 1}. <b>${tournament.name}</b>\n`;
      message += `   ğŸ“… ${timeStr} | ${status}\n`;
      message += `   ğŸ‘¥ ${tournament._count.participants} | ğŸ’° ${tournament.prizepool || 100} pts\n`;
      message += `   ğŸ“ ${tournament.questionsCount} preguntas\n`;
      message += `   ğŸ« <code>/torneo_unirse ${index + 1}</code>\n\n`;
    });

    message += `ğŸ’¡ <b>CÃ³mo participar:</b>\n`;
    message += `1. Usa <code>/torneo_unirse [nÃºmero]</code>\n`;
    message += `2. Â¡Espera a que inicie el torneo!\n`;
    message += `3. Responde las preguntas rÃ¡pidamente\n\n`;
    message += `âš¡ <b>Respuesta instantÃ¡nea:</b> En cuanto respondas, recibes la siguiente pregunta\n\n`;
    message += `â„¹ï¸ <i>Solo se muestran torneos disponibles de esta semana</i>`;

    return message;

  } catch (error) {
    console.error('âŒ Error en handleTorneoCommand:', error);
    return `âŒ <b>Error interno</b>\n\nIntÃ©ntalo de nuevo en unos segundos.`;
  }
}

async function handleTorneosListCommand(userid: string, fromtelegramuser: any): Promise<string | null> {
  try {
    console.log('ğŸ† TORNEOS LIST COMMAND - Procesando:', { userid });

    // Obtener todos los torneos usando el servicio
    const allTournaments = await TournamentService.getInstance().getTournamentList(userid);

    if (allTournaments.length === 0) {
      return `ğŸ† <b>No hay torneos registrados</b>\n\nğŸ’¡ Â¡SÃ© el primero en crear actividad competitiva!`;
    }

    // ğŸ“… FILTRAR SOLO TORNEOS DE LA SEMANA ACTUAL
    const now = new Date();
    const startOfWeek = new Date(now);
    startOfWeek.setDate(now.getDate() - now.getDay()); // Inicio de la semana (domingo)
    startOfWeek.setHours(0, 0, 0, 0);
    
    const endOfWeek = new Date(startOfWeek);
    endOfWeek.setDate(startOfWeek.getDate() + 6); // Final de la semana (sÃ¡bado)
    endOfWeek.setHours(23, 59, 59, 999);

    // Filtrar torneos de esta semana
    const tournaments = allTournaments.filter(tournament => {
      const tournamentDate = new Date(tournament.scheduleddate);
      return tournamentDate >= startOfWeek && tournamentDate <= endOfWeek;
    });

    if (tournaments.length === 0) {
      return `ğŸ† <b>TORNEOS DE ESTA SEMANA</b>\n\n` +
             `ğŸ“… <b>No hay torneos programados para esta semana</b>\n\n` +
             `ğŸ”® <b>PrÃ³xima semana:</b>\n` +
             `â€¢ Los torneos continÃºan automÃ¡ticamente\n` +
             `â€¢ Nuevos horarios: 10:30, 16:00, 20:00\n` +
             `â€¢ Martes, Jueves, SÃ¡bados y Domingos\n\n` +
             `ğŸ’¡ <b>Comandos Ãºtiles:</b>\n` +
             `â€¢ <code>/torneo</code> - Ver torneos disponibles\n` +
             `â€¢ <code>/torneo_historial</code> - Tu historial`;
    }

    let message = `ğŸ† <b>TORNEOS DE ESTA SEMANA</b>\n`;
    message += `ğŸ“… ${startOfWeek.toLocaleDateString('es-ES')} - ${endOfWeek.toLocaleDateString('es-ES')}\n\n`;

    const scheduled = tournaments.filter(t => t.status === 'SCHEDULED');
    const inProgress = tournaments.filter(t => t.status === 'IN_PROGRESS');
    const completed = tournaments.filter(t => t.status === 'COMPLETED').slice(0, 3);

    // Torneos programados
    if (scheduled.length > 0) {
      message += `â° <b>PRÃ“XIMOS TORNEOS:</b>\n`;
      scheduled.forEach((tournament, index) => {
        const timeUntilStart = tournament.scheduleddate.getTime() - now.getTime();
        const minutesUntilStart = Math.ceil(timeUntilStart / (1000 * 60));
        const participantCount = tournament._count.participants;

        message += `${index + 1}ï¸âƒ£ ${tournament.name}\n`;
        message += `   ğŸ“… ${tournament.scheduleddate.toLocaleString('es-ES')}\n`;
        message += `   â° En ${minutesUntilStart > 0 ? `${minutesUntilStart} min` : 'Â¡Ya!'}\n`;
        message += `   ğŸ‘¥ ${participantCount}/${tournament.maxparticipants} participantes\n\n`;
      });
    }

    // Torneos en progreso
    if (inProgress.length > 0) {
      message += `ğŸ”¥ <b>EN PROGRESO:</b>\n`;
      inProgress.forEach((tournament) => {
        const participantCount = tournament._count.participants;
        
        message += `ğŸ¯ ${tournament.name}\n`;
        message += `   ğŸ‘¥ ${participantCount} participantes activos\n`;
        message += `   ğŸ“Š Estado: En desarrollo\n\n`;
      });
    }

    // Torneos recientes completados
    if (completed.length > 0) {
      message += `ğŸ <b>RECIENTES COMPLETADOS:</b>\n`;
      completed.forEach((tournament) => {
        const participantCount = tournament._count.participants;
        
        message += `âœ… ${tournament.name}\n`;
        message += `   ğŸ“… ${tournament.scheduleddate.toLocaleDateString('es-ES')}\n`;
        message += `   ğŸ‘¥ ${participantCount} participantes\n`;
        message += `   ğŸ† Premio: ${tournament.prizepool} pts\n\n`;
      });
    }

    message += `ğŸ“Š <b>RESUMEN SEMANAL:</b>\n`;
    message += `â€¢ Programados: ${scheduled.length}\n`;
    message += `â€¢ En progreso: ${inProgress.length}\n`;
    message += `â€¢ Completados: ${completed.length}\n\n`;

    message += `ğŸ® <b>COMANDOS:</b>\n`;
    message += `â€¢ <code>/torneo</code> - Unirse a torneo disponible\n`;
    message += `â€¢ <code>/torneo_historial</code> - Tu historial completo\n`;
    message += `â€¢ <code>/ranking</code> - Ver clasificaciÃ³n general\n\n`;

    message += `â„¹ï¸ <i>Solo se muestran torneos de esta semana</i>`;

    return message;

  } catch (error) {
    console.error('âŒ Error en handleTorneosListCommand:', error);
    return `âŒ <b>Error interno</b>\n\nIntÃ©ntalo de nuevo en unos segundos.`;
  }
}

async function handleTorneoJoinCommand(userid: string, fromtelegramuser: any, messageText: string): Promise<string | null> {
  try {
    console.log('ğŸ† TORNEO JOIN COMMAND - Procesando:', { userid, messageText });

    // Extraer nÃºmero del torneo
    const match = messageText.match(/\/torneo_unirse\s+(\d+)/);
    if (!match) {
      return `âŒ <b>Formato incorrecto</b>

ğŸ”§ <b>Uso correcto:</b>
<code>/torneo_unirse [nÃºmero]</code>

ğŸ’¡ <b>Ejemplo:</b>
<code>/torneo_unirse 1</code> - Unirse al primer torneo

â„¹ï¸ Usa <code>/torneo</code> para ver torneos disponibles con nÃºmeros.`;
    }

    const tournamentNumber = parseInt(match[1]);

    // Verificar usuario
    const user = await prisma.telegramuser.findUnique({
      where: { telegramUserId: userid }
    });

    if (!user) {
      return `âŒ <b>Usuario no registrado</b>\n\nğŸ”§ EnvÃ­a <code>/start</code> al bot privado primero.`;
    }

    // Verificar puntos mÃ­nimos
    if ((user.totalpoints || 0) < 10) {
      return `âš ï¸ <b>Puntos insuficientes</b>\n\nNecesitas al menos 10 puntos para participar.\nPuntos actuales: ${user.totalpoints || 0}`;
    }

    // Obtener torneos disponibles
    const availableTournaments = await TournamentService.getInstance().getTournamentList(user.id);

    if (availableTournaments.length === 0) {
      return `âŒ <b>No hay torneos disponibles</b>\n\nğŸ’¡ Usa <code>/torneos</code> para ver el estado actual.`;
    }

    if (tournamentNumber < 1 || tournamentNumber > availableTournaments.length) {
      return `âŒ <b>NÃºmero de torneo invÃ¡lido</b>

ğŸ“Š <b>Torneos disponibles:</b> 1 a ${availableTournaments.length}

ğŸ’¡ Usa <code>/torneo</code> para ver la lista con nÃºmeros.`;
    }

    const selectedTournament = availableTournaments[tournamentNumber - 1];

    // Verificar si el torneo estÃ¡ lleno
    const maxParticipants = selectedTournament.maxparticipants || 100; // Default 100 si es null
    if (selectedTournament._count.participants >= maxParticipants) {
      return `âŒ <b>Torneo lleno</b>

ğŸ† <b>Torneo:</b> ${selectedTournament.name}
ğŸ‘¥ <b>Participantes:</b> ${selectedTournament._count.participants}/${maxParticipants}

ğŸ’¡ Prueba con otro torneo usando <code>/torneo</code>.`;
    }

    // Verificar si el torneo estÃ¡ muy cerca del inicio (menos de 2 minutos)
    const timeUntilStart = selectedTournament.scheduleddate.getTime() - Date.now();
    const minutesUntilStart = Math.floor(timeUntilStart / (1000 * 60));
    const secondsUntilStart = Math.floor(timeUntilStart / 1000);

    // Si faltan menos de 2 minutos (120 segundos), cerrar inscripciones
    if (secondsUntilStart < 120) {
      const displayMinutes = Math.max(0, minutesUntilStart);
      return `â° <b>Demasiado tarde</b>

ğŸ† <b>Torneo:</b> ${selectedTournament.name}
â° <b>Inicio:</b> En ${displayMinutes} minuto(s)

âŒ Las inscripciones se cierran 2 minutos antes del inicio.

ğŸ’¡ Usa <code>/torneo</code> para ver otros torneos disponibles.`;
    }

    // Intentar unirse al torneo usando el servicio
    const joinResult = await TournamentService.getInstance().joinTournament(selectedTournament.id, user.id);

    if (!joinResult.success) {
      return `âŒ <b>No se pudo unir al torneo</b>\n\n${joinResult.message}`;
    }

    // Actualizar contador de participantes
    const updatedCount = selectedTournament._count.participants + 1;
    const spotsLeft = maxParticipants - updatedCount;

    const successMessage = `âœ… <b>Â¡Registrado exitosamente!</b>

ğŸ† <b>Torneo:</b> ${selectedTournament.name}
ğŸ“ <b>DescripciÃ³n:</b> ${selectedTournament.description}
ğŸ“… <b>Inicio:</b> ${selectedTournament.scheduleddate.toLocaleString('es-ES')}
â° <b>En:</b> ${minutesUntilStart} minutos
ğŸ¯ <b>Preguntas:</b> ${selectedTournament.questionsCount}
ğŸ’° <b>Premios por posiciÃ³n:</b>
   ğŸ¥‡ 1Â° lugar: 100 puntos
   ğŸ¥ˆ 2Â° lugar: 90 puntos  
   ğŸ¥‰ 3Â° lugar: 80 puntos
   ğŸ“Š 4Â° lugar y siguientes: decreciente
ğŸ‘¥ <b>Participantes:</b> ${updatedCount}/${maxParticipants}

${spotsLeft <= 3 && spotsLeft > 0 ? `ğŸ”¥ Â¡Solo quedan ${spotsLeft} lugares!` : ''}
${spotsLeft === 0 ? 'ğŸ‰ Â¡Torneo completo!' : ''}

ğŸ® <b>SIGUIENTE PASO:</b>
Espera al inicio del torneo. RecibirÃ¡s las preguntas automÃ¡ticamente en privado.

ğŸ’¡ <b>Comandos Ãºtiles:</b>
â€¢ <code>/torneo_salir</code> - Salir del torneo (si no ha iniciado)
â€¢ <code>/torneos</code> - Ver otros torneos

ğŸ€ Â¡Buena suerte!`;

    console.log('âœ… Usuario registrado en torneo:', {
      userid,
      tournamentId: selectedTournament.id,
      joinResult: joinResult.success
    });

    return successMessage;

  } catch (error) {
    console.error('âŒ Error en handleTorneoJoinCommand:', error);
    return `âŒ <b>Error interno</b>\n\nIntÃ©ntalo de nuevo en unos segundos.`;
  }
}

async function handleTorneoLeaveCommand(userid: string, fromtelegramuser: any, messageText: string): Promise<string | null> {
  try {
    console.log('ğŸ† TORNEO LEAVE COMMAND - Procesando:', { userid });

    // Verificar usuario
    const user = await prisma.telegramuser.findUnique({
      where: { telegramUserId: userid }
    });

    if (!user) {
      return `âŒ <b>Usuario no registrado</b>\n\nğŸ”§ EnvÃ­a <code>/start</code> al bot privado primero.`;
    }

    // Intentar salir usando el servicio (simplificado por ahora)
    return `â„¹ï¸ <b>FunciÃ³n en desarrollo</b>

ğŸ”§ La funciÃ³n de salir del torneo estÃ¡ siendo actualizada.

ğŸ’¡ <b>Mientras tanto:</b>
â€¢ Usa <code>/torneo</code> para ver torneos disponibles
â€¢ Usa <code>/torneo_historial</code> para ver tu historial`;

  } catch (error) {
    console.error('âŒ Error en handleTorneoLeaveCommand:', error);
    return `âŒ <b>Error interno</b>\n\nIntÃ©ntalo de nuevo en unos segundos.`;
  }
}

async function handleTorneoHistoryCommand(userid: string, fromtelegramuser: any): Promise<string | null> {
  try {
    console.log('ğŸ† TORNEO HISTORY COMMAND - Procesando:', { userid });

    // Verificar usuario
    const user = await prisma.telegramuser.findUnique({
      where: { telegramUserId: userid }
    });

    if (!user) {
      return `âŒ <b>Usuario no registrado</b>\n\nğŸ”§ EnvÃ­a <code>/start</code> al bot privado primero.`;
    }

    // Obtener historial usando el servicio
    const participations = await TournamentService.getInstance().getUserTournamentHistory(user.id);

    if (participations.length === 0) {
      return `ğŸ“Š <b>Historial de Torneos</b>

ğŸ‘¤ <b>${user.firstName || user.username || 'Usuario'}</b>

âŒ <b>No has participado en torneos aÃºn</b>

ğŸ® <b>Â¡Comienza tu historia competitiva!</b>
â€¢ <code>/torneo</code> - Ver torneos disponibles
â€¢ <code>/torneos</code> - Lista completa de torneos

ğŸ’¡ <b>Los torneos te permiten:</b>
â€¢ Competir contra otros usuarios
â€¢ Ganar puntos extra
â€¢ Demostrar tu conocimiento
â€¢ Â¡Divertirte mientras estudias!`;
    }

    let message = `ğŸ“Š <b>HISTORIAL DE TORNEOS</b>\n\n`;
    message += `ğŸ‘¤ <b>${user.firstName || user.username || 'Usuario'}</b>\n\n`;

    // Calcular estadÃ­sticas generales
    const completed = participations.filter(p => p.status === 'COMPLETED');
    const inProgress = participations.filter(p => p.status === 'IN_PROGRESS');
    const registered = participations.filter(p => p.status === 'REGISTERED');
    
    const totalScore = completed.reduce((sum, p) => sum + (p.score || 0), 0);
    const totalCorrect = completed.reduce((sum, p) => sum + (p.correctanswers || 0), 0);
    const totalQuestions = completed.reduce((sum, p) => sum + p.responses.length, 0);
    const averageAccuracy = totalQuestions > 0 ? Math.round((totalCorrect / totalQuestions) * 100) : 0;

    message += `ğŸ“ˆ <b>ESTADÃSTICAS GENERALES:</b>\n`;
    message += `ğŸ† Torneos completados: ${completed.length}\n`;
    message += `â³ En progreso: ${inProgress.length}\n`;
    message += `ğŸ“ Registrado: ${registered.length}\n`;
    message += `ğŸ’° Puntos totales ganados: ${totalScore}\n`;
    message += `ğŸ¯ PrecisiÃ³n promedio: ${averageAccuracy}%\n\n`;

    // Mostrar Ãºltimos 5 torneos
    const recentParticipations = participations.slice(0, 5);

    message += `ğŸ“‹ <b>PARTICIPACIONES RECIENTES:</b>\n`;

    recentParticipations.forEach((participation, index) => {
      const tournament = participation.tournament;
      const status = participation.status;
      const score = participation.score || 0;
      const correctAnswers = participation.correctanswers || 0;
      const totalResponses = participation.responses.length;

      let statusEmoji = '';
      let statusText = '';

      switch (status) {
        case 'COMPLETED':
          statusEmoji = 'âœ…';
          statusText = 'Completado';
          break;
        case 'IN_PROGRESS':
          statusEmoji = 'â³';
          statusText = 'En progreso';
          break;
        case 'REGISTERED':
          statusEmoji = 'ğŸ“';
          statusText = 'Registrado';
          break;
        default:
          statusEmoji = 'â“';
          statusText = status;
      }

      message += `${index + 1}ï¸âƒ£ <b>${tournament.name}</b>\n`;
      message += `   ğŸ“… ${tournament.scheduleddate.toLocaleDateString('es-ES')}\n`;
      message += `   ${statusEmoji} Estado: ${statusText}\n`;
      
      if (status === 'COMPLETED') {
        message += `   ğŸ’° Puntos: ${score}\n`;
        message += `   ğŸ¯ Correctas: ${correctAnswers}/${tournament.questionsCount}\n`;
        const accuracy = tournament.questionsCount > 0 ? Math.round((correctAnswers / tournament.questionsCount) * 100) : 0;
        message += `   ğŸ“Š PrecisiÃ³n: ${accuracy}%\n`;
      } else if (status === 'IN_PROGRESS') {
        message += `   ğŸ¯ Progreso: ${totalResponses}/${tournament.questionsCount} preguntas\n`;
        if (totalResponses > 0) {
          message += `   ğŸ’° Puntos actuales: ${score}\n`;
        }
      } else if (status === 'REGISTERED') {
        const timeUntilStart = tournament.scheduleddate.getTime() - Date.now();
        const minutesUntilStart = Math.ceil(timeUntilStart / (1000 * 60));
        if (minutesUntilStart > 0) {
          message += `   â° Inicia en: ${minutesUntilStart} minutos\n`;
        } else {
          message += `   ğŸ”¥ Â¡Iniciando pronto!\n`;
        }
      }
      
      message += `\n`;
    });

    if (participations.length > 5) {
      message += `ğŸ“Š <i>... y ${participations.length - 5} mÃ¡s en tu historial</i>\n\n`;
    }

    // Mejores resultados
    if (completed.length > 0) {
      const bestScore = Math.max(...completed.map(p => p.score || 0));
      const bestAccuracy = Math.max(...completed.map(p => {
        const correct = p.correctanswers || 0;
        const total = p.tournament.questionsCount;
        return total > 0 ? Math.round((correct / total) * 100) : 0;
      }));

      message += `ğŸ… <b>MEJORES RESULTADOS:</b>\n`;
      message += `ğŸ’° Mayor puntuaciÃ³n: ${bestScore} puntos\n`;
      message += `ğŸ¯ Mejor precisiÃ³n: ${bestAccuracy}%\n\n`;
    }

    message += `ğŸ® <b>COMANDOS:</b>\n`;
    message += `â€¢ <code>/torneo</code> - Unirse a nuevo torneo\n`;
    message += `â€¢ <code>/torneos</code> - Ver torneos disponibles\n`;
    message += `â€¢ <code>/ranking</code> - ClasificaciÃ³n general`;

    return message;

  } catch (error) {
    console.error('âŒ Error en handleTorneoHistoryCommand:', error);
    return `âŒ <b>Error interno</b>\n\nIntÃ©ntalo de nuevo en unos segundos.`;
  }
}

// ==============================================
// ğŸ¯ HANDLERS DE SESIONES DE ESTUDIO PRIVADAS
// ==============================================

async function handleStudyCommand(
  userid: string, 
  message: any, 
  studyCommand: { subject: string; quantity: number; type?: 'normal' | 'failed' }
): Promise<string | null> {
  try {
    const sessionType = studyCommand.type || 'normal';
    console.log(`ğŸ¯ STUDY COMMAND - Usuario: ${userid}, Materia: ${studyCommand.subject}, Cantidad: ${studyCommand.quantity}, Tipo: ${sessionType}`);

    // Verificar que es un chat privado
    if (message.chat && message.chat.type !== 'private') {
      const commandExample = sessionType === 'failed' ? 
        (studyCommand.subject === 'all' ? '/falladas5' : `/${studyCommand.subject}falladas${studyCommand.quantity}`) :
        `/${studyCommand.subject}${studyCommand.quantity}`;
        
      return `âš ï¸ <b>Solo chat privado</b>\n\n` +
             `ğŸ”’ Los comandos de estudio solo funcionan en <b>chat privado</b> con el bot.\n\n` +
             `ğŸ’¡ <b>CÃ³mo usarlo:</b>\n` +
             `1. Abre un chat privado con @tu_bot\n` +
             `2. Usa el comando: ${commandExample}\n\n` +
             `ğŸ“š <b>Comandos disponibles:</b>\n` +
             `â€¢ /constitucion10, /defensanacional5, /rjsp15\n` +
             `â€¢ /falladas, /constitucionfalladas5\n` +
             `â€¢ /stop, /progreso`;
    }

    // Verificar usuario registrado
    const user = await prisma.telegramuser.findUnique({
      where: { telegramUserId: userid }
    });

    if (!user) {
      return `âŒ <b>Usuario no registrado</b>\n\n` +
             `ğŸ”§ EnvÃ­a <code>/start</code> primero para registrarte.`;
    }

    // â­ NUEVA FUNCIONALIDAD: Verificar permisos y cuotas de suscripciÃ³n
    console.log('ğŸ” Verificando permisos de suscripciÃ³n para comandos de estudio...');
    
    // VerificaciÃ³n directa de suscripciÃ³n usando SQL (similar a /mi_plan que funciona)
    const subscriptionCheck = await prisma.$queryRaw`
      SELECT 
        tu."telegramUserId",
        tu."firstName",
        s."id" as "subscriptionId",
        s."status",
        s."endDate",
        p."name" as "planName",
        p."displayName" as "planDisplayName",
        p."canUseFailedQuestions"
      FROM "TelegramUser" tu
      LEFT JOIN "UserSubscription" s ON tu."id" = s."userid" AND s."status" = 'active' AND s."endDate" >= NOW()
      LEFT JOIN "SubscriptionPlan" p ON s."planId" = p."id"
      WHERE tu."telegramUserId" = ${userid}
      LIMIT 1
    ` as any[];

    const userSubscription = subscriptionCheck[0];
    const featureType = sessionType === 'failed' ? 'failed_questions' : 'questions';
    
    // Verificar acceso a la funcionalidad
    let accessResult: { allowed: boolean; reason?: string; currentPlan?: string; requiredPlan?: string; remainingQuota?: number };
    
    if (!userSubscription) {
      accessResult = {
        allowed: false,
        reason: 'Usuario no encontrado'
      };
    } else if (!userSubscription.planName) {
      // Usuario sin suscripciÃ³n (plan gratuito)
      accessResult = {
        allowed: false,
        reason: 'Las preguntas falladas requieren suscripciÃ³n',
        currentPlan: 'Gratuito',
        requiredPlan: 'BÃ¡sico'
      };
    } else if (featureType === 'failed_questions' && !userSubscription.canUseFailedQuestions) {
      // Plan que no incluye preguntas falladas
      accessResult = {
        allowed: false,
        reason: 'Tu plan no incluye acceso a preguntas falladas',
        currentPlan: userSubscription.planDisplayName,
        requiredPlan: 'BÃ¡sico'
      };
    } else {
      // Todo correcto
      accessResult = { allowed: true };
      console.log(`âœ… Acceso autorizado: Usuario ${userSubscription.firstName} con plan ${userSubscription.planDisplayName}`);
    }

    if (!accessResult.allowed) {
      console.log('âŒ Acceso denegado por lÃ­mites de suscripciÃ³n:', accessResult.reason);
      
      // Generar mensaje de upgrade personalizado
      let upgradeMessage = `ğŸ”’ <b>LÃ­mite de SuscripciÃ³n Alcanzado</b>\n\n`;
      upgradeMessage += `âŒ ${accessResult.reason}\n\n`;
      
      if (accessResult.currentPlan) {
        upgradeMessage += `ğŸ“‹ <b>Tu plan actual:</b> ${accessResult.currentPlan}\n`;
      }
      
      if (accessResult.remainingQuota !== undefined && accessResult.remainingQuota > 0) {
        upgradeMessage += `ğŸ“Š <b>Restante hoy:</b> ${accessResult.remainingQuota} preguntas\n`;
      }
      
      if (accessResult.requiredPlan) {
        upgradeMessage += `ğŸ’ <b>Plan requerido:</b> ${accessResult.requiredPlan}\n\n`;
        
        if (accessResult.requiredPlan === 'Premium') {
          upgradeMessage += `ğŸš€ <b>Â¡Actualiza a Premium!</b>\n`;
          upgradeMessage += `â€¢ â™¾ï¸ Preguntas ilimitadas\n`;
          upgradeMessage += `â€¢ ğŸ¯ Simulacros personalizados\n`;
          upgradeMessage += `â€¢ ğŸ“Š EstadÃ­sticas avanzadas\n`;
          upgradeMessage += `â€¢ ğŸ”— IntegraciÃ³n Moodle\n`;
          upgradeMessage += `â€¢ ğŸ¤– AnÃ¡lisis con IA\n\n`;
          upgradeMessage += `ğŸ’³ <code>/premium</code> - Ver planes Premium`;
        } else {
          upgradeMessage += `ğŸ“š <b>Â¡SuscrÃ­bete al plan BÃ¡sico!</b>\n`;
          upgradeMessage += `â€¢ 100 preguntas diarias\n`;
          upgradeMessage += `â€¢ Sistema de preguntas falladas\n`;
          upgradeMessage += `â€¢ EstadÃ­sticas bÃ¡sicas\n\n`;
          upgradeMessage += `ğŸ’³ <code>/basico</code> - Ver plan BÃ¡sico (â‚¬4.99/mes)`;
        }
      } else {
        upgradeMessage += `ğŸ’¡ <b>Opciones:</b>\n`;
        upgradeMessage += `â€¢ <code>/planes</code> - Ver todos los planes\n`;
        upgradeMessage += `â€¢ <code>/mi_plan</code> - Ver tu suscripciÃ³n actual`;
      }
      
      return upgradeMessage;
    }

    console.log('âœ… Permisos verificados - usuario puede acceder a la funcionalidad');

    // Crear instancia del servicio
    const studyService = new StudySessionService();

    // Iniciar sesiÃ³n de estudio (normal o de falladas)
    const result = await studyService.startStudySession(
      userid, 
      studyCommand.subject, 
      studyCommand.quantity,
      sessionType
    );

    // â­ FUNCIONALIDAD: Tracking de cuota para planes bÃ¡sicos
    if (result.success) {
      console.log('âœ… SesiÃ³n de estudio iniciada exitosamente');
      
      // Incrementar cuota solo si el usuario tiene suscripciÃ³n activa
      if (userSubscription && userSubscription.planName) {
        try {
          // ImplementaciÃ³n directa del tracking de cuotas usando SQL
          const today = new Date().toISOString().split('T')[0]; // Formato YYYY-MM-DD
          
          // Verificar si existe registro de uso de hoy
          const existingUsage = await prisma.$queryRaw`
            SELECT * FROM "UserQuotaUsage" 
            WHERE "userid" = ${user.id} AND "date" = ${today}::date
            LIMIT 1
          ` as any[];

          if (existingUsage.length > 0) {
            // Actualizar uso existente
            const currentQuestions = existingUsage[0].questionsUsed || 0;
            const currentFailed = existingUsage[0].failedQuestionsUsed || 0;
            
            if (featureType === 'questions') {
              await prisma.$executeRaw`
                UPDATE "UserQuotaUsage" 
                SET "questionsUsed" = ${currentQuestions + studyCommand.quantity},
                    "updatedAt" = NOW()
                WHERE "userid" = ${user.id} AND "date" = ${today}::date
              `;
            } else if (featureType === 'failed_questions') {
              await prisma.$executeRaw`
                UPDATE "UserQuotaUsage" 
                SET "failedQuestionsUsed" = ${currentFailed + studyCommand.quantity},
                    "updatedAt" = NOW()
                WHERE "userid" = ${user.id} AND "date" = ${today}::date
              `;
            }
          } else {
            // Crear nuevo registro de uso - REQUIERE subscriptionId
            const questionsUsed = featureType === 'questions' ? studyCommand.quantity : 0;
            const failedQuestionsUsed = featureType === 'failed_questions' ? studyCommand.quantity : 0;
            
            // âš ï¸ VALIDACIÃ“N CRÃTICA: Verificar que tenemos subscriptionId
            if (!userSubscription.subscriptionId) {
              console.error(`âŒ TRACKING ERROR: No se puede crear registro sin subscriptionId para usuario ${userid}`);
              throw new Error('subscriptionId requerido para crear registro de cuotas');
            }
            
            await prisma.$executeRaw`
              INSERT INTO "UserQuotaUsage" ("id", "userid", "subscriptionId", "date", "questionsUsed", "failedQuestionsUsed", "createdAt", "updatedAt")
              VALUES (gen_random_uuid(), ${user.id}, ${userSubscription.subscriptionId}, ${today}::date, ${questionsUsed}, ${failedQuestionsUsed}, NOW(), NOW())
            `;
            
            console.log(`âœ… TRACKING: Nuevo registro creado con subscriptionId = ${userSubscription.subscriptionId}`);
          }
          
          console.log(`âœ… Cuota incrementada: ${studyCommand.quantity} ${featureType}`);
        } catch (quotaError) {
          console.error('âš ï¸ Error incrementando cuota (no crÃ­tico):', quotaError);
          // No bloquear la funcionalidad si falla el tracking
        }
      } else {
        console.log('â„¹ï¸ Usuario sin suscripciÃ³n - no se hace tracking de cuota');
      }
    }

    return result.message;

  } catch (error) {
    console.error('âŒ Error en handleStudyCommand:', error);
    return `âŒ <b>Error interno</b>\n\nIntÃ©ntalo de nuevo en unos segundos.`;
  }
}

async function handleStopStudySession(userid: string, message: any): Promise<string | null> {
  try {
    console.log(`ğŸ›‘ STOP STUDY SESSION - Usuario: ${userid}`);

    // Verificar que es un chat privado
    if (message.chat && message.chat.type !== 'private') {
      return `âš ï¸ <b>Solo chat privado</b>\n\n` +
             `ğŸ”’ Los comandos de estudio solo funcionan en <b>chat privado</b> con el bot.`;
    }

    const studyService = new StudySessionService();
    const result = await studyService.stopSession(userid);
    return result.message;

  } catch (error) {
    console.error('âŒ Error en handleStopStudySession:', error);
    return `âŒ <b>Error interno</b>\n\nIntÃ©ntalo de nuevo en unos segundos.`;
  }
}

async function handleStudyProgress(userid: string, message: any): Promise<string | null> {
  try {
    console.log(`ğŸ“Š STUDY PROGRESS - Usuario: ${userid}`);

    // Verificar que es un chat privado
    if (message.chat && message.chat.type !== 'private') {
      return `âš ï¸ <b>Solo chat privado</b>\n\n` +
             `ğŸ”’ Los comandos de estudio solo funcionan en <b>chat privado</b> con el bot.`;
    }

    const studyService = new StudySessionService();
    const result = await studyService.getSessionProgress(userid);
    return result.message;

  } catch (error) {
    console.error('âŒ Error en handleStudyProgress:', error);
    return `âŒ <b>Error interno</b>\n\nIntÃ©ntalo de nuevo en unos segundos.`;
  }
}

async function sendStudyPoll(userid: string, questionData: any): Promise<boolean> {
  try {
    console.log(`ğŸ“Š ENVIANDO POLL DE ESTUDIO - Usuario: ${userid}, Pregunta: ${questionData.id}`);

    const question = questionData.question || questionData.pregunta || 'Pregunta no disponible';
    
    // Las opciones pueden venir como array de strings o campos individuales
    let options: string[] = [];
    if (Array.isArray(questionData.options)) {
      // Limpiar opciones eliminando porcentajes al inicio (ej: "%100%texto" -> "texto")
      options = questionData.options.map((option: string) => {
        // Eliminar porcentajes al inicio como "%100%" o "%-33.33333%"
        return option.replace(/^%[-\d.]+%/, '').trim();
      }).filter((option: string) => option && option.length > 0);
    } else {
      // Fallback para formato anterior
      options = [
        questionData.a || questionData.option1,
        questionData.b || questionData.option2, 
        questionData.c || questionData.option3,
        questionData.d || questionData.option4
      ].filter(option => option && option.trim() !== '');
    }

    if (options.length < 2) {
      console.error('âŒ Opciones insuficientes para la pregunta:', questionData.id);
      return false;
    }

    // ğŸ“ VERIFICAR LÃMITE DE CARACTERES DE TELEGRAM (100 caracteres por opciÃ³n)
    const maxOptionLength = options.reduce((max, option) => Math.max(max, option.length), 0);
    if (maxOptionLength > 100) {
      console.log(`âš ï¸ PREGUNTA SALTADA: OpciÃ³n muy larga (${maxOptionLength} caracteres, mÃ¡ximo 100)`);
      console.log('ğŸ“‹ Opciones problemÃ¡ticas:', options.map((opt, i) => `${i+1}. ${opt.length} chars: ${opt.substring(0, 50)}...`));
      
      // Buscar siguiente pregunta automÃ¡ticamente
      // TODO: Implementar skipCurrentAndGetNext en StudySessionService
      console.log('ğŸ”„ Funcionalidad de saltar pregunta deshabilitada temporalmente');
      await sendTelegramMessage(userid.toString(), 
        'âŒ <b>Error tÃ©cnico</b>\n\n' +
        'Esta pregunta tiene opciones muy largas para Telegram.\n' +
        'Usa /stop y vuelve a intentar.'
      );
      return false;
      /*
      try {
        const nextQuestionResult = await StudySessionService.skipCurrentAndGetNext(userid.toString());
        if (nextQuestionResult.success && nextQuestionResult.nextQuestion) {
          console.log('ğŸ”„ Saltando a siguiente pregunta automÃ¡ticamente...');
          // Llamada recursiva con la siguiente pregunta
          return await sendStudyPoll(userid, nextQuestionResult.nextQuestion);
        } else if (nextQuestionResult.sessionComplete) {
          // Si se completÃ³ la sesiÃ³n, enviar resumen
          if (nextQuestionResult.message) {
            await sendTelegramMessage(userid.toString(), nextQuestionResult.message);
          }
          return true;
        } else {
          console.error('âŒ No se pudo obtener siguiente pregunta despuÃ©s de saltar');
          await sendTelegramMessage(userid.toString(), 
            'âŒ <b>Error tÃ©cnico</b>\n\n' +
            'Esta pregunta tiene opciones muy largas para Telegram.\n' +
            'Usa /parar_estudio y vuelve a intentar.'
          );
          return false;
        }
      } catch (skipError) {
        console.error('âŒ Error saltando pregunta:', skipError);
        await sendTelegramMessage(userid.toString(), 
          'âŒ <b>Error tÃ©cnico</b>\n\n' +
          'Problema saltando pregunta con opciones largas.\n' +
          'Usa /parar_estudio y vuelve a intentar.'
        );
        return false;
      }
      */
    }

    // El correctAnswerIndex ya viene 0-indexed desde la base de datos
    const originalCorrectIndex = questionData.correctanswerindex !== undefined ? 
      questionData.correctanswerindex : 
      (questionData.correcta ? questionData.correcta - 1 : 0);

    // ğŸ² RANDOMIZAR OPCIONES PARA EVITAR QUE LA RESPUESTA CORRECTA SIEMPRE SEA LA A
    // Crear array con opciones y sus Ã­ndices originales
    const optionsWithIndex = options.map((option: string, index: number) => ({
      option,
      originalIndex: index
    }));

    // Mezclar las opciones aleatoriamente
    const shuffledOptions = [...optionsWithIndex].sort(() => Math.random() - 0.5);
    
    // Encontrar la nueva posiciÃ³n de la respuesta correcta despuÃ©s del shuffle
    const newCorrectIndex = shuffledOptions.findIndex(
      item => item.originalIndex === originalCorrectIndex
    );

    // Extraer solo las opciones mezcladas para el poll
    const finalOptions = shuffledOptions.map(item => item.option);

    console.log('ğŸ² Opciones randomizadas:', {
      original: options,
      shuffled: finalOptions,
      originalCorrectIndex,
      newCorrectIndex,
      correctAnswer: finalOptions[newCorrectIndex]
    });

    // Formatear header con informaciÃ³n de progreso
    const header = `ğŸ¯ PREGUNTA ${questionData.currentIndex}/${questionData.totalQuestions}\n` +
                  `ğŸ“š ${StudySessionService.getDisplayName(questionData.subject)}\n` +
                  `â±ï¸ Tiempo lÃ­mite: 1 minuto\n\n`;

    const fullQuestion = truncatePollQuestion(header, question, 280);

    const pollData = {
      chat_id: userid,
      question: fullQuestion,
      options: JSON.stringify(finalOptions), // Usar opciones mezcladas
      type: 'quiz',
      correct_option_id: newCorrectIndex, // Usar nuevo Ã­ndice despuÃ©s del shuffle
      is_anonymous: false,
      allows_multiple_answers: false,
      explanation: `âœ… La respuesta correcta es: ${finalOptions[newCorrectIndex]}`,
      open_period: 60 // 1 minuto lÃ­mite
    };

    const response = await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/sendPoll`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(pollData),
    });

    if (!response.ok) {
      const errorData = await response.json();
      console.error('âŒ Error enviando poll de estudio:', errorData);
      return false;
    }

    const data = await response.json();
    const pollid = data.result.poll.id;

    // Guardar mapping temporal en memoria para poder procesar respuesta despuÃ©s
    // TODO: Implementar con Redis o tabla especÃ­fica para producciÃ³n
    global.studyPollMappings = global.studyPollMappings || new Map();
    const mappingData = {
      questionid: questionData.id.toString(),
      userid: userid,
      subject: questionData.subject,
      timestamp: Date.now(),
      // ğŸ² Guardar el Ã­ndice correcto despuÃ©s del shuffle para validar respuestas
      correctanswerindex: newCorrectIndex,
      originalCorrectIndex: originalCorrectIndex
    };
    global.studyPollMappings.set(pollid, mappingData);

    // â° PROGRAMAR TIMEOUT PARA ENVIAR SIGUIENTE PREGUNTA SI NO HAY RESPUESTA
    setTimeout(async () => {
      try {
        // Verificar si el poll aÃºn estÃ¡ en el mapping (no fue respondido)
        if (global.studyPollMappings && global.studyPollMappings.has(pollid)) {
          console.log(`â° TIMEOUT: Poll ${pollid} no fue respondido en 65 segundos, procesando automÃ¡ticamente...`);
          
          // Procesar timeout como respuesta no respondida usando el StudySessionService
          console.log('â° Procesando timeout automÃ¡ticamente con StudySessionService...');
          
          // Usar el mÃ©todo processPollAnswer con opciÃ³n invÃ¡lida (-1) para indicar timeout
          await studySessionService.processPollAnswer(
            pollid,
            userid.toString(),
            -1 // OpciÃ³n invÃ¡lida para indicar timeout
          );
          
          // Limpiar mapping despuÃ©s del procesamiento
          global.studyPollMappings.delete(pollid);
          
          console.log('âœ… Timeout procesado exitosamente por StudySessionService');
        }
      } catch (error) {
        console.error('âŒ Error procesando timeout de poll:', error);
      }
    }, 65000); // 65 segundos (5 segundos despuÃ©s del lÃ­mite de Telegram)

    console.log(`âœ… Poll de estudio enviado - ID: ${pollid}`);
    return true;

  } catch (error) {
    console.error('âŒ Error enviando poll de estudio:', error);
    return false;
  }
}

// ==============================================
// ğŸ“Š HANDLERS DE COMANDOS DE ESTADÃSTICAS PERSONALES
// ==============================================

async function handleMiProgresoCommand(userid: string, fromtelegramuser: any): Promise<string | null> {
  try {
    console.log('ğŸ“Š MI PROGRESO COMMAND - Ver progreso personal de graduaciones');

    // Verificar usuario registrado
    const user = await prisma.telegramuser.findUnique({
      where: { telegramUserId: userid }
    });

    if (!user) {
      return `âŒ <b>Usuario no registrado</b>\n\nğŸ”§ EnvÃ­a <code>/start</code> primero para registrarte.`;
    }

    // Obtener estadÃ­sticas de graduaciÃ³n usando el servicio de estudio
    const studyService = new StudySessionService();
    
    // Contar total de preguntas falladas y graduadas por materia
    const subjectMappings = StudySessionService.getSubjectMappings();
    const stats: Record<string, { total: number, graduated: number }> = {};
    
    for (const [command, subjectName] of Object.entries(subjectMappings)) {
      const subjectKey = command.replace('/', '');
      
      // Contar preguntas falladas (no graduadas)
      const failedCount = await studyService.getFailedQuestionsCount(userid, subjectKey);
      
      // Contar total de respuestas incorrectas Ãºnicamente (estimado de preguntas que han fallado alguna vez)
      const uniqueFailedQuestions = await prisma.studyresponse.findMany({
        where: {
          userid: userid,
          subject: subjectKey,
          iscorrect: false
        },
        select: {
          questionid: true
        },
        distinct: ['questionId']
      });
      const totalFailedEver = uniqueFailedQuestions.length;
      
      // Graduadas = Total que fallaron alguna vez - Actuales falladas
      const graduated = Math.max(0, totalFailedEver - failedCount);
      
      if (totalFailedEver > 0) {
        stats[subjectName] = {
          total: totalFailedEver,
          graduated: graduated
        };
      }
    }

    if (Object.keys(stats).length === 0) {
      return `ğŸ“Š <b>MI PROGRESO</b>

ğŸ‘¤ <b>${user.firstName || user.username || 'Usuario'}</b>

âŒ <b>AÃºn no tienes preguntas graduadas</b>

ğŸ’¡ <b>Â¿CÃ³mo funciona la graduaciÃ³n?</b>
â€¢ Cuando fallas una pregunta, va a tu lista de "falladas"
â€¢ Cuando aciertas 1 vez esa pregunta â†’ Â¡Se gradÃºa! ğŸ“
â€¢ Las preguntas graduadas ya no aparecen en /falladas

ğŸ¯ <b>Para empezar:</b>
â€¢ Responde preguntas en el grupo
â€¢ Usa <code>/falladas</code> para repasar las que hayas fallado
â€¢ Â¡Observa cÃ³mo van graduÃ¡ndose!

ğŸ“š <b>Comandos Ãºtiles:</b>
â€¢ <code>/estadisticas</code> - Ver precisiÃ³n por materia
â€¢ <code>/graduadas</code> - Ver lista de preguntas graduadas`;
    }

    let message = `ğŸ“Š <b>MI PROGRESO DE GRADUACIÃ“N</b>\n\n`;
    message += `ğŸ‘¤ <b>${user.firstName || user.username || 'Usuario'}</b>\n\n`;

    // Calcular estadÃ­sticas generales
    const totalFailed = Object.values(stats).reduce((sum, s) => sum + s.total, 0);
    const totalGraduated = Object.values(stats).reduce((sum, s) => sum + s.graduated, 0);
    const graduationRate = totalFailed > 0 ? Math.round((totalGraduated / totalFailed) * 100) : 0;

    message += `ğŸ“ <b>RESUMEN GENERAL:</b>\n`;
    message += `ğŸ“š Total preguntas falladas alguna vez: ${totalFailed}\n`;
    message += `âœ… Preguntas graduadas: ${totalGraduated}\n`;
    message += `ğŸ“Š Tasa de graduaciÃ³n: ${graduationRate}%\n\n`;

    // Mostrar desglose por materia
    message += `ğŸ“‹ <b>DESGLOSE POR MATERIA:</b>\n`;
    
    const sortedStats = Object.entries(stats).sort((a, b) => b[1].graduated - a[1].graduated);
    
    sortedStats.forEach(([subject, data]) => {
      const rate = data.total > 0 ? Math.round((data.graduated / data.total) * 100) : 0;
      const emoji = rate >= 80 ? 'ğŸ¯' : rate >= 60 ? 'ğŸ“ˆ' : rate >= 40 ? 'âš¡' : 'ğŸ“š';
      
      message += `${emoji} <b>${subject}</b>\n`;
      message += `   ğŸ“ Graduadas: ${data.graduated}/${data.total} (${rate}%)\n`;
      message += `   ğŸ“ Pendientes: ${data.total - data.graduated}\n\n`;
    });

    // MotivaciÃ³n personalizada
    if (graduationRate >= 80) {
      message += `ğŸ† <b>Â¡EXCELENTE!</b> Tienes una tasa de graduaciÃ³n muy alta.\n`;
    } else if (graduationRate >= 60) {
      message += `ğŸ‘ <b>Â¡MUY BIEN!</b> EstÃ¡s en buen camino con tus graduaciones.\n`;
    } else if (graduationRate >= 40) {
      message += `ğŸ’ª <b>Â¡SIGUE ASÃ!</b> Vas progresando en tus graduaciones.\n`;
    } else {
      message += `ğŸš€ <b>Â¡A POR ELLO!</b> Practica con /falladas para graduar mÃ¡s preguntas.\n`;
    }

    message += `\nğŸ“š <b>COMANDOS ÃšTILES:</b>\n`;
    message += `â€¢ <code>/falladas</code> - Repasar preguntas pendientes\n`;
    message += `â€¢ <code>/estadisticas</code> - Ver precisiÃ³n por materia\n`;
    message += `â€¢ <code>/graduadas</code> - Ver lista detallada`;

    return message;

  } catch (error) {
    console.error('âŒ Error en handleMiProgresoCommand:', error);
    return `âŒ <b>Error interno</b>\n\nIntÃ©ntalo de nuevo en unos segundos.`;
  }
}

async function handleEstadisticasCommand(userid: string, fromtelegramuser: any): Promise<string | null> {
  try {
    console.log('ğŸ“ˆ ESTADISTICAS COMMAND - Ver estadÃ­sticas por materia');

    // Verificar usuario registrado
    const user = await prisma.telegramuser.findUnique({
      where: { telegramUserId: userid }
    });

    if (!user) {
      return `âŒ <b>Usuario no registrado</b>\n\nğŸ”§ EnvÃ­a <code>/start</code> primero para registrarte.`;
    }

    // Obtener estadÃ­sticas por materia
    const subjectMappings = StudySessionService.getSubjectMappings();
    const stats: Record<string, { total: number, correct: number, accuracy: number }> = {};
    
    for (const [command, subjectName] of Object.entries(subjectMappings)) {
      const subjectKey = command.replace('/', '');
      
      // Contar respuestas por materia
      const responses = await prisma.studyresponse.groupBy({
        by: ['isCorrect'],
        where: {
          userid: userid,
          subject: subjectKey
        },
        _count: {
          _all: true
        }
      });
      
      let total = 0;
      let correct = 0;
      
      responses.forEach(r => {
        total += r._count._all;
        if (r.iscorrect) {
          correct += r._count._all;
        }
      });
      
      if (total > 0) {
        const accuracy = Math.round((correct / total) * 100);
        stats[subjectName] = { total, correct, accuracy };
      }
    }

    if (Object.keys(stats).length === 0) {
      return `ğŸ“ˆ <b>ESTADÃSTICAS POR MATERIA</b>

ğŸ‘¤ <b>${user.firstName || user.username || 'Usuario'}</b>

âŒ <b>AÃºn no tienes estadÃ­sticas</b>

ğŸ¯ <b>Para generar estadÃ­sticas:</b>
â€¢ Responde preguntas en el grupo
â€¢ Usa comandos de estudio como <code>/constitucion5</code>
â€¢ Practica con <code>/falladas</code>

ğŸ“š <b>Comandos de estudio disponibles:</b>
â€¢ <code>/constitucion10</code> - Preguntas de ConstituciÃ³n
â€¢ <code>/defensanacional5</code> - Preguntas de Defensa Nacional
â€¢ <code>/falladas</code> - Repasar preguntas falladas`;
    }

    let message = `ğŸ“ˆ <b>ESTADÃSTICAS POR MATERIA</b>\n\n`;
    message += `ğŸ‘¤ <b>${user.firstName || user.username || 'Usuario'}</b>\n\n`;

    // Calcular estadÃ­sticas generales
    const totalResponses = Object.values(stats).reduce((sum, s) => sum + s.total, 0);
    const totalCorrect = Object.values(stats).reduce((sum, s) => sum + s.correct, 0);
    const overallAccuracy = totalResponses > 0 ? Math.round((totalCorrect / totalResponses) * 100) : 0;

    message += `ğŸ¯ <b>RESUMEN GENERAL:</b>\n`;
    message += `ğŸ“Š Total respuestas: ${totalResponses}\n`;
    message += `âœ… Respuestas correctas: ${totalCorrect}\n`;
    message += `ğŸ¯ PrecisiÃ³n general: ${overallAccuracy}%\n\n`;

    // Mostrar estadÃ­sticas por materia (ordenadas por precisiÃ³n)
    message += `ğŸ“‹ <b>DESGLOSE POR MATERIA:</b>\n`;
    
    const sortedStats = Object.entries(stats).sort((a, b) => b[1].accuracy - a[1].accuracy);
    
    sortedStats.forEach(([subject, data]) => {
      let emoji = 'ğŸ“š';
      if (data.accuracy >= 90) emoji = 'ğŸ†';
      else if (data.accuracy >= 80) emoji = 'ğŸ¥‡';
      else if (data.accuracy >= 70) emoji = 'ğŸ¥ˆ';
      else if (data.accuracy >= 60) emoji = 'ğŸ¥‰';
      else if (data.accuracy >= 50) emoji = 'ğŸ“ˆ';
      else emoji = 'âš¡';
      
      message += `${emoji} <b>${subject}</b>\n`;
      message += `   ğŸ¯ PrecisiÃ³n: ${data.accuracy}% (${data.correct}/${data.total})\n`;
      message += `   ğŸ“Š Total respuestas: ${data.total}\n\n`;
    });

    // Consejos personalizados
    const worstSubject = sortedStats[sortedStats.length - 1];
    const bestSubject = sortedStats[0];
    
    if (overallAccuracy >= 80) {
      message += `ğŸ‰ <b>Â¡EXCELENTE RENDIMIENTO!</b> Tu precisiÃ³n general es muy alta.\n`;
    } else if (overallAccuracy >= 70) {
      message += `ğŸ‘ <b>Â¡BUEN TRABAJO!</b> Tienes una precisiÃ³n sÃ³lida.\n`;
    } else if (overallAccuracy >= 60) {
      message += `ğŸ’ª <b>Â¡SIGUE MEJORANDO!</b> Vas por buen camino.\n`;
    } else {
      message += `ğŸš€ <b>Â¡A POR ELLO!</b> Cada respuesta te hace mejorar.\n`;
    }

    if (worstSubject && worstSubject[1].accuracy < 70) {
      message += `ğŸ’¡ <b>TIP:</b> Considera repasar mÃ¡s ${worstSubject[0]} (${worstSubject[1].accuracy}%)\n`;
    }

    message += `\nğŸ“š <b>COMANDOS ÃšTILES:</b>\n`;
    message += `â€¢ <code>/miprogreso</code> - Ver preguntas graduadas\n`;
    message += `â€¢ <code>/falladas</code> - Repasar preguntas falladas\n`;
    message += `â€¢ <code>/graduadas</code> - Lista de preguntas graduadas`;

    return message;

  } catch (error) {
    console.error('âŒ Error en handleEstadisticasCommand:', error);
    return `âŒ <b>Error interno</b>\n\nIntÃ©ntalo de nuevo en unos segundos.`;
  }
}

async function handleGraduadasCommand(userid: string, fromtelegramuser: any): Promise<string | null> {
  try {
    console.log('ğŸ“ GRADUADAS COMMAND - Ver preguntas graduadas');

    // Verificar usuario registrado
    const user = await prisma.telegramuser.findUnique({
      where: { telegramUserId: userid }
    });

    if (!user) {
      return `âŒ <b>Usuario no registrado</b>\n\nğŸ”§ EnvÃ­a <code>/start</code> primero para registrarte.`;
    }

    // Obtener preguntas graduadas (que han tenido >= 1 acierto desde Ãºltimo fallo)
    const graduatedQuestions = await prisma.$queryRaw`
      WITH failed_questions AS (
        SELECT 
          "questionid",
          subject,
          MAX("answeredAt") as last_failed_at
        FROM "StudyResponse" 
        WHERE "userid" = ${userid} 
          AND "iscorrect" = false
        GROUP BY "questionid", subject
      ),
      total_successes AS (
        SELECT 
          fq."questionid",
          fq.subject,
          fq.last_failed_at,
          COUNT(sr2.id) as total_successes_since_last_fail
        FROM failed_questions fq
        LEFT JOIN "StudyResponse" sr2 ON sr2."questionid" = fq."questionid" 
          AND sr2."userid" = ${userid} 
          AND sr2."iscorrect" = true 
          AND sr2."answeredAt" > fq.last_failed_at
          AND sr2.subject = fq.subject
        GROUP BY fq."questionid", fq.subject, fq.last_failed_at
      )
      SELECT * FROM total_successes 
      WHERE total_successes_since_last_fail >= 1
      ORDER BY subject, "questionid"
    `;

    if (!graduatedQuestions || (graduatedQuestions as any[]).length === 0) {
      return `ğŸ“ <b>PREGUNTAS GRADUADAS</b>

ğŸ‘¤ <b>${user.firstName || user.username || 'Usuario'}</b>

âŒ <b>AÃºn no tienes preguntas graduadas</b>

ğŸ’¡ <b>Â¿CÃ³mo graduar preguntas?</b>
1. Al fallar una pregunta, va a tu lista de "falladas"
2. Usa <code>/falladas</code> para repasarla
3. Al acertarla 1 vez â†’ Â¡Se gradÃºa! ğŸ“
4. Ya no aparecerÃ¡ mÃ¡s en /falladas

ğŸ¯ <b>Para empezar:</b>
â€¢ Responde preguntas en el grupo
â€¢ Usa <code>/falladas</code> para repasar
â€¢ Â¡Observa cÃ³mo se gradÃºan!

ğŸ“š <b>Comandos Ãºtiles:</b>
â€¢ <code>/miprogreso</code> - Ver progreso general
â€¢ <code>/estadisticas</code> - Ver precisiÃ³n por materia`;
    }

    const questions = graduatedQuestions as any[];
    
    let message = `ğŸ“ <b>PREGUNTAS GRADUADAS</b>\n\n`;
    message += `ğŸ‘¤ <b>${user.firstName || user.username || 'Usuario'}</b>\n\n`;
    
    message += `âœ… <b>Total graduadas: ${questions.length}</b>\n\n`;

    // Agrupar por materia
    const questionsBySubject: Record<string, any[]> = {};
    const subjectMappings = StudySessionService.getSubjectMappings();
    
    questions.forEach(q => {
      const subjectName = Object.entries(subjectMappings)
        .find(([cmd, name]) => cmd.replace('/', '') === q.subject)?.[1] || q.subject;
      
      if (!questionsBySubject[subjectName]) {
        questionsBySubject[subjectName] = [];
      }
      questionsBySubject[subjectName].push(q);
    });

    // Mostrar por materia
    message += `ğŸ“‹ <b>POR MATERIA:</b>\n`;
    
    Object.entries(questionsBySubject)
      .sort((a, b) => b[1].length - a[1].length)
      .forEach(([subject, subjectQuestions]) => {
        message += `ğŸ“š <b>${subject}</b>: ${subjectQuestions.length} graduadas\n`;
        
        // Mostrar las primeras 3 preguntas como ejemplo
        const samplesToShow = Math.min(3, subjectQuestions.length);
                 for (let i = 0; i < samplesToShow; i++) {
           const q = subjectQuestions[i];
           message += `   ğŸ“ ID: ${q.questionid} (${Number(q.total_successes_since_last_fail)} aciertos)\n`;
         }
        
        if (subjectQuestions.length > 3) {
          message += `   ğŸ“Š ... y ${subjectQuestions.length - 3} mÃ¡s\n`;
        }
        
        message += `\n`;
      });

    // EstadÃ­sticas adicionales (convertir BigInt a number)
    const successCounts = questions.map(q => Number(q.total_successes_since_last_fail));
    const avgSuccesses = successCounts.length > 0 ? 
      Math.round(successCounts.reduce((sum, count) => sum + count, 0) / successCounts.length * 10) / 10 : 0;

    message += `ğŸ“Š <b>ESTADÃSTICAS:</b>\n`;
    message += `ğŸ¯ Promedio aciertos por pregunta: ${avgSuccesses}\n`;
    message += `ğŸ“… Ãšltima actualizaciÃ³n: ${new Date().toLocaleDateString('es-ES')}\n\n`;

    message += `ğŸ‰ <b>Â¡Felicidades por tu progreso!</b>\n`;
    message += `Cada pregunta graduada es una victoria. ğŸ†\n\n`;

    message += `ğŸ“š <b>COMANDOS ÃšTILES:</b>\n`;
    message += `â€¢ <code>/falladas</code> - Repasar preguntas pendientes\n`;
    message += `â€¢ <code>/miprogreso</code> - Ver progreso general\n`;
    message += `â€¢ <code>/reiniciar_graduacion</code> - Reset para repasar`;

    return message;

  } catch (error) {
    console.error('âŒ Error en handleGraduadasCommand:', error);
    return `âŒ <b>Error interno</b>\n\nIntÃ©ntalo de nuevo en unos segundos.`;
  }
}

async function handleReiniciarGraduacionCommand(userid: string, fromtelegramuser: any): Promise<string | null> {
  try {
    console.log('ğŸ”„ REINICIAR_GRADUACION COMMAND - Reset de graduaciones');

    // Verificar usuario registrado
    const user = await prisma.telegramuser.findUnique({
      where: { telegramUserId: userid }
    });

    if (!user) {
      return `âŒ <b>Usuario no registrado</b>\n\nğŸ”§ EnvÃ­a <code>/start</code> primero para registrarte.`;
    }

    // Contar preguntas que serÃ­an afectadas
    const graduatedCount = await prisma.$queryRaw`
      WITH failed_questions AS (
        SELECT 
          "questionid",
          subject,
          MAX("answeredAt") as last_failed_at
        FROM "StudyResponse" 
        WHERE "userid" = ${userid} 
          AND "iscorrect" = false
        GROUP BY "questionid", subject
      ),
      total_successes AS (
        SELECT 
          fq."questionid",
          fq.subject,
          COUNT(sr2.id) as total_successes_since_last_fail
        FROM failed_questions fq
        LEFT JOIN "StudyResponse" sr2 ON sr2."questionid" = fq."questionid" 
          AND sr2."userid" = ${userid} 
          AND sr2."iscorrect" = true 
          AND sr2."answeredAt" > fq.last_failed_at
          AND sr2.subject = fq.subject
        GROUP BY fq."questionid", fq.subject
      )
      SELECT COUNT(*) as count FROM total_successes 
      WHERE total_successes_since_last_fail >= 1
    `;

    const count = Number((graduatedCount as any[])[0]?.count || 0);

    if (count === 0) {
      return `ğŸ”„ <b>REINICIAR GRADUACIÃ“N</b>

ğŸ‘¤ <b>${user.firstName || user.username || 'Usuario'}</b>

â„¹ï¸ <b>No hay preguntas graduadas que reiniciar</b>

ğŸ’¡ <b>Â¿QuÃ© hace este comando?</b>
â€¢ Resetea todas las graduaciones
â€¢ Las preguntas "graduadas" vuelven a aparecer en /falladas
â€¢ Ãštil para repasar todo desde cero

ğŸ¯ <b>Para tener graduaciones que resetear:</b>
â€¢ Usa <code>/falladas</code> para repasar preguntas
â€¢ Acierta preguntas para graduarlas
â€¢ Luego podrÃ¡s usar este reset

ğŸ“š <b>Comandos Ãºtiles:</b>
â€¢ <code>/miprogreso</code> - Ver progreso actual
â€¢ <code>/graduadas</code> - Ver preguntas graduadas`;
    }

    return `ğŸ”„ <b>REINICIAR GRADUACIÃ“N</b>

ğŸ‘¤ <b>${user.firstName || user.username || 'Usuario'}</b>

âš ï¸ <b>CONFIRMACIÃ“N REQUERIDA</b>

ğŸ“Š <b>Preguntas graduadas encontradas: ${count}</b>

ğŸ’¡ <b>Â¿QuÃ© pasarÃ¡ si confirmas?</b>
â€¢ Se borrarÃ¡n todas las respuestas correctas de preguntas falladas
â€¢ Las ${count} preguntas graduadas volverÃ¡n a aparecer en /falladas
â€¢ PodrÃ¡s repasarlas desde cero
â€¢ No se perderÃ¡n las estadÃ­sticas generales

âš ï¸ <b>IMPORTANTE:</b> Esta acciÃ³n NO se puede deshacer.

ğŸ¤” <b>Â¿EstÃ¡s seguro?</b>
Este comando estÃ¡ diseÃ±ado para casos especiales de repaso intensivo.

ğŸ’¡ <b>Alternativas recomendadas:</b>
â€¢ <code>/falladas</code> - Repasar solo preguntas pendientes
â€¢ <code>/constitucionfalladas5</code> - Repasar por materia especÃ­fica
â€¢ <code>/miprogreso</code> - Ver estado actual

ğŸ”„ <b>Para confirmar el reset completo:</b>
Usa <code>/reiniciar_graduacion_confirmar</code>

âŒ <b>Para cancelar:</b>
Simplemente ignora este mensaje.`;

  } catch (error) {
    console.error('âŒ Error en handleReiniciarGraduacionCommand:', error);
    return `âŒ <b>Error interno</b>\n\nIntÃ©ntalo de nuevo en unos segundos.`;
  }
}

async function handleReiniciarGraduacionConfirmarCommand(userid: string, fromtelegramuser: any): Promise<string | null> {
  try {
    console.log('âœ… REINICIAR_GRADUACION_CONFIRMAR COMMAND - Ejecutar reset de graduaciones');

    // Verificar usuario registrado
    const user = await prisma.telegramuser.findUnique({
      where: { telegramUserId: userid }
    });

    if (!user) {
      return `âŒ <b>Usuario no registrado</b>\n\nğŸ”§ EnvÃ­a <code>/start</code> primero para registrarte.`;
    }

    // Ejecutar el reset en una transacciÃ³n
    const result = await prisma.$transaction(async (tx) => {
      // Contar preguntas afectadas antes del reset
      const beforeCount = await tx.$queryRaw`
        WITH failed_questions AS (
          SELECT 
            "questionid",
            subject,
            MAX("answeredAt") as last_failed_at
          FROM "StudyResponse" 
          WHERE "userid" = ${userid} 
            AND "iscorrect" = false
          GROUP BY "questionid", subject
        ),
        total_successes AS (
          SELECT 
            fq."questionid",
            fq.subject,
            COUNT(sr2.id) as total_successes_since_last_fail
          FROM failed_questions fq
          LEFT JOIN "StudyResponse" sr2 ON sr2."questionid" = fq."questionid" 
            AND sr2."userid" = ${userid} 
            AND sr2."iscorrect" = true 
            AND sr2."answeredAt" > fq.last_failed_at
            AND sr2.subject = fq.subject
          GROUP BY fq."questionid", fq.subject
        )
        SELECT COUNT(*) as count FROM total_successes 
        WHERE total_successes_since_last_fail >= 1
      `;

      const graduatedCount = Number((beforeCount as any[])[0]?.count || 0);

      if (graduatedCount === 0) {
        return { success: false, count: 0 };
      }

      // Eliminar TODAS las respuestas correctas de preguntas que habÃ­an sido falladas
      // Esto hace que las preguntas "graduadas" vuelvan a ser "falladas"
      const deletedResponses = await tx.$executeRaw`
        DELETE FROM "StudyResponse" 
        WHERE "userid" = ${userid} 
          AND "iscorrect" = true 
          AND "questionid" IN (
            SELECT DISTINCT "questionid" 
            FROM "StudyResponse" 
            WHERE "userid" = ${userid} 
              AND "iscorrect" = false
          )
      `;

      return { success: true, count: graduatedCount, deleted: Number(deletedResponses) };
    });

    if (!result.success) {
      return `ğŸ”„ <b>RESET GRADUACIÃ“N</b>

ğŸ‘¤ <b>${user.firstName || user.username || 'Usuario'}</b>

â„¹ï¸ <b>No hay preguntas graduadas para resetear</b>

ğŸ’¡ <b>Estado actual:</b>
â€¢ No tienes preguntas graduadas actualmente
â€¢ Todas las preguntas falladas ya estÃ¡n disponibles para repaso

ğŸ¯ <b>Puedes usar:</b>
â€¢ <code>/falladas</code> - Ver preguntas pendientes de repaso
â€¢ <code>/miprogreso</code> - Ver tu progreso actual`;
    }

    return `âœ… <b>GRADUACIÃ“N RESETEADA</b>

ğŸ‘¤ <b>${user.firstName || user.username || 'Usuario'}</b>

ğŸ‰ <b>Reset completado exitosamente</b>

ğŸ“Š <b>Resultados:</b>
â€¢ ${result.count} preguntas des-graduadas
â€¢ ${result.deleted} respuestas correctas eliminadas
â€¢ Todas las preguntas vuelven a estar disponibles para repaso

ğŸ’¡ <b>Â¿QuÃ© significa esto?</b>
â€¢ Las preguntas que habÃ­as "graduado" vuelven a aparecer en /falladas
â€¢ Puedes repasarlas desde cero
â€¢ Tus estadÃ­sticas generales se mantienen intactas

ğŸ¯ <b>PrÃ³ximos pasos:</b>
â€¢ Usa <code>/falladas</code> para empezar el repaso intensivo
â€¢ Usa <code>/miprogreso</code> para ver el nuevo estado
â€¢ Usa <code>/estadisticas</code> para ver tu rendimiento

ğŸš€ <b>Â¡Ideal para repaso intensivo pre-examen!</b>

ğŸ’¡ <b>Consejo:</b> Ahora tienes la oportunidad de repasar todo desde cero y consolidar tu conocimiento.`;

  } catch (error) {
    console.error('âŒ Error en handleReiniciarGraduacionConfirmarCommand:', error);
    return `âŒ <b>Error interno</b>\n\nNo se pudo completar el reset. IntÃ©ntalo de nuevo en unos segundos.`;
  }
}

async function handleConfigurarNotificacionesCommand(userid: string, fromtelegramuser: any): Promise<string | null> {
  try {
    console.log('âš™ï¸ CONFIGURAR_NOTIFICACIONES COMMAND - Configurar sistema de notificaciones');

    // Verificar usuario registrado
    const user = await prisma.telegramuser.findUnique({
      where: { telegramUserId: userid }
    });

    if (!user) {
      return `âŒ <b>Usuario no registrado</b>\n\nğŸ”§ EnvÃ­a <code>/start</code> primero para registrarte.`;
    }

    // Obtener configuraciones actuales
    const { NotificationService } = await import('@/services/notificationService');
    const notificationService = new NotificationService();
    const settings = await notificationService.getUserNotificationSettings(user.id);

    const graduationEnabled = settings?.graduationNotifications !== false;
    const milestoneEnabled = settings?.milestoneNotifications !== false;
    const reminderEnabled = settings?.reminderNotifications !== false;
    const weeklyEnabled = settings?.weeklyReportNotifications !== false;

    const startHour = settings?.notificationStartHour || 8;
    const endHour = settings?.notificationEndHour || 22;
    const reminderDays = settings?.reminderDaysThreshold || 3;

    return `âš™ï¸ <b>CONFIGURACIÃ“N DE NOTIFICACIONES</b>

ğŸ‘¤ ${fromtelegramuser.first_name || 'Usuario'}

ğŸ”” <b>TIPOS DE NOTIFICACIONES:</b>
ğŸ“ Graduaciones: ${graduationEnabled ? 'âœ… Activada' : 'âŒ Desactivada'}
ğŸ† Logros: ${milestoneEnabled ? 'âœ… Activada' : 'âŒ Desactivada'}
â° Recordatorios: ${reminderEnabled ? 'âœ… Activada' : 'âŒ Desactivada'}
ğŸ“Š Reportes semanales: ${weeklyEnabled ? 'âœ… Activada' : 'âŒ Desactivada'}

â° <b>HORARIO:</b>
ğŸ• Desde: ${startHour}:00
ğŸ•™ Hasta: ${endHour}:00

âš ï¸ <b>RECORDATORIOS:</b>
ğŸ“… Cada ${reminderDays} dÃ­as sin estudiar

ğŸ”§ <b>COMANDOS DE CONFIGURACIÃ“N:</b>
â€¢ <code>/notificaciones_graduacion on/off</code>
â€¢ <code>/notificaciones_logros on/off</code>
â€¢ <code>/notificaciones_recordatorios on/off</code>
â€¢ <code>/notificaciones_semanales on/off</code>
â€¢ <code>/horario_notificaciones 8 22</code>

ğŸ’¡ <b>Ejemplo:</b>
<code>/notificaciones_graduacion off</code> - Desactivar notificaciones de graduaciÃ³n
<code>/horario_notificaciones 9 21</code> - Recibir notificaciones de 9:00 a 21:00`;

  } catch (error) {
    console.error('âŒ Error en handleConfigurarNotificacionesCommand:', error);
    return `âŒ <b>Error interno</b>\n\nIntÃ©ntalo de nuevo en unos segundos.`;
  }
}

// ==========================================
// ğŸ”” FUNCIONES DE COMANDOS ESPECÃFICOS DE NOTIFICACIONES
// ==========================================

async function handleNotificacionesGraduacionCommand(userid: string, fromtelegramuser: any, messageText: string): Promise<string | null> {
  try {
    console.log('ğŸ“ NOTIFICACIONES_GRADUACION COMMAND - Configurar notificaciones de graduaciÃ³n');

    // Verificar usuario registrado
    const user = await prisma.telegramuser.findUnique({
      where: { telegramUserId: userid }
    });

    if (!user) {
      return `âŒ <b>Usuario no registrado</b>\n\nğŸ”§ EnvÃ­a <code>/start</code> primero para registrarte.`;
    }

    // Parsear comando
    const parts = messageText.trim().split(' ');
    if (parts.length < 2) {
      return `âŒ <b>Uso incorrecto</b>\n\nğŸ”§ <b>Uso correcto:</b>\n<code>/notificaciones_graduacion on</code> - Activar\n<code>/notificaciones_graduacion off</code> - Desactivar\n\nğŸ’¡ <b>Ejemplo:</b>\n<code>/notificaciones_graduacion on</code>`;
    }

    const setting = parts[1].toLowerCase();
    if (setting !== 'on' && setting !== 'off') {
      return `âŒ <b>ParÃ¡metro invÃ¡lido</b>\n\nâœ… <b>Opciones vÃ¡lidas:</b>\nâ€¢ <code>on</code> - Activar\nâ€¢ <code>off</code> - Desactivar\n\nğŸ’¡ <b>Ejemplo:</b>\n<code>/notificaciones_graduacion on</code>`;
    }

    const enabled = setting === 'on';

    // Actualizar configuraciÃ³n
    const { NotificationService } = await import('@/services/notificationService');
    const notificationService = new NotificationService();
    await notificationService.updateUserNotificationSettings(user.id, {
      graduationNotifications: enabled
    });

    const status = enabled ? 'âœ… activadas' : 'âŒ desactivadas';
    const emoji = enabled ? 'ğŸ‰' : 'ğŸ˜´';
    
    return `${emoji} <b>NOTIFICACIONES DE GRADUACIÃ“N ${status.toUpperCase()}</b>

ğŸ‘¤ ${fromtelegramuser.first_name || 'Usuario'}

ğŸ“ <b>Estado:</b> ${status}

${enabled ? 
  `ğŸ”” <b>RecibirÃ¡s notificaciones cuando:</b>\nâ€¢ GradÃºes una pregunta fallada\nâ€¢ Alcances hitos de graduaciÃ³n (5, 10, 25, etc.)\nâ€¢ Completes sesiones exitosas de repaso\n\nğŸ’¡ <b>Tip:</b> Las notificaciones respetan tu horario configurado.` :
  `ğŸ˜´ <b>No recibirÃ¡s notificaciones de:</b>\nâ€¢ Preguntas graduadas\nâ€¢ Hitos de graduaciÃ³n\nâ€¢ Sesiones de repaso completadas\n\nğŸ’¡ <b>Tip:</b> Puedes reactivarlas cuando quieras.`
}

ğŸ”§ <b>Otros comandos:</b>
â€¢ <code>/configurar_notificaciones</code> - Ver todas las configuraciones
â€¢ <code>/notificaciones_logros ${enabled ? 'off' : 'on'}</code> - ${enabled ? 'Desactivar' : 'Activar'} notificaciones de logros`;

  } catch (error) {
    console.error('âŒ Error en handleNotificacionesGraduacionCommand:', error);
    return `âŒ <b>Error interno</b>\n\nIntÃ©ntalo de nuevo en unos segundos.`;
  }
}

async function handleNotificacionesLogrosCommand(userid: string, fromtelegramuser: any, messageText: string): Promise<string | null> {
  try {
    console.log('ğŸ† NOTIFICACIONES_LOGROS COMMAND - Configurar notificaciones de logros');

    // Verificar usuario registrado
    const user = await prisma.telegramuser.findUnique({
      where: { telegramUserId: userid }
    });

    if (!user) {
      return `âŒ <b>Usuario no registrado</b>\n\nğŸ”§ EnvÃ­a <code>/start</code> primero para registrarte.`;
    }

    // Parsear comando
    const parts = messageText.trim().split(' ');
    if (parts.length < 2) {
      return `âŒ <b>Uso incorrecto</b>\n\nğŸ”§ <b>Uso correcto:</b>\n<code>/notificaciones_logros on</code> - Activar\n<code>/notificaciones_logros off</code> - Desactivar\n\nğŸ’¡ <b>Ejemplo:</b>\n<code>/notificaciones_logros on</code>`;
    }

    const setting = parts[1].toLowerCase();
    if (setting !== 'on' && setting !== 'off') {
      return `âŒ <b>ParÃ¡metro invÃ¡lido</b>\n\nâœ… <b>Opciones vÃ¡lidas:</b>\nâ€¢ <code>on</code> - Activar\nâ€¢ <code>off</code> - Desactivar\n\nğŸ’¡ <b>Ejemplo:</b>\n<code>/notificaciones_logros on</code>`;
    }

    const enabled = setting === 'on';

    // Actualizar configuraciÃ³n
    const { NotificationService } = await import('@/services/notificationService');
    const notificationService = new NotificationService();
    await notificationService.updateUserNotificationSettings(user.id, {
      milestoneNotifications: enabled
    });

    const status = enabled ? 'âœ… activadas' : 'âŒ desactivadas';
    const emoji = enabled ? 'ğŸ†' : 'ğŸ˜´';
    
    return `${emoji} <b>NOTIFICACIONES DE LOGROS ${status.toUpperCase()}</b>

ğŸ‘¤ ${fromtelegramuser.first_name || 'Usuario'}

ğŸ† <b>Estado:</b> ${status}

${enabled ? 
  `ğŸ”” <b>RecibirÃ¡s notificaciones cuando:</b>\nâ€¢ Alcances hitos importantes (5, 10, 25, 50, 100 graduaciones)\nâ€¢ Consigas rachas destacadas\nâ€¢ Desbloquees nuevos niveles\nâ€¢ Logres precisiÃ³n excepcional\n\nğŸ‰ <b>Â¡Celebra tus logros!</b>` :
  `ğŸ˜´ <b>No recibirÃ¡s notificaciones de:</b>\nâ€¢ Hitos de graduaciÃ³n\nâ€¢ Rachas destacadas\nâ€¢ Nuevos niveles\nâ€¢ Logros desbloqueados\n\nğŸ’¡ <b>Tip:</b> Puedes reactivarlas cuando quieras.`
}

ğŸ”§ <b>Otros comandos:</b>
â€¢ <code>/configurar_notificaciones</code> - Ver todas las configuraciones
â€¢ <code>/notificaciones_graduacion ${enabled ? 'off' : 'on'}</code> - ${enabled ? 'Desactivar' : 'Activar'} notificaciones de graduaciÃ³n`;

  } catch (error) {
    console.error('âŒ Error en handleNotificacionesLogrosCommand:', error);
    return `âŒ <b>Error interno</b>\n\nIntÃ©ntalo de nuevo en unos segundos.`;
  }
}

async function handleNotificacionesRecordatoriosCommand(userid: string, fromtelegramuser: any, messageText: string): Promise<string | null> {
  try {
    console.log('â° NOTIFICACIONES_RECORDATORIOS COMMAND - Configurar recordatorios');

    // Verificar usuario registrado
    const user = await prisma.telegramuser.findUnique({
      where: { telegramUserId: userid }
    });

    if (!user) {
      return `âŒ <b>Usuario no registrado</b>\n\nğŸ”§ EnvÃ­a <code>/start</code> primero para registrarte.`;
    }

    // Parsear comando
    const parts = messageText.trim().split(' ');
    if (parts.length < 2) {
      return `âŒ <b>Uso incorrecto</b>\n\nğŸ”§ <b>Uso correcto:</b>\n<code>/notificaciones_recordatorios on</code> - Activar\n<code>/notificaciones_recordatorios off</code> - Desactivar\n\nğŸ’¡ <b>Ejemplo:</b>\n<code>/notificaciones_recordatorios on</code>`;
    }

    const setting = parts[1].toLowerCase();
    if (setting !== 'on' && setting !== 'off') {
      return `âŒ <b>ParÃ¡metro invÃ¡lido</b>\n\nâœ… <b>Opciones vÃ¡lidas:</b>\nâ€¢ <code>on</code> - Activar\nâ€¢ <code>off</code> - Desactivar\n\nğŸ’¡ <b>Ejemplo:</b>\n<code>/notificaciones_recordatorios on</code>`;
    }

    const enabled = setting === 'on';

    // Actualizar configuraciÃ³n
    const { NotificationService } = await import('@/services/notificationService');
    const notificationService = new NotificationService();
    await notificationService.updateUserNotificationSettings(user.id, {
      reminderNotifications: enabled
    });

    const status = enabled ? 'âœ… activados' : 'âŒ desactivados';
    const emoji = enabled ? 'â°' : 'ğŸ˜´';
    
    return `${emoji} <b>RECORDATORIOS ${status.toUpperCase()}</b>

ğŸ‘¤ ${fromtelegramuser.first_name || 'Usuario'}

â° <b>Estado:</b> ${status}

${enabled ? 
  `ğŸ”” <b>RecibirÃ¡s recordatorios cuando:</b>\nâ€¢ Pases 3 dÃ­as sin estudiar\nâ€¢ Tengas preguntas falladas pendientes\nâ€¢ Haya sido mucho tiempo desde tu Ãºltima sesiÃ³n\n\nğŸ’¡ <b>Frecuencia:</b> MÃ¡ximo 1 recordatorio cada 3 dÃ­as\nâ° <b>Horario:</b> Respeta tu horario configurado` :
  `ğŸ˜´ <b>No recibirÃ¡s recordatorios de:</b>\nâ€¢ Inactividad prolongada\nâ€¢ Preguntas pendientes\nâ€¢ Sesiones de estudio\n\nğŸ’¡ <b>Tip:</b> Puedes reactivarlos cuando quieras.`
}

ğŸ”§ <b>Otros comandos:</b>
â€¢ <code>/configurar_notificaciones</code> - Ver todas las configuraciones
â€¢ <code>/horario_notificaciones 8 22</code> - Configurar horario
â€¢ <code>/notificaciones_semanales ${enabled ? 'off' : 'on'}</code> - ${enabled ? 'Desactivar' : 'Activar'} reportes semanales`;

  } catch (error) {
    console.error('âŒ Error en handleNotificacionesRecordatoriosCommand:', error);
    return `âŒ <b>Error interno</b>\n\nIntÃ©ntalo de nuevo en unos segundos.`;
  }
}

async function handleNotificacionesSemanalesCommand(userid: string, fromtelegramuser: any, messageText: string): Promise<string | null> {
  try {
    console.log('ğŸ“Š NOTIFICACIONES_SEMANALES COMMAND - Configurar reportes semanales');

    // Verificar usuario registrado
    const user = await prisma.telegramuser.findUnique({
      where: { telegramUserId: userid }
    });

    if (!user) {
      return `âŒ <b>Usuario no registrado</b>\n\nğŸ”§ EnvÃ­a <code>/start</code> primero para registrarte.`;
    }

    // Parsear comando
    const parts = messageText.trim().split(' ');
    if (parts.length < 2) {
      return `âŒ <b>Uso incorrecto</b>\n\nğŸ”§ <b>Uso correcto:</b>\n<code>/notificaciones_semanales on</code> - Activar\n<code>/notificaciones_semanales off</code> - Desactivar\n\nğŸ’¡ <b>Ejemplo:</b>\n<code>/notificaciones_semanales on</code>`;
    }

    const setting = parts[1].toLowerCase();
    if (setting !== 'on' && setting !== 'off') {
      return `âŒ <b>ParÃ¡metro invÃ¡lido</b>\n\nâœ… <b>Opciones vÃ¡lidas:</b>\nâ€¢ <code>on</code> - Activar\nâ€¢ <code>off</code> - Desactivar\n\nğŸ’¡ <b>Ejemplo:</b>\n<code>/notificaciones_semanales on</code>`;
    }

    const enabled = setting === 'on';

    // Actualizar configuraciÃ³n
    const { NotificationService } = await import('@/services/notificationService');
    const notificationService = new NotificationService();
    await notificationService.updateUserNotificationSettings(user.id, {
      weeklyReportNotifications: enabled
    });

    const status = enabled ? 'âœ… activados' : 'âŒ desactivados';
    const emoji = enabled ? 'ğŸ“Š' : 'ğŸ˜´';
    
    return `${emoji} <b>REPORTES SEMANALES ${status.toUpperCase()}</b>

ğŸ‘¤ ${fromtelegramuser.first_name || 'Usuario'}

ğŸ“Š <b>Estado:</b> ${status}

${enabled ? 
  `ğŸ”” <b>RecibirÃ¡s cada domingo:</b>\nâ€¢ Resumen de tu progreso semanal\nâ€¢ Preguntas graduadas en la semana\nâ€¢ EstadÃ­sticas de precisiÃ³n\nâ€¢ Comparativa con semana anterior\nâ€¢ Recomendaciones personalizadas\n\nğŸ“… <b>CuÃ¡ndo:</b> Domingos por la maÃ±ana\nâ° <b>Horario:</b> Respeta tu horario configurado` :
  `ğŸ˜´ <b>No recibirÃ¡s:</b>\nâ€¢ ResÃºmenes semanales\nâ€¢ EstadÃ­sticas de progreso\nâ€¢ Comparativas semanales\nâ€¢ Recomendaciones personalizadas\n\nğŸ’¡ <b>Tip:</b> Puedes reactivarlos cuando quieras.`
}

ğŸ”§ <b>Otros comandos:</b>
â€¢ <code>/configurar_notificaciones</code> - Ver todas las configuraciones
â€¢ <code>/notificaciones_recordatorios ${enabled ? 'off' : 'on'}</code> - ${enabled ? 'Desactivar' : 'Activar'} recordatorios
â€¢ <code>/estadisticas</code> - Ver tus estadÃ­sticas actuales`;

  } catch (error) {
    console.error('âŒ Error en handleNotificacionesSemanalesCommand:', error);
    return `âŒ <b>Error interno</b>\n\nIntÃ©ntalo de nuevo en unos segundos.`;
  }
}

// ==============================================
// ğŸ“Š HANDLER DE COMANDO DE QUOTAS Y LÃMITES
// ==============================================

async function handleMiQuotaCommand(userid: string, fromtelegramuser: any): Promise<string | null> {
  try {
    console.log('ğŸ“Š MI QUOTA COMMAND - Ver lÃ­mites y uso actual');

    // Verificar usuario registrado
    const user = await prisma.telegramuser.findUnique({
      where: { telegramUserId: userid }
    });

    if (!user) {
      return `âŒ <b>Usuario no registrado</b>\n\nğŸ”§ EnvÃ­a <code>/start</code> primero para registrarte.`;
    }

    // Obtener suscripciÃ³n actual usando SQL directo
    const subscriptionCheck = await prisma.$queryRaw`
      SELECT 
        tu."telegramUserId",
        tu."firstName",
        s."status",
        s."endDate",
        p."name" as "planName",
        p."displayName" as "planDisplayName",
        p."price",
        p."dailyQuestionsLimit",
        p."maxSimulationsPerDay",
        p."canUseFailedQuestions",
        p."canUseAdvancedStats",
        p."canUseSimulations",
        p."canUseAIAnalysis",
        p."canUseMoodleIntegration"
      FROM "TelegramUser" tu
      LEFT JOIN "UserSubscription" s ON tu."id" = s."userid" AND s."status" = 'active' AND s."endDate" >= NOW()
      LEFT JOIN "SubscriptionPlan" p ON s."planId" = p."id"
      WHERE tu."telegramUserId" = ${userid}
      LIMIT 1
    ` as any[];
    
    const userSubscription = subscriptionCheck[0];
    
    if (!userSubscription || !userSubscription.planName) {
      return `ğŸ”’ <b>SIN SUSCRIPCIÃ“N ACTIVA</b>

ğŸ‘¤ <b>${user.firstName || user.username || 'Usuario'}</b>

âŒ <b>No tienes una suscripciÃ³n activa</b>

ğŸ†“ <b>LÃ­mites actuales (gratuito):</b>
â€¢ ğŸ“š Preguntas privadas: 0/dÃ­a
â€¢ ğŸ”„ Preguntas falladas: No disponible
â€¢ ğŸ¯ Simulacros: No disponible
â€¢ ğŸ“Š EstadÃ­sticas avanzadas: No disponible

ğŸ’¡ <b>Â¿Quieres mÃ¡s funcionalidades?</b>

ğŸ’° <b>PLAN BÃSICO (â‚¬4.99/mes):</b>
â€¢ ğŸ“š 100 preguntas diarias en privado
â€¢ ğŸ”„ Sistema de preguntas falladas
â€¢ ğŸ“Š EstadÃ­sticas bÃ¡sicas

ğŸ’ <b>PLAN PREMIUM (â‚¬9.99/mes):</b>
â€¢ â™¾ï¸ Preguntas ilimitadas
â€¢ ğŸ¯ Simulacros personalizados
â€¢ ğŸ“Š EstadÃ­sticas avanzadas
â€¢ ğŸ”— IntegraciÃ³n Moodle
â€¢ ğŸ¤– AnÃ¡lisis con IA

ğŸš€ <b>SuscrÃ­bete ahora:</b>
â€¢ <code>/basico</code> - Plan BÃ¡sico
â€¢ <code>/premium</code> - Plan Premium
â€¢ <code>/planes</code> - Comparar todos los planes`;
    }

    // Obtener uso actual del dÃ­a usando SQL directo
    const today = new Date().toISOString().split('T')[0]; // Formato YYYY-MM-DD
    
    const usageStats = await prisma.$queryRaw`
      SELECT 
        "questionsUsed",
        "failedQuestionsUsed",
        "simulationsUsed"
      FROM "UserQuotaUsage"
      WHERE "userid" = ${user.id} AND "date" = ${today}::date
      LIMIT 1
    ` as any[];
    
    const todayUsage = usageStats[0] || {
      questionsUsed: 0,
      failedQuestionsUsed: 0,
      simulationsUsed: 0
    };

    const questionsUsed = (todayUsage.questionsUsed || 0) + (todayUsage.failedQuestionsUsed || 0);
    const simulationsUsed = todayUsage.simulationsUsed || 0;

    // Calcular dÃ­as restantes de suscripciÃ³n
    const endDate = userSubscription.endDate ? new Date(userSubscription.endDate) : null;
    const daysRemaining = endDate ? Math.ceil((endDate.getTime() - Date.now()) / (1000 * 60 * 60 * 24)) : null;

    let message = `ğŸ“Š <b>MI ESTADO DE SUSCRIPCIÃ“N</b>\n\n`;
    message += `ğŸ‘¤ <b>${user.firstName || user.username || 'Usuario'}</b>\n\n`;

    // Estado de la suscripciÃ³n
    message += `ğŸ’ <b>PLAN ACTUAL:</b> ${userSubscription.planDisplayName}\n`;
    message += `ğŸ’° <b>Precio:</b> â‚¬${userSubscription.price}/mes\n`;
    message += `ğŸ“‹ <b>Estado:</b> âœ… Activa\n`;
    
    if (daysRemaining !== null) {
      message += `ğŸ“… <b>RenovaciÃ³n:</b> ${daysRemaining} dÃ­as\n`;
    }
    
    message += `\nğŸ“Š <b>USO DE HOY:</b>\n`;

    // Mostrar lÃ­mites y uso actual
    if (userSubscription.dailyQuestionsLimit === null) {
      message += `ğŸ“š <b>Preguntas:</b> â™¾ï¸ ILIMITADAS\n`;
    } else {
      const questionsLimit = userSubscription.dailyQuestionsLimit || 100;
      const remaining = Math.max(0, questionsLimit - questionsUsed);
      message += `ğŸ“š <b>Preguntas:</b> ${questionsUsed}/${questionsLimit} (${remaining} restantes)\n`;
    }

    if (userSubscription.maxSimulationsPerDay === null) {
      message += `ğŸ¯ <b>Simulacros:</b> â™¾ï¸ ILIMITADOS\n`;
    } else {
      const simulationsLimit = userSubscription.maxSimulationsPerDay || 1;
      const remainingSimulations = Math.max(0, simulationsLimit - simulationsUsed);
      message += `ğŸ¯ <b>Simulacros:</b> ${simulationsUsed}/${simulationsLimit} (${remainingSimulations} restantes)\n`;
    }

    // Funcionalidades disponibles
    message += `\nğŸ® <b>FUNCIONALIDADES ACTIVAS:</b>\n`;
    message += `${userSubscription.canUseFailedQuestions ? 'âœ…' : 'âŒ'} Preguntas falladas\n`;
    message += `${userSubscription.canUseAdvancedStats ? 'âœ…' : 'âŒ'} EstadÃ­sticas avanzadas\n`;
    message += `${userSubscription.canUseSimulations ? 'âœ…' : 'âŒ'} Simulacros personalizados\n`;
    message += `${userSubscription.canUseAIAnalysis ? 'âœ…' : 'âŒ'} AnÃ¡lisis con IA\n`;
    message += `${userSubscription.canUseMoodleIntegration ? 'âœ…' : 'âŒ'} IntegraciÃ³n Moodle\n`;

    // MotivaciÃ³n y acciones
    if (userSubscription.planName === 'basic') {
      const remainingQuestions = userSubscription.dailyQuestionsLimit ? Math.max(0, userSubscription.dailyQuestionsLimit - questionsUsed) : 0;
      if (remainingQuestions <= 10) {
        message += `\nâš ï¸ <b>POCAS PREGUNTAS RESTANTES</b>\n`;
        message += `Te quedan solo ${remainingQuestions} preguntas hoy.\n\n`;
        message += `ğŸš€ <b>Â¿Quieres mÃ¡s?</b>\n`;
        message += `â€¢ <code>/premium</code> - Actualizar a Premium (ilimitado)`;
      } else {
        message += `\nğŸ’¡ <b>Â¿Quieres mÃ¡s funcionalidades?</b>\n`;
        message += `â€¢ <code>/premium</code> - Actualizar a Premium`;
      }
    } else if (userSubscription.planName === 'premium') {
      message += `\nğŸ‰ <b>Â¡Tienes acceso completo!</b>\n`;
      message += `Disfruta de todas las funcionalidades sin lÃ­mites.`;
    }

    message += `\n\nğŸ“ <b>GESTIONAR SUSCRIPCIÃ“N:</b>\n`;
    message += `â€¢ <code>/mi_plan</code> - Detalles completos\n`;
    message += `â€¢ <code>/facturas</code> - Historial de pagos\n`;
    message += `â€¢ <code>/cancelar</code> - Cancelar suscripciÃ³n`;

    return message;

  } catch (error) {
    console.error('âŒ Error en handleMiQuotaCommand:', error);
    return `âŒ <b>Error interno</b>\n\nIntÃ©ntalo de nuevo en unos segundos.`;
  }
}

async function handleHorarioNotificacionesCommand(userid: string, fromtelegramuser: any, messageText: string): Promise<string | null> {
  try {
    console.log('ğŸ• HORARIO_NOTIFICACIONES COMMAND - Configurar horario');

    // Verificar usuario registrado
    const user = await prisma.telegramuser.findUnique({
      where: { telegramUserId: userid }
    });

    if (!user) {
      return `âŒ <b>Usuario no registrado</b>\n\nğŸ”§ EnvÃ­a <code>/start</code> primero para registrarte.`;
    }

    // Parsear comando
    const parts = messageText.trim().split(' ');
    if (parts.length < 3) {
      return `âŒ <b>Uso incorrecto</b>\n\nğŸ”§ <b>Uso correcto:</b>\n<code>/horario_notificaciones [hora_inicio] [hora_fin]</code>\n\nğŸ’¡ <b>Ejemplos:</b>\n<code>/horario_notificaciones 8 22</code> - De 8:00 a 22:00\n<code>/horario_notificaciones 9 21</code> - De 9:00 a 21:00\n<code>/horario_notificaciones 7 23</code> - De 7:00 a 23:00\n\nğŸ“ <b>Nota:</b> Usa formato 24 horas (0-23)`;
    }

    const startHour = parseInt(parts[1]);
    const endHour = parseInt(parts[2]);

    // Validar horas
    if (isNaN(startHour) || isNaN(endHour)) {
      return `âŒ <b>Horas invÃ¡lidas</b>\n\nğŸ”§ <b>Formato correcto:</b>\nUsa nÃºmeros enteros de 0 a 23\n\nğŸ’¡ <b>Ejemplos vÃ¡lidos:</b>\n<code>/horario_notificaciones 8 22</code>\n<code>/horario_notificaciones 9 21</code>`;
    }

    if (startHour < 0 || startHour > 23 || endHour < 0 || endHour > 23) {
      return `âŒ <b>Horas fuera de rango</b>\n\nâ° <b>Rango vÃ¡lido:</b> 0 a 23 horas\n\nğŸ’¡ <b>Ejemplos vÃ¡lidos:</b>\nâ€¢ <code>/horario_notificaciones 8 22</code> - 8:00 AM a 10:00 PM\nâ€¢ <code>/horario_notificaciones 9 21</code> - 9:00 AM a 9:00 PM\nâ€¢ <code>/horario_notificaciones 0 23</code> - 12:00 AM a 11:00 PM`;
    }

    if (startHour >= endHour) {
      return `âŒ <b>Horario invÃ¡lido</b>\n\nğŸ• <b>Problema:</b> La hora de inicio debe ser menor que la hora de fin\n\nğŸ’¡ <b>Ejemplos correctos:</b>\nâ€¢ <code>/horario_notificaciones 8 22</code> âœ…\nâ€¢ <code>/horario_notificaciones 9 21</code> âœ…\n\nâŒ <b>Ejemplos incorrectos:</b>\nâ€¢ <code>/horario_notificaciones 22 8</code> âŒ\nâ€¢ <code>/horario_notificaciones 15 15</code> âŒ`;
    }

    // Actualizar configuraciÃ³n
    const { NotificationService } = await import('@/services/notificationService');
    const notificationService = new NotificationService();
    await notificationService.updateUserNotificationSettings(user.id, {
      notificationStartHour: startHour,
      notificationEndHour: endHour
    });

    const startTime = `${startHour.toString().padStart(2, '0')}:00`;
    const endTime = `${endHour.toString().padStart(2, '0')}:00`;
    const duration = endHour - startHour;
    
    return `ğŸ• <b>HORARIO DE NOTIFICACIONES ACTUALIZADO</b>

ğŸ‘¤ ${fromtelegramuser.first_name || 'Usuario'}

â° <b>Nuevo horario:</b>
ğŸŒ… Inicio: ${startTime}
ğŸŒ™ Fin: ${endTime}
â±ï¸ DuraciÃ³n: ${duration} horas

ğŸ”” <b>Â¿QuÃ© significa esto?</b>
â€¢ Solo recibirÃ¡s notificaciones entre ${startTime} y ${endTime}
â€¢ Notificaciones fuera de este horario se pospondrÃ¡n
â€¢ Recordatorios y reportes respetarÃ¡n este horario
â€¢ Notificaciones urgentes (como duelos) pueden llegar en cualquier momento

ğŸ’¡ <b>Recomendaciones por horario:</b>
${startHour <= 8 && endHour >= 20 ? 
  'âœ… <b>Horario amplio</b> - Ideal para recibir todas las notificaciones' :
  startHour >= 9 && endHour <= 21 ? 
  'â° <b>Horario moderado</b> - Perfecto para horario laboral/estudios' :
  'ğŸŒ™ <b>Horario restringido</b> - Algunas notificaciones pueden posponerse'
}

ğŸ”§ <b>Otros comandos:</b>
â€¢ <code>/configurar_notificaciones</code> - Ver todas las configuraciones
â€¢ <code>/notificaciones_recordatorios on/off</code> - Configurar recordatorios
â€¢ <code>/notificaciones_semanales on/off</code> - Configurar reportes semanales`;

  } catch (error) {
    console.error('âŒ Error en handleHorarioNotificacionesCommand:', error);
    return `âŒ <b>Error interno</b>\n\nIntÃ©ntalo de nuevo en unos segundos.`;
  }
}


